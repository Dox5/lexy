<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>lexy: C++ parser combinator library</title><link>https://lexy.foonathan.net/</link><description>Recent content on lexy: C++ parser combinator library</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>2020-2021</copyright><atom:link href="https://lexy.foonathan.net/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://lexy.foonathan.net/benchmark_json/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lexy.foonathan.net/benchmark_json/</guid><description>This benchmark measures the time it takes to validate JSON, i.e. to check whether it is well-formed. Validation was chosen as opposed to parsing, as parsing speed depends on the JSON data structure as well. Implementing an efficient JSON container is out of scope for lexy, so it would have a disadvantage over the specialized JSON libraries.
The average validation times for each input are shown in the boxplots below.</description></item><item><title/><link>https://lexy.foonathan.net/reference/dsl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lexy.foonathan.net/reference/dsl/</guid><description>The rule DSL The rule of a production is specified using a DSL built on top of C++ operator overloading. Everything of the DSL is defined in the namespace lexy::dsl::* and every header available under lexy/dsl/*. The umbrella header lexy/dsl.hpp includes all DSL headers.
A Rule is an object that defines a specific set of input to be parsed. It first tries to match a set of characters from the input by comparing the character at the current reader position to the set of expected characters, temporarily advancing the reader further if necessary.</description></item><item><title/><link>https://lexy.foonathan.net/reference/glossary/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lexy.foonathan.net/reference/glossary/</guid><description>Glossary Branch A rule that has an associated condition and will only be taken if the condition matches. It is used to make decisions in the parsing algorithm.
Callback A function object with a return_type member typedef.
Encoding Set of pre-defined classes that define the text encoding of the input.
Error Callback The callback used to report errors.
Grammar An entry production and all productions referenced by it.</description></item><item><title/><link>https://lexy.foonathan.net/reference/inputs/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lexy.foonathan.net/reference/inputs/</guid><description>Inputs and Encodings An Input defines the input that will be parsed by lexy. It has a corresponding Encoding that controls, among other things, its character type and whether certain rules are available. The Input itself is unchanging and it produces a Reader which remembers the current position of the input during parsing.
Encodings lexy/encoding.hpp namespace lexy { struct default_encoding; struct ascii_encoding; struct utf8_encoding; struct utf16_encoding; struct utf32_encoding; struct raw_encoding; template &amp;lt;typename CharT&amp;gt; using deduce_encoding = /* see below */; enum class encoding_endianness; } An Encoding is a set of pre-defined policy classes that determine the text encoding of an input.</description></item><item><title/><link>https://lexy.foonathan.net/reference/parsing/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lexy.foonathan.net/reference/parsing/</guid><description>Matching, parsing and validating The Production concept struct Production { static constexpr auto rule = …; static constexpr auto whitespace = …; // optional static constexpr auto value = …; // optional }; A Production is type containing a rule and optional callbacks that produce the value. A grammar contains an entry production where parsing begins and all productions referenced by it.
Tip It is recommended to put all productions of a grammar into a separate namespace.</description></item><item><title>Reference - lexy</title><link>https://lexy.foonathan.net/reference/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lexy.foonathan.net/reference/</guid><description>This is the reference documentation for lexy.
If anything in the documentation could be improved (and there is probably a lot), please raise an issue or — even better — create a PR. Thank you!
Inputs and Encodings An Input defines the input that will be parsed by lexy. It has a corresponding Encoding that controls, among other things, its character type and whether certain rules are available.</description></item><item><title>Tutorial - lexy</title><link>https://lexy.foonathan.net/tutorial/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://lexy.foonathan.net/tutorial/</guid><description>This tutorial introduces you to the basics of lexy. Our goal is to parse some simple configuration file of a software package.
A sample input file can look like this:
package.config name = lexy version = 0.0.0 authors = [&amp;#34;Jonathan Müller&amp;#34;] And we want to parse it into the following C++ data structure using lexy:
PackageConfig struct PackageVersion { int major; int minor; int patch; }; struct PackageConfig { std::string name; PackageVersion version; std::vector&amp;lt;std::string&amp;gt; authors; }; The final source code can be found at examples/tutorial.</description></item></channel></rss>