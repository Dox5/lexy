---
layout: header
header: "lexy/dsl/production.hpp"
entities:
  "lexy::dsl::inline_": inline_
  "lexy::dsl::p": p
  "lexy::dsl::recurse": recurse
---

[.lead]
The `inline_`, `p`, and `recurse` rules.

[#inline_]
== Rule `lexy::dsl::inline_`

{{% interface %}}
----
namespace lexy::dsl
{
    template <_production_ P>
    constexpr _rule_ auto inline_;

    template <_production_ P>
      requires _token-rule_<production_rule<P>>
    constexpr _token-rule_ auto inline_;

    template <_production_ P>
      requires _branch-rule_<production_rule<P>>
    constexpr _branch-rule_ auto inline_;
}
----

[.lead]
`inline_` is a rule that parses the rule of production `P` as part of the current production.

Requires::
  `P` is a complete type, i.e. `p` cannot be used for recursion.
Matching::
  Matches `P::rule`.
(Branch) Parsing::
  Parses `P::rule`.
Errors::
  All errors raised by `P::rule`.
  The rule then fails if `P::rule` has failed.
Values::
  All values produced by `P::rule`.

{{% playground-example inline "Parse a child production inline" %}}

TIP: Use `inline_` when you need to parse a production as part of the whitespace rule.

[#p]
== Rule `lexy::dsl::p`

{{% interface %}}
----
namespace lexy::dsl
{
    template <_production_ P>
    constexpr _rule_ auto p;

    template <_production_ P>
      requires _branch-rule_<production_rule<P>>
    constexpr _branch-rule_ auto p;
}
----

[.lead]
`p` is a rule that parses the production `P`.

Requires::
  `P` is a complete type, i.e. `p` cannot be used for recursion.
(Branch) Parsing::
  Parses `P::rule` in a new context for `P`.
Errors::
  All errors raised by parsing `P::rule`, but forwarded to the new context for `P`.
  The rule fails if `P::rule` has failed.
Values::
  All values produced by `P::rule` are forwarded to the new context, e.g. to `P::value`.
  The final value of the context is produced as the single value for `p`.
Parse tree::
  * If `P` inherits from {{% docref "lexy::transparent_production" %}}, the nodes generated by `P::rule` are added to the parse tree as if they were added by `p` itself.
  * If `P` inherits from {{% docref "lexy::token_production" %}}, adjacent token nodes that have the same token kind are merged to a single token node.
    Otherwise, the nodes are added as described by the case above or below.
  * Otherwise, it creates a single production node for `P`.
    Its children are all the nodes generated by `P::rule`.

{{% playground-example default "Parse a child production" %}}

{{% playground-example choice_production "Productions with branches" %}}

NOTE: The `p` rule cannot handle direct or indirect recursion, as `P` must be a complete type.

CAUTION: While parsing `P::rule`, the {{% docref "whitespace" "current whitespace rule" %}} can be different.
If whitespace parsing has been disabled using {{% docref "lexy::dsl::no_whitespace" %}},
it is temporarily re-enabled while parsing `P::rule`.
If whitespace parsing has been disabled because the current production inherits from {{% docref "lexy::token_production" %}},
it is still disabled, unless `P` explicitly defines a new whitespace rule.

[#recurse]
== Rule `lexy::dsl::recurse`

{{% interface %}}
----
namespace lexy::dsl
{
    template <_production_ P>
    constexpr _rule_ auto recurse;
}
----

[.lead]
`recurse` is a rule that parses the production `P` but supports recursion.

It behaves exactly the same as the `p` rule.
The only difference is that `P` does not need to be a complete type, which allows recursion.
For the same reason, `recurse<P>` is never a branch rule.

{{% playground-example recurse "Parse a parenthesized expression" %}}

WARNING: Left recursion will create an infinite loop.
Use {{% docref "lexy::dsl::loop" %}} or {{% docref "lexy::dsl::list"%}} instead.

