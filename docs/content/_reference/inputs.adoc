== Tokens

=== Token Kind

.`lexy/token.hpp`
[source,cpp]
----
namespace lexy
{
    enum predefined_token_kind
    {
        unknown_token_kind,
        eof_token_kind,
        position_token_kind,
        identifier_token_kind,
    };

    template <typename TokenKind = void>
    class token_kind
    {
    public:
        constexpr token_kind() noexcept;
        constexpr token_kind(predefined_token_kind value) noexcept;
        constexpr token_kind(TokenKind value) noexcept;
        template <typename TokenRule>
        constexpr token_kind(TokenRule token_rule) noexcept;

        constexpr explicit operator bool() const noexcept;

        constexpr bool is_predefined() const noexcept;

        constexpr const char* name() const noexcept;

        constexpr TokenKind get() const noexcept;

        static constexpr std::uint_least16_t to_raw(token_kind<TokenKind> kind) noexcept;
        static constexpr token_kind<TokenKind> from_raw(std::uint_least16_t kind) noexcept;

        friend constexpr bool operator==(token_kind lhs, token_kind rhs) noexcept;
        friend constexpr bool operator!=(token_kind lhs, token_kind rhs) noexcept;
    };
}
----

The class `lexy::token_kind` identifies a token rule.
It is merely a wrapper over the specified `TokenKind`, which is an enum.
If `TokenKind` is `void`, it is a wrapper over an `int`.

A token kind can represent any of the `lexy::predefined_token_kind` as well as any values specified in the given enum,
or any integer value.
Predefined token kinds are mapped to spare enum values.

==== Constructors

[source,cpp]
----
constexpr token_kind() noexcept;                         // <1>

constexpr token_kind(predefined_token_kind value) noexcept; // <2>

constexpr token_kind(TokenKind value) noexcept; // <3>

template <typename TokenRule>
constexpr token_kind(TokenRule token_rule) noexcept; // <4>
----
<1> Creates an unknown token kind.
<2> Creates a predefined token kind.
<3> Creates the specified token kind, if `TokenKind` is `void`, constructor takes an `int`.
<4> Creates a token kind from a token rule.

The token kind of a rule is computed as follows:

* If the token rule was associated with a token kind by calling `.kind<value>`, the resulting kind is the specified `value>`.
* Otherwise, if the map found at `lexy::token_kind_map_for<TokenKind>` contains a mapping for the `TokenRule`, it uses that.
* Otherwise, the token kind is unknown.

==== Access

[source,cpp]
----
constexpr explicit operator bool() const noexcept; // <1>

constexpr bool is_predefined() const noexcept; // <2>

constexpr const char* name() const noexcept; // <3>

constexpr TokenKind get() const noexcept; // <4>
----
<1> Returns `true` if the token kind is not unknown, `false` otherwise.
<2> Returns `true` if the token kind one of the `lexy::predefined_token_kind`s, `false` otherwise.
<3> Returns the name of the token kind.
<4> Returns the underlying value of the token kind, which is some other value for predefined tokens.

The name of a token kind is determined as follows:

* If the `TokenKind` is `void`, the name is `"token"` for all token kinds.
* Otherwise, if the token kind is unknown, the name is `"token"`.
* Otherwise, if the token kind is predefined, the name describes the predefined token.
* Otherwise, if ADL finds an overload `const char* token_kind_name(TokenKind kind)`,
  returns that as the name.
* Otherwise, the name is `"token"` for all tokens.

=== Token Kind Map

.`lexy/token.hpp`
[source,cpp]
----
namespace lexy
{
    class Token-Kind-Map
    {
    public:
        template <auto TokenKind, typename TokenRule>
        consteval Token-Kind-Map map(TokenRule) const;
    };

    inline constexpr auto token_kind_map = Token-Kind-Map{};

    template <typename TokenKind>
    constexpr auto token_kind_map_for = token_kind_map;
}
----

There are two ways to associate a token kind with a token rule.
Either by calling `.kind<Kind>` on the token rule and giving it a value there,
or by specializing the `lexy::token_kind_map_for` for your `TokenKind` enumeration.

.Example
[%collapsible]
====
[source,cpp]
----
enum class my_token_kind // <1>
{
    code_point,
    period,
    open_paren,
    close_paren,
};

// <2>
template <>
constexpr auto lexy::token_kind_map_for<my_token_kind>
    = lexy::token_kind_map.map<my_token_kind::code_point>(lexy::dsl::code_point)
                          .map<my_token_kind::period>(lexy::dsl::period)
                          .map<my_token_kind::open_paren>(lexy::dsl::parenthesized.open())
                          .map<my_token_kind::close_paren>(lexy::dsl::parenthesized.close());
----
<1> Define your `TokenKind` enumeration.
<2> Define the mapping of token rules to enumeration values.
====

NOTE: The token kind is only relevant when `lexy::parse_as_tree()` is used to parse the input.

=== Token

.`lexy/token.hpp`
----
namespace lexy
{
    template <typename Reader, typename TokenKind = void>
    class token
    {
    public:
        explicit constexpr token(token_kind<TokenKind> kind, lexy::lexeme<Reader> lex) noexcept;
        explicit constexpr token(token_kind<TokenKind> kind,
                                 typename Reader::iterator begin,
                                 typename Reader::iterator end) noexcept;

        constexpr token_kind<TokenKind> kind() const noexcept;
        constexpr auto lexeme() const noexcept;

        constexpr auto name() const noexcept { return kind().name(); }

        constexpr auto position() const noexcept -> typename Reader::iterator
        {
            return lexeme().begin();
        }
    };

    template <typename Input, typename TokenKind = void>
    using token_for = token<input_reader<Input>, TokenKind>;
}
----

The class `lexy::token` just combines a `lexy::token_kind` and a `lexy::lexeme`.

