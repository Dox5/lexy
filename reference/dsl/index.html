<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>lexy: C++ parser combinator library</title><style>:root{--white: white;--header-white: rgba(255, 255, 255, .75);--background-color: #fdfdfd;--default-color: #101010;--heading-color: #0A0A0A;--link-color: #2A2A2A;--gray-highlight-color: #aaaaaa;--highlight-color: #2861ce}@media(prefers-color-scheme:dark){:root{--white: #020202;--header-white: rgba(2, 2, 2, .75);--background-color: #222222;--default-color: #efefef;--heading-color: #f5f5f5;--link-color: #d5d5d5;--gray-highlight-color: #555555}}nav#menu div.menu-container,main{max-width:1200px;margin:0 auto;padding:0 10px}@media(min-width:800px){article{max-width:900px;margin:0 auto;padding:0 10px}}html{position:relative;min-height:100%;margin:0;padding:0}body{font-family:serif;font-size:18px;color:var(--default-color);background-color:var(--background-color);width:100%;padding:0;margin:0}main{margin-bottom:75px}h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:700;line-height:1.15em;color:var(--heading-color);margin:0 0 .4em}h1{font-size:2em}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h5{font-size:1.15em}h6{font-size:1.1em}a{color:var(--link-color);transition:color ease .3s}a:hover{color:var(--highlight-color)}a:focus{outline:none}br{margin:1em}article p,article ul,article ol,article dl{hyphens:auto;text-align:justify}nav#menu{width:100%;padding:0;background-color:var(--white);border-bottom:2px solid var(--highlight-color);font-family:sans-serif;font-size:1.3em}nav#menu div.menu-container{display:flex}nav#menu div.menu-container ul{display:flex;flex-direction:row;align-items:center;padding:0;list-style:none}nav#menu div.menu-container ul li a{text-decoration:none}nav#menu div.menu-container ul li a.active{border-width:0 0 2px;border-style:solid;border-color:var(--highlight-color)}nav#menu div.menu-container ul#home{padding-left:0;padding-right:10px}nav#menu div.menu-container ul#home li{font-weight:700}nav#menu div.menu-container ul#main{margin-left:auto}nav#menu div.menu-container ul#main li{padding-left:20px}@media(max-width:600px){nav#menu div.menu-container ul#main{flex-direction:column;align-items:flex-end;margin:5px 10px 0 auto}}footer#page-footer{position:absolute;bottom:0;left:0;right:0;height:2em;display:flex;justify-content:space-between;font-size:.8em;font-weight:200;line-height:1em;border-top:1px solid #ccc}footer#page-footer section{padding-left:1em;padding-right:1em;padding-top:.5em;width:100%}footer#page-footer .copyright{text-align:left}footer#page-footer .patreon{text-align:center}footer#page-footer .poweredby{text-align:right}@media(max-width:450px){footer#page-footer{flex-direction:column;align-items:flex-start}footer#page-footer section{text-align:initial!important;width:initial}}aside.toc{display:none}@media(min-width:1200px){aside.toc{display:initial;position:sticky;top:1em;float:left;width:300px}aside.toc header{font-weight:700}aside.toc ul{list-style:none;padding:0}aside.toc ul ul{padding-left:1em;padding-bottom:.5em}aside.toc a{text-decoration:none}aside.toc~article{padding-left:300px}}article .admonitionblock{margin-bottom:1em}article .admonitionblock td.icon{width:75px;font-weight:700;border-right:1px solid var(--gray-highlight-color);padding:.5em}article .admonitionblock td.content{padding-left:.5em}article details{padding-bottom:1em}article details summary{font-weight:700}article dl dt{font-weight:700}article dl dd{margin-top:-.9em}article dl dd dt{margin-top:.9em}article div.sidebarblock{border:1px solid var(--gray-highlight-color);padding:.75em;margin:1em}article div.sidebarblock p{margin:0}article :not(td)>div.title{font-style:italic;margin-bottom:-.9em}article code{font-family:Inconsolata,monospace,sans-serif}article pre{overflow:auto;padding:10px;background:var(--white);border:1px solid var(--gray-highlight-color);line-height:1.1}article .colist{margin-top:-.5em}article .colist ol{counter-reset:list}article .colist ol li{counter-increment:list;padding-left:1em}article .colist ol ::marker{content:"(" counter(list)")";font-weight:700}article .colist p{margin:0}article .highlight{}article .highlight .c{color:#998;font-style:italic}article .highlight .k{color:#458;font-weight:700}article .highlight .o{color:red}article .highlight .p{color:red}article .highlight .err{color:red}article .highlight .cm{color:#998;font-style:italic}article .highlight .cp{color:green;font-weight:700}article .highlight .c1{color:#998;font-style:italic}article .highlight .cs{color:#999;font-weight:700;font-style:italic}article .highlight .gd{color:#000;background-color:#fdd}article .highlight .gd .x{color:#000;background-color:#faa}article .highlight .ge{font-style:italic}article .highlight .gr{color:#a00}article .highlight .gh{color:#999}article .highlight .gi{color:#000;background-color:#dfd}article .highlight .gi .x{color:#000;background-color:#afa}article .highlight .go{color:#888}article .highlight .gp{color:#555}article .highlight .gs{font-weight:700}article .highlight .gu{color:#aaa}article .highlight .gt{color:#a00}article .highlight .kc{color:#458;font-weight:700}article .highlight .kd{color:#458;font-weight:700}article .highlight .kp{color:#458;font-weight:700}article .highlight .kr{color:#458;font-weight:700}article .highlight .kt{color:#458;font-weight:700}article .highlight .m{color:#ff8000}article .highlight .s{color:green}article .highlight .ow{font-weight:700}article .highlight .w{color:#bbb}article .highlight .mf{color:#ff8000}article .highlight .mh{color:#ff8000}article .highlight .mi{color:#ff8000}article .highlight .mo{color:#ff8000}article .highlight .sb{color:#d14}article .highlight .sc{color:#d14}article .highlight .sd{color:#d14}article .highlight .s2{color:#d14}article .highlight .se{color:#d14}article .highlight .sh{color:#d14}article .highlight .si{color:#d14}article .highlight .sx{color:#d14}article .highlight .sr{color:#009926}article .highlight .s1{color:#d14}article .highlight .ss{color:#990073}article .highlight .bp{color:#999}article .highlight .vc{color:teal}article .highlight .vg{color:teal}article .highlight .vi{color:teal}article .highlight .il{color:#099}</style></head><body><nav id=menu><div class=menu-container><ul id=home><li><a href=/>lexy: C++ parser combinator library</a></li></ul><ul id=main><li><a href=/tutorial/>Tutorial</a></li><li><a href=/reference/>Reference</a></li><li><a href=https://github.com/foonathan/lexy>GitHub</a></li></ul></nav><main id=content><aside class=toc><header><a href=#>Table of Contents</a></header><nav id=TableOfContents></nav></aside><article><div class=sect1><h2 id=_the_rule_dsl>The rule DSL</h2><div class=sectionbody><div class=paragraph><p>The rule of a production is specified using a DSL built on top of C++ operator overloading.
Everything of the DSL is defined in the namespace <code>lexy::dsl::*</code> and every header available under <code>lexy/dsl/*</code>.
The umbrella header <code>lexy/dsl.hpp</code> includes all DSL headers.</p></div><div class=paragraph><p>A <code>Rule</code> is an object that defines a specific set of input to be parsed.
It first tries to match a set of characters from the input by comparing the character at the current reader position to the set of expected characters,
temporarily advancing the reader further if necessary.
If the matching was successful, a subset of matched characters are consumed by advancing the reader permanently.
The rule can then produce zero or more values, which are eventually forwarded to the value callback of its production.
If the matching was not successful, an error is produced instead.
A failed rule does not consume any characters.</p></div><div class=paragraph><p>A <code>Branch</code> is a rule that has an associated condition.
The parsing algorithm can efficiently check whether the condition would match at the current reader position.
As such, they are used whenever the algorithm needs to decide between multiple alternatives.
Once the branch condition matches, the branch is taken without any additional backtracking.</p></div><div class=paragraph><p>A <code>Token</code> is a special <code>Rule</code> that is an atomic element of the input.
As a rule, it does not produce any value.
Every <code>Token</code> is also a <code>Branch</code> that uses itself as the condition.</p></div><div class=sect2><h3 id=_whitespace>Whitespace</h3><div class=paragraph><p>By default, <code>lexy</code> does not treat whitespace in any special way.
You need to instruct it to do so, using either manual or automatic whitespace skipping.</p></div><div class=paragraph><p>Manual whitespace skipping is done using <code>lexy::dsl::whitespace(rule)</code>.
It skips zero or more whitespace characters defined by <code>rule</code>.
Insert it everywhere you want to skip over whitespace.
See <code>examples/email.cpp</code> or <code>examples/xml.cpp</code> for an example of manual whitespace skipping.</p></div><div class=paragraph><p>Automatic whitespace skipping is done by adding a <code>static constexpr auto whitespace</code> to the root production,
i.e. the production passed to one of the parse functions.
This member is initialized to a rule that defines a single whitespace character.
<code>lexy</code> will then skip zero or more occurrences of <code>::whitespace</code> after every token of the entire grammar.</p></div><div class=paragraph><p>To temporarily disable whitespace skipping for a production, inherit the production from <code>lexy::token_production</code>.
Then whitespace will not be skipped for the rule of the production, and all productions reached from that rule.
Likewise, <code>lexy::dsl::no_whitespace()</code> can be used to disable it for a single rule.</p></div><div class=paragraph><p>See <code>examples/tutorial.cpp</code> or <code>examples/json.cpp</code> for an example of automatic whitespace skipping.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>"Whitespace" can mean literal whitespace characters, but also comments (or whatever you want it to mean).</td></tr></tbody></table></div><h4 id=_lexydslwhitespace_explicit class=discrete><code>lexy::dsl::whitespace</code> (explicit)</h4><div class=listingblock><div class=title><code>lexy/dsl/whitespace.hpp</code></div><div class=content><pre>whitespace(rule) : Rule

whitespace(rule_a) | rule_b = whitespace(rule_a | rule_b)
whitespace(rule_a) / rule_b = whitespace(rule_a / rule_b)</pre></div></div><div class=paragraph><p>The explicit <code>whitespace</code> rule matches <code>rule</code> zero or more times and treats the result as whitespace.
This happens regardless of the state of automatic whitespace skipping.</p></div><div class=paragraph><p>If the whitespace rule is used inside a choice or alternative, the entire choice/alternative is treated as whitespace instead.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p><code>rule</code> is a branch or a choice rule.
It must not produce any values.</p></dd><dt class=hdlist1>Matches</dt><dd><p>While the branch condition of <code>rule</code> or any of the branch conditions of the choices match,
match and consume <code>rule</code>.
This will only stop once the branch conditions no longer match.
While matching and consuming <code>rule</code>, automatic whitespace skipping is disabled.</p></dd><dt class=hdlist1>Values</dt><dd><p>None.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by <code>rule</code> after the branch condition has been matched.</p></dd></dl></div><h4 id=_lexydslwhitespace_implicit class=discrete><code>lexy::dsl::whitespace</code> (implicit)</h4><div class=listingblock><div class=title><code>lexy/dsl/whitespace.hpp</code></div><div class=content><pre>whitespace : Rule = whitespace(automatic_whitespace_rule)</pre></div></div><div class=paragraph><p>The implicit <code>whitespace</code> rule is equivalent to the explicit <code>whitespace</code> rule with the current whitespace rule;
i.e. it matches the current whitespace rule zero or more times.</p></div><div class=paragraph><p>The current whitespace rule is determined as follows:</p></div><div class=ulist><ul><li><p>If automatic whitespace skipping is disabled, there is no current whitespace rule.
<code>lexy::dsl::whitespace</code> does nothing.</p></li><li><p>If the current production inherits from <code>lexy::token_production</code>, there is no current whitespace rule.
<code>lexy::dsl::whitespace</code> does nothing.</p></li><li><p>Otherwise, if the current production defines a <code>static constexpr auto whitespace</code> member,
its value is the current whitespace rule.</p></li><li><p>Otherwise, if the root production defines a <code>static constexpr auto whitespace</code> member,
its value is the current whitespace rule.</p></li></ul></div><div class=paragraph><p>Here, the root production is defined as follows:</p></div><div class=ulist><ul><li><p>If the current production is a token production, the root production is the current production.</p></li><li><p>Otherwise, if the current production is the production that was originally parsed to the top-level parse function (e.g. <code>lexy::parse()</code>),
the root production is the current production.</p></li><li><p>Otherwise, the root production is taken from the production that parsed the <code>lexy::dsl::p</code> or <code>lexy::dsl::recurse</code> rule to start parsing the current production.</p></li></ul></div><div class=paragraph><p>This rule is automatically parsed after every token, after a production that inherits from <code>lexy::token_production</code>,
or after a <code>lexy::dsl::no_whitespace()</code> rule.</p></div><details><summary class=title>Example</summary><div class=content><div class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>struct token_p : lexy::token_production
{
    struct child
    {
        static constexpr auto rule = dsl::whitespace; // <b class=conum>(4)</b>
    };

    static constexpr auto rule = dsl::whitespace + dsl::p&lt;child&gt;; // <b class=conum>(3)</b>
};

struct normal_prod
{
    static constexpr auto rule = dsl::whitespace + dsl::p&lt;token_p&gt;; // <b class=conum>(2)</b>
};

struct root_prod
{
    static constexpr auto whitespace = dsl::ascii::space;
    static constexpr auto rule = dsl::whitespace + dsl::p&lt;normal_prod&gt;; // <b class=conum>(1)</b>
};

…

auto result = lexy::parse&lt;root_prod&gt;(…);</code></pre></div></div><div class="colist arabic"><ol><li><p>Here, the automatic whitespace rule is <code>dsl::ascii::space</code>,
as the current production has a <code>whitespace</code> member.</p></li><li><p>Here, the automatic whitespace rule is also <code>dsl::ascii::space</code>.
The current production doesn’t have a <code>whitespace</code> member,
but its root production (<code>root_prod</code>) does.</p></li><li><p>Here, the current production is a token production, so there is no automatic whitespace.
The root production is reset to <code>token_p</code>.</p></li><li><p>Here, the root production is <code>token_p</code>, as that is the root of the parent.
As such, there is no automatic whitespace.</p></li></ol></div></div></details><h4 id=_lexydslno_whitespace class=discrete><code>lexy::dsl::no_whitespace()</code></h4><div class=listingblock><div class=title><code>lexy/dsl/whitespace.hpp</code></div><div class=content><pre>no_whitespace(rule)   : Rule
no_whitespace(branch) : Branch</pre></div></div><div class=paragraph><p>The <code>no_whitespace</code> rule parses the given <code>rule</code> but disables automatic whitespace skipping while doing so.
It is a branch if given a branch.</p></div><div class=dlist><dl><dt class=hdlist1>Branch Condition</dt><dd><p>Whatever <code>branch</code> uses as branch condition.
Note that automatic whitespace skipping inside a branch condition is impossible anyway,
so nothing is changed there.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes <code>rule</code> but without performing automatic whitespace skipping after every token;
it disables the automatic whitespace rule during the parsing of <code>rule</code>.
After <code>rule</code> has been matched, skips implicit whitespace by matching and consuming <code>lexy::dsl::whitespace</code>.</p></dd><dt class=hdlist1>Values</dt><dd><p>All values produced by <code>rule</code>.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by <code>rule</code>.</p></dd></dl></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>When <code>rule</code> contains a <code>lexy::dsl::p</code> or <code>lexy::dsl::recurse</code> rule, whitespace skipping is re-enabled while that production is parsed.</td></tr></tbody></table></div></div><div class=sect2><h3 id=_primitive_tokens>Primitive Tokens</h3><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>All tokens, not just the tokens defined here, do implicit whitespace skipping.
As such, a token <code>t</code> is really equivalent to <code>t + dsl::whitespace</code>.
This has no effect, unless a whitespace rule has been specified.</td></tr></tbody></table></div><h4 id=_lexydslany class=discrete><code>lexy::dsl::any</code></h4><div class=listingblock><div class=title><code>lexy/dsl/any.hpp</code></div><div class=content><pre>any : Token</pre></div></div><div class=paragraph><p>The <code>any</code> token matches anything, i.e. all the remaining input.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>All the remaining input.</p></dd><dt class=hdlist1>Error</dt><dd><p>n/a (it never fails)</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content><code>any</code> is useful in combination with partial inputs such as the minus rule or <code>switch_</code>.</td></tr></tbody></table></div><h4 id=_lexydsllit class=discrete><code>lexy::dsl::lit</code></h4><div class=listingblock><div class=title><code>lexy/dsl/literal.hpp</code></div><div class=content><pre>lit_c&lt;C&gt; : Token
lit&lt;Str&gt; : Token

LEXY_LIT(Str) : Token</pre></div></div><div class=paragraph><p>The literal tokens match the specified sequence of characters.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><div class=ulist><ul><li><p><code>C</code> is a character literal.</p></li><li><p><code>Str</code> is a string literal.</p><div class=paragraph><p>In both cases, their encoding must be ASCII or match the encoding of the input.</p></div></li></ul></div></dd><dt class=hdlist1>Matches</dt><dd><p>The specified character or string of characters, which are consumed.</p></dd><dt class=hdlist1>Error</dt><dd><p><code>lexy::expected_literal</code> giving it the string and the index where the match failure occurred.</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content><code>lit&lt;Str></code> requires C++20 support for extended NTTPs.
Use the <code>LEXY_LIT(Str)</code> macro if your compiler does not support them.</td></tr></tbody></table></div><div class=listingblock><div class=title><code>lexy/dsl/punctuator.hpp</code></div><div class=content><pre>period    : Token = lit&lt;&#34;.&#34;&gt;
comma     : Token = lit&lt;&#34;,&#34;&gt;
colon     : Token = lit&lt;&#34;:&#34;&gt;
semicolon : Token = lit&lt;&#34;;&#34;&gt;

hyphen     : Token = lit&lt;&#34;-&#34;&gt;
slash      : Token = lit&lt;&#34;/&#34;&gt;
backslash  : Token = lit&lt;&#34;\\&#34;&gt;
apostrophe : Token = lit&lt;&#34;&#39;&#34;&gt;

hash_sign   : Token = lit&lt;&#34;#&#34;&gt;
dollar_sign : Token = lit&lt;&#34;$&#34;&gt;
at_sign     : Token = lit&lt;&#34;@&#34;&gt;</pre></div></div><div class=paragraph><p>The header <code>lexy/dsl/punctuator.hpp</code> defines common punctuator literals.
They are equivalent to a literal matching the specified character.</p></div></div><div class=sect2><h3 id=_character_classes>Character classes</h3><h4 id=_lexydsleof class=discrete><code>lexy::dsl::eof</code></h4><div class=listingblock><div class=title><code>lexy/dsl/eof.hpp</code></div><div class=content><pre>eof : Token</pre></div></div><div class=paragraph><p>The <code>eof</code> token matches EOF.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Only if the reader is at the end of the input. It does not consume anything (it can’t).</p></dd><dt class=hdlist1>Error</dt><dd><p><code>lexy::expected_char_class</code> with the name <code>EOF</code>.</p></dd></dl></div><h4 id=_lexydslnewline class=discrete><code>lexy::dsl::newline</code></h4><div class=listingblock><div class=title><code>lexy/dsl/newline.hpp</code></div><div class=content><pre>newline : Token</pre></div></div><div class=paragraph><p>The <code>newline</code> token matches a newline.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p><code>\n</code> or <code>\r\n</code>, which is consumed.</p></dd><dt class=hdlist1>Error</dt><dd><p><code>lexy::expected_char_class</code> with the name <code>newline</code>.</p></dd></dl></div><h4 id=_lexydsleol class=discrete><code>lexy::dsl::eol</code></h4><div class=listingblock><div class=title><code>lexy/dsl/newline.hpp</code></div><div class=content><pre>eol : Token</pre></div></div><div class=paragraph><p>The <code>eol</code> token matches an end-of-line (EOL).</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p><code>\n</code> or <code>\r\n</code>, which is consumed.
Also matches EOF, which is not consumed.</p></dd><dt class=hdlist1>Error</dt><dd><p><code>lexy::expected_char_class</code> with the name <code>EOL</code>.</p></dd></dl></div><h4 id=_lexydslascii class=discrete><code>lexy::dsl::ascii::*</code></h4><div class=listingblock><div class=title><code>lexy/dsl/ascii.hpp</code></div><div class=content><pre>namespace ascii
{
    control : Token // 0x00-0x1F, 0x7F

    blank       : Token // &#39; &#39; (space character) or &#39;\t&#39;
    newline     : Token // &#39;\n&#39; or &#39;\r&#39;
    other_space : Token // &#39;\f&#39; or &#39;\v&#39;
    space       : Token // `blank` or `newline` or `other_space`

    lower : Token // a-z
    upper : Token // A-Z
    alpha : Token // `lower` or `upper`

    digit : Token // 0-9
    alnum : Token // `digit` or `alpha`

    punct : Token // One of: !&#34;#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\]^_`{|}~

    graph : Token // `alnum` or `punct`
    print : Token // `graph` or &#39; &#39; (space characters)

    character : Token // 0x00-0x7F
}</pre></div></div><div class=paragraph><p>All tokens defined in <code>lexy::dsl::ascii</code> match one of the categories of ASCII characters.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes one of the set of ASCII characters indicated in the comments.</p></dd><dt class=hdlist1>Errors</dt><dd><p>A <code>lexy::expected_char_class</code> error with name <code>ASCII.&lt;token></code>, where <code>&lt;token></code> is the name of the token.</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>Every ASCII character except for the space character is in exactly one of <code>control</code>, <code>lower</code>, <code>upper</code>, <code>digit</code> or <code>punct</code>.</td></tr></tbody></table></div><h4 id=_lexydslcode_point class=discrete><code>lexy::dsl::code_point</code></h4><div class=listingblock><div class=title><code>lexy/dsl/code_point.hpp</code></div><div class=content><pre>code_point : Token

code_point.capture() : Rule</pre></div></div><div class=paragraph><p>The <code>code_point</code> token will match and consume a well-formed Unicode code point according to the encoding of the input.
If <code>code_point.capture()</code> is used, the consumed code point will be produced as value.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p>The encoding of the input is <code>lexy::ascii_encoding</code>, <code>lexy::utf8_encoding</code>, <code>lexy::utf16_encoding</code>, or <code>lexy::utf32_encoding</code>.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes all code units of the next code point.
For ASCII and UTF-32 this is only one, but for UTF-8 and UTF-16 it can be multiple code units.
If the code point is too big or a UTF-16 surrogate, it fails.
For UTF-8, it also fails for overlong sequences.</p></dd><dt class=hdlist1>Value</dt><dd><p>If <code>.capture()</code> was called, it will produce the matched code point as a <code>lexy::code_point</code>.</p></dd><dt class=hdlist1>Errors</dt><dd><p>If it could not match a valid code point, it fails with a <code>lexy::expected_char_class</code> error with name <code>&lt;encoding>.code_point</code>.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Match and capture one arbitrary code point.
dsl::code_point.capture()</code></pre></div></div></div></details><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>If you want to match a specific code point, use a literal rule instead.
This rule is useful for matching things like string literals that can contain arbitrary code points.</td></tr></tbody></table></div><h4 id=_lexydsloperator class=discrete><code>lexy::dsl::operator-</code></h4><div class=listingblock><div class=title><code>lexy/dsl/minus.hpp</code></div><div class=content><pre>token - except : Token</pre></div></div><div class=paragraph><p>The minus rule matches the given token, but only if <code>except</code> does not match on the input the rule has consumed.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p><code>except</code> is a token.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes whatever <code>token</code> match and consume.
Then matches <code>except</code> on the same input.
Matching fails if <code>except</code> matches the entire input consumed by the token.</p></dd><dt class=hdlist1>Errors</dt><dd><p>Whatever errors are raised if <code>token</code> is not matched.
A generic error with tag <code>lexy::minus_failure</code> if <code>except</code> has matched.</p></dd></dl></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use a minus rule to exclude characters from a character class; e.g. <code>lexy::dsl::code_point - lexy::dsl::ascii::control</code> matches all code points except control characters.</td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>Minus rules can be chained. This is equivalent to specifying an alternative for <code>except</code>.</td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><div class=title>Warning</div></td><td class=content><code>except</code> has to match <em>everything</em> the rule has consumed before; partial matches don’t count.
Use <code>token - (except + lexy::dsl::any)</code> if you want to allow a partial match.</td></tr></tbody></table></div><h4 id=_lexydsltoken class=discrete><code>lexy::dsl::token</code></h4><div class=listingblock><div class=title><code>lexy/dsl/token.hpp</code></div><div class=content><pre>token(rule) : Token</pre></div></div><div class=paragraph><p>The <code>token</code> rule turns an arbitrary rule into a token by parsing it and discarding all values it has produced.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Whatever <code>rule</code> matches, which will be consumed.</p></dd><dt class=hdlist1>Error</dt><dd><p>A generic error with tag <code>lexy::missing_token</code> if the <code>rule</code> did not match.</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>While <code>token()</code> is optimized to prevent any overhead created by constructing values that are later discarded,
it still should only be used when required.</td></tr></tbody></table></div></div><div class=sect2><h3 id=_values>Values</h3><div class=paragraph><p>The following rules are used to produce additional values without any additional matching.</p></div><h4 id=_lexydslvalue class=discrete><code>lexy::dsl::value_*</code></h4><div class=listingblock><div class=title><code>lexy/dsl/value.hpp</code></div><div class=content><pre>value_c&lt;Value&gt; : Rule
value_f&lt;Fn&gt;    : Rule
value_t&lt;T&gt;     : Rule
value_str&lt;Str&gt; : Rule

LEXY_VALUE_STR(Str) : Rule</pre></div></div><div class=paragraph><p>The <code>value_*</code> rules create a constant value without parsing anything.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><div class=ulist><ul><li><p><code>Value</code> is any constant.</p></li><li><p><code>Fn</code> is a pointer to a function taking no arguments.</p></li><li><p><code>T</code> is a default-constructible type.</p></li><li><p><code>Str</code> is a string literal.</p></li></ul></div></dd><dt class=hdlist1>Matches</dt><dd><p>Any input, but does not consume anything.</p></dd><dt class=hdlist1>Value</dt><dd><div class=dlist><dl><dt class=hdlist1><code>value_c</code></dt><dd><p>The specified constant.</p></dd><dt class=hdlist1><code>value_f</code></dt><dd><p>The result of invoking the function.</p></dd><dt class=hdlist1><code>value_t</code></dt><dd><p>A default constructed object of the specified type.</p></dd><dt class=hdlist1><code>value_str</code></dt><dd><p>The string literal as a pointer, followed by its size.</p></dd></dl></div></dd><dt class=hdlist1>Error</dt><dd><p>n/a (it does not fail)</p></dd></dl></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use the <code>value_*</code> rules only to create symmetry between different branches.
Everything they do, can also be achieved using callbacks, which is usually a better solution.</td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><div class=title>Warning</div></td><td class=content>The function might not be called or the object might not be constructed in all situations. You cannot rely on their side effects.</td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content><code>value_str&lt;Str></code> requires C++20 support for extended NTTPs.
Use the <code>LEXY_VALUE_STR(Str)</code> macro if your compiler does not support them.</td></tr></tbody></table></div><h4 id=_lexydslnullopt class=discrete><code>lexy::dsl::nullopt</code></h4><div class=listingblock><div class=title><code>lexy/dsl/option.hpp</code></div><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>namespace lexy
{
    struct nullopt
    {
        template &lt;typename T&gt;
        constexpr operator T() const;
    };
}</code></pre></div></div><div class=paragraph><p>The <code>lexy::nullopt</code> type represents an empty optional.
It is implicitly convertible to any type that has a default constructor (<code>T()</code>), a dereference operator (<code>*t</code>), and a contextual conversion to <code>bool</code> (<code>if (t)</code>).
Examples are pointers or <code>std::optional</code>.
The conversion operator returns a default constructible object, i.e. an empty optional.</p></div><div class=listingblock><div class=title><code>lexy/dsl/option.hpp</code></div><div class=content><pre>nullopt : Rule</pre></div></div><div class=paragraph><p>The <code>nullopt</code> rule produces a value of type <code>lexy::nullopt</code> without parsing anything.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Any input, but does not consume anything.</p></dd><dt class=hdlist1>Value</dt><dd><p>An object of type <code>lexy::nullopt</code>.</p></dd><dt class=hdlist1>Error</dt><dd><p>n/a (it does not fail)</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>It is meant to be used for symmetry with together with the <code>opt()</code> rule.</td></tr></tbody></table></div><h4 id=_lexydsllabel_and_lexydslid class=discrete><code>lexy::dsl::label</code> and <code>lexy::dsl::id</code></h4><div class=listingblock><div class=title><code>lexy/dsl/label.hpp</code></div><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>namespace lexy
{
    template &lt;typename Tag&gt;
    struct label
    {
        // only if Tag::value is well-formed
        consteval operator auto() const
        {
            return Tag::value;
        }
    };

    template &lt;auto Id&gt;
    using id = label&lt;std::integral_constant&lt;int, Id&gt;&gt;;
}</code></pre></div></div><div class=listingblock><div class=title><code>lexy/dsl/label.hpp</code></div><div class=content><pre>label&lt;Tag&gt; : Rule
id&lt;Id&gt;     : Rule</pre></div></div><div class=paragraph><p>The <code>label</code> and <code>id</code> rules are used to disambiguate between two branches that create otherwise the same values but should resolve to different callbacks.
They simply produce the empty tag object or the id to differentiate them without parsing anything.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><div class=ulist><ul><li><p><code>Tag</code> is any type.</p></li><li><p><code>Id</code> is an integer constant.</p></li></ul></div></dd><dt class=hdlist1>Matches</dt><dd><p>Any input, but does not consume anything.</p></dd><dt class=hdlist1>Value</dt><dd><div class=dlist><dl><dt class=hdlist1><code>label&lt;Tag></code></dt><dd><p>A <code>lexy::label&lt;Tag></code> object.</p></dd><dt class=hdlist1><code>id&lt;Id></code></dt><dd><p>A <code>lexy::id&lt;Id></code> object.</p></dd></dl></div></dd><dt class=hdlist1>Error</dt><dd><p>n/a (it does not fail)</p></dd></dl></div><div class=listingblock><div class=title><code>lexy/dsl/label.hpp</code></div><div class=content><pre>label&lt;Tag&gt;(rule)   : Rule   = label&lt;Tag&gt; + rule
label&lt;Tag&gt;(branch) : Branch = /* as above, except as branch */

id&lt;Id&gt;(rule)   : Rule   = id&lt;Id&gt; + rule
id&lt;Id&gt;(branch) : Branch = /* as above, except as branch */</pre></div></div><div class=paragraph><p>For convenience, <code>label</code> and <code>id</code> have function call operators.
They produce the label/id and then parse the rule.</p></div><h4 id=_lexydslcapture class=discrete><code>lexy::dsl::capture</code></h4><div class=listingblock><div class=title><code>lexy/dsl/capture.hpp</code></div><div class=content><pre>capture(rule)   : Rule
capture(branch) : Branch</pre></div></div><div class=paragraph><p>The <code>capture()</code> rule takes an arbitrary rule and parses it, capturing everything it has consumed into a <code>lexy::lexeme</code>.
It is a branch if given a branch.</p></div><div class=dlist><dl><dt class=hdlist1>Branch Condition</dt><dd><p>The branch condition is whatever <code>branch</code> uses as a branch condition.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes whatever <code>rule</code> matches.</p></dd><dt class=hdlist1>Values</dt><dd><p>A <code>lexy::lexeme</code> which begins at the original reader position and ends at the reader position after <code>rule</code> has been parsed,
followed by any other values produced by parsing the <code>rule</code> in the same order.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by <code>rule</code>. It cannot fail itself.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=77jfM5 class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Captures the entire input.
dsl::capture(dsl::any)</code></pre></div></div></div></details><h4 id=_lexydslposition class=discrete><code>lexy::dsl::position</code></h4><div class=listingblock><div class=title><code>lexy/dsl/position.hpp</code></div><div class=content><pre>position : Rule</pre></div></div><div class=paragraph><p>The <code>position</code> rule creates as its value an iterator to the current reader position without consuming any input.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Any input, but does not consume anything.</p></dd><dt class=hdlist1>Value</dt><dd><p>An iterator to the current position of the reader.</p></dd><dt class=hdlist1>Error</dt><dd><p>n/a (it does not fail)</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=Wh86vn class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Parses the entire input and returns the final position.
dsl::any + dsl::position</code></pre></div></div></div></details><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use <code>position</code> when creating an AST whose nodes are annotated with their original source position.</td></tr></tbody></table></div></div><div class=sect2><h3 id=_errors>Errors</h3><div class=paragraph><p>The following rules are used to customize/improve error messages.</p></div><h4 id=_errortag class=discrete><code>.error&lt;Tag>()</code></h4><div class=listingblock><div class=content><pre>token.error&lt;Tag&gt;() : Token</pre></div></div><div class=paragraph><p>The <code>error()</code> function on tokens changes the error that is raised when a token failed.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes what <code>token</code> matches.</p></dd><dt class=hdlist1>Error</dt><dd><p>A generic error with the specified <code>Tag</code>.</p></dd></dl></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>It is useful for tokens such as <code>dsl::token()</code> and <code>operator-</code>, where the result is a generic tag such as <code>lexy::missing_token</code> or <code>lexy::minus_failure</code>.</td></tr></tbody></table></div><h4 id=_lexydslerror class=discrete><code>lexy::dsl::error</code></h4><div class=listingblock><div class=title><code>lexy/dsl/error.hpp</code></div><div class=content><pre>error&lt;Tag&gt;       : Branch
error&lt;Tag&gt;(rule) : Branch</pre></div></div><div class=paragraph><p>The <code>error</code> rule always fails and produces an error with the given tag.
For the second version, the rule is matched first to determine the error range.</p></div><div class=dlist><dl><dt class=hdlist1>Branch Condition</dt><dd><p>Branch is always taken.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Nothing and always fails.</p></dd><dt class=hdlist1>Error</dt><dd><p>An error object of the specified <code>Tag</code>.
If the optional <code>rule</code> is given, it will be matched (without producing values or errors).
If it matched successfully, the previous and new reader position will be used to determine the error range.
Otherwise, the error has no range.</p></dd></dl></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use it as the final branch of a choice rule to customize the <code>lexy::exhausted_choice</code> error.</td></tr></tbody></table></div><h4 id=_lexydslrequire_and_lexydslprevent class=discrete><code>lexy::dsl::require</code> and <code>lexy::dsl::prevent</code></h4><div class=listingblock><div class=title><code>lexy/dsl/error.hpp</code></div><div class=content><pre>require&lt;Tag&gt;(rule) : Rule
prevent&lt;Tag&gt;(rule) : Rule</pre></div></div><div class=paragraph><p>The <code>require</code> and <code>prevent</code> rules can be used to lookahead and fail if the input matches or does not match the token.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Both match the <code>rule</code> without consuming input (or producing values or errors).
<code>require</code> fails if the <code>rule</code> did not match; <code>rule</code> fails if it did.</p></dd><dt class=hdlist1>Error</dt><dd><p>An error object of the specified <code>Tag</code>.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=n7zM4d class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Parses a sequence of digits but raises an error with tag `forbidden_leading_zero` if a zero is followed by more digits.
// Note: this is already available as `dsl::digits&lt;&gt;.no_leading_zero()`.
dsl::zero &gt;&gt; dsl::prevent&lt;forbidden_leading_zero&gt;(dsl::digits&lt;&gt;)
    | dsl::digits&lt;&gt;</code></pre></div></div></div></details><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use <code>prevent</code> together with <code>times</code> to prevent the rule from matching more than the specified number of times.</td></tr></tbody></table></div></div><div class=sect2><h3 id=_branch_conditions>Branch conditions</h3><div class=paragraph><p>The following rules are designed to be used as the condition of an <code>operator>></code>.
They have no effect if not used in a context that requires a branch.</p></div><h4 id=_lexydslelse class=discrete><code>lexy::dsl::else_</code></h4><div class=listingblock><div class=title><code>lexy/dsl/branch.hpp</code></div><div class=content><pre>else_ : Branch</pre></div></div><div class=paragraph><p>If <code>else_</code> is used as a condition, that branch will be taken unconditionally.
It must be used as a last alternative in a choice.</p></div><h4 id=_lexydslpeek class=discrete><code>lexy::dsl::peek</code></h4><div class=listingblock><div class=title><code>lexy/dsl/peek.hpp</code></div><div class=content><pre>peek(rule) : Branch</pre></div></div><div class=paragraph><p>The <code>peek</code> branch is taken if <code>rule</code> matches, but does not consume it.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>Automatic whitespace skipping is disabled while determining whether <code>rule</code> matches.</td></tr></tbody></table></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>Long lookahead can slow down parsing speed due to backtracking.</td></tr></tbody></table></div><h4 id=_lexydslpeek_not class=discrete><code>lexy::dsl::peek_not</code></h4><div class=listingblock><div class=title><code>lexy/dsl/peek.hpp</code></div><div class=content><pre>peek_not(rule) : Branch</pre></div></div><div class=paragraph><p>The <code>peek_not()</code> branch is taken if <code>rule</code> does not match, but does not consume it.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>Automatic whitespace skipping is disabled while determining whether <code>rule</code> matches.</td></tr></tbody></table></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>Long lookahead can slow down parsing speed due to backtracking.</td></tr></tbody></table></div><h4 id=_lexydsllookahead class=discrete><code>lexy::dsl::lookahead</code></h4><div class=listingblock><div class=title><code>lexy/dsl/lookahead.hpp</code></div><div class=content><pre>lookahead(needle, end) : Branch</pre></div></div><div class=paragraph><p>The <code>lookahead</code> branch is taken if lookahead finds <code>needle</code> before <code>end</code> is found, which must both be tokens.
No characters are consumed.</p></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>Long lookahead can slow down parsing speed due to backtracking.</td></tr></tbody></table></div></div><div class=sect2><h3 id=_branches>Branches</h3><h4 id=_lexydsloperator_2 class=discrete><code>lexy::dsl::operator+</code></h4><div class=listingblock><div class=title><code>lexy/dsl/sequence.hpp</code></div><div class=content><pre>rule + rule : Rule</pre></div></div><div class=paragraph><p>A sequence rule matches multiple rules one after the other.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Matches and consume the first rule, then matches and consumes the second rule, and so on.
Only succeeds if all of them succeed.</p></dd><dt class=hdlist1>Values</dt><dd><p>All the values produced by the rules in the same order as they were matched.</p></dd><dt class=hdlist1>Errors</dt><dd><p>Whatever errors are raised by the individual rules.</p></dd></dl></div><h4 id=_lexydsloperator_3 class=discrete><code>lexy::dsl::operator>></code></h4><div class=listingblock><div class=title><code>lexy/dsl/branch.hpp</code></div><div class=content><pre>branch &gt;&gt; rule : Branch</pre></div></div><div class=paragraph><p>The <code>operator>></code> is used to turn a rule into a branch by giving it a branch condition, which must be a branch itself.
If the branch is used as a normal rule, it first matches the condition followed by the rule.
If it is used in a context that requires a branch, the branch is checked to determine whether it should be taken.</p></div><div class=dlist><dl><dt class=hdlist1>Branch Condition</dt><dd><p>Whatever <code>branch</code> uses as branch condition.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Matches and consume the branch, then matches and consumes the <code>rule</code>.
Only succeeds if all of them succeed.</p></dd><dt class=hdlist1>Values</dt><dd><p>All the values produced by the branch and rule in the same order as they were matched.</p></dd><dt class=hdlist1>Errors</dt><dd><p>Whatever errors are raised by the individual branch and rule.</p></dd></dl></div><h4 id=_lexydslif class=discrete><code>lexy::dsl::if_</code></h4><div class=listingblock><div class=title><code>lexy/dsl/if.hpp</code></div><div class=content><pre>if_(branch) : Rule</pre></div></div><div class=paragraph><p>The <code>if_</code> rule matches a branch only if its condition matches.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>First matches the branch condition.
If that succeeds, consumes it and matches and consumes the rest of the branch.
Otherwise, consumes nothing and succeeds anyway.</p></dd><dt class=hdlist1>Values</dt><dd><p>Any values produced by the branch.</p></dd><dt class=hdlist1>Errors</dt><dd><p>Any errors produced by the branch.
It will only fail after the condition has been matched.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=GaxjbP class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Matches an optional C style comment.
dsl::if_(LEXY_LIT(&#34;/*&#34;) &gt;&gt; dsl::until(LEXY_LIT(&#34;*/&#34;)))</code></pre></div></div></div></details><h4 id=_lexydslopt class=discrete><code>lexy::dsl::opt</code></h4><div class=listingblock><div class=title><code>lexy/dsl/opt.hpp</code></div><div class=content><pre>opt(branch) : Rule = branch | else_ &gt;&gt; nullopt</pre></div></div><div class=paragraph><p>The <code>opt</code> rule matches a branch only if its condition matches.
Unlike <code>if_</code>, if the branch was not taken, it produces a <code>lexy::nullopt</code>.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>First matches the branch condition.
If that succeeds, consumes it and matches and consumes the rest of the branch.
Otherwise, consumes nothing and succeeds anyway.</p></dd><dt class=hdlist1>Values</dt><dd><p>If the branch condition matches, any values produced by the rule.
Otherwise, a single object of type <code>lexy::nullopt</code>.</p></dd><dt class=hdlist1>Errors</dt><dd><p>Any errors produced by the branch.
It will only fail after the condition has been matched.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=1vK39o class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Matches an optional list of alpha characters.
// (The id&lt;0&gt; is just there, so the sink will be invoked on each character).
// If no items are present, it will default construct the list type.
dsl::opt(dsl::list(dsl::ascii::alpha &gt;&gt; dsl::id&lt;0&gt;))</code></pre></div></div></div></details><h4 id=_lexydsloperator_4 class=discrete><code>lexy::dsl::operator|</code></h4><div class=listingblock><div class=title><code>lexy/dsl/choice.hpp</code></div><div class=content><pre>branch  | branch  : Rule</pre></div></div><div class=paragraph><p>A choice rule matches the first branch in order whose condition was matched.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Tries to match the condition of each branch in the order they were specified.
As soon as one branch condition matches, matches and consumes that branch without ever backtracking to try another branch.
If no branch condition matched, fails without consuming anything.</p></dd><dt class=hdlist1>Values</dt><dd><p>Any values produced by the selected branch.</p></dd><dt class=hdlist1>Errors</dt><dd><p>Any errors raised by the then of the selected branch.
If no branch condition matched, a generic error with tag <code>lexy::exhausted_choice</code>.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=aaEnW7 class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// A contrived example to illustrate the behavior of choice.
// Note that branch with id 1 will never be taken, as branch 0 takes everything starting with a and then fails if it isn&#39;t followed by bc.
// The correct behavior is illustrated with 2 and 3, there the branch with the longer condition is listed first.
dsl::id&lt;0&gt;(LEXY_LIT(&#34;a&#34;) &gt;&gt; LEXY_LIT(&#34;bc&#34;))
  | dsl::id&lt;1&gt;(LEXY_LIT(&#34;a&#34;) &gt;&gt; LEXY_LIT(&#34;b&#34;))
  | dsl::id&lt;2&gt;(LEXY_LIT(&#34;bc&#34;))
  | dsl::id&lt;3&gt;(LEXY_LIT(&#34;b&#34;))</code></pre></div></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The C++ operator precedence is specified in such a way that <code>condition >> a | else_ >> b</code> works.
The compiler might warn that the precedence is not intuitive without parentheses, but in the context of this DSL it is the expected result.</td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use <code>… | error&lt;Tag></code> to raise a custom error instead of <code>lexy::exhausted_choice</code>.</td></tr></tbody></table></div><h4 id=_lexydsloperator_5 class=discrete><code>lexy::dsl::operator/</code></h4><div class=listingblock><div class=title><code>lexy/dsl/alternative.hpp</code></div><div class=content><pre>token / token : Token</pre></div></div><div class=paragraph><p>An alternative rule tries to match each token in order, backtracking if necessary.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Tries to match each token in the order they were specified.
As soon as one token matches, consumes it and succeeds.
If no token matched, fails without consuming anything.</p></dd><dt class=hdlist1>Errors</dt><dd><p>A generic error with tag <code>lexy::exhausted_alternatives</code> if no token matched.</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>If an alternative consists of only literals, a trie is used to efficiently match them without backtracking.</td></tr></tbody></table></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>Use a choice rule with a suitable condition to avoid potentially long backtracking.</td></tr></tbody></table></div><h4 id=_lexydslswitch class=discrete><code>lexy::dsl::switch_</code></h4><div class=listingblock><div class=title><code>lexy/dsl/switch.hpp</code></div><div class=content><pre>switch_(rule) : Rule

switch_(rule).case_(branch)  : Rule
switch_(rule).default_(rule) : Rule = switch_(rule).case_(else_ &gt;&gt; rule)
switch_(rule).error&lt;Tag&gt;()   : Rule = switch_(rule).case_(error&lt;Tag&gt;(any))</pre></div></div><div class=paragraph><p>The <code>switch_</code> rule matches a rule and then switches over the input the rule has consumed.
Switch cases can be added by calling <code>.case_()</code>; they are tried in order.
A default case is added using <code>.default_()</code>; it is taken unconditionally.
Alternatively, an error case can be added using <code>.error&lt;Tag>()</code>; it produces an error if no previous case has matched.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>First matches and consumes the switched rule.
What the rule has consumed is then taken as the entire input for matching the switch cases.
Then it tries to match the branch conditions of each case in order.
When a branch condition matches, that case is taken and its then is matched.
If no case has matched, it fails.</p></dd><dt class=hdlist1>Values</dt><dd><p>Any values produced by the switched rule followed by any values produced by the selected case.</p></dd><dt class=hdlist1>Errors</dt><dd><p>If the switched rule fails to match, any errors raised by it.
If the branch condition of a case has matched, any errors raised by the then.
If the switch had an error case, a generic error with the specified <code>Tag</code> is raised whose range is everything consumed by the switched rule.
Otherwise, a generic error with tag <code>lexy::exhausted_switch</code> is raised.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=G87Mqf class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Parse identifiers (one or more alpha numeric characters) but detect the three reserved keywords.
// We use `+ dsl::eof` in the case condition to ensure that `boolean` is not matched as `bool`.
dsl::switch_(dsl::while_one(dsl::ascii::alnum))
    .case_(LEXY_LIT(&#34;true&#34;)  + dsl::eof &gt;&gt; dsl::id&lt;1&gt;)
    .case_(LEXY_LIT(&#34;false&#34;) + dsl::eof &gt;&gt; dsl::id&lt;2&gt;)
    .case_(LEXY_LIT(&#34;bool&#34;)  + dsl::eof &gt;&gt; dsl::id&lt;3&gt;)
    .default_(dsl::id&lt;0&gt;) // It wasn&#39;t a reserved keyword but a normal identifier.

// Note: a more efficient and convenient method for handling keywords is planned.</code></pre></div></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>It does not matter if the then of a case does not consume everything the original rule has consumed.
As soon as the then has matched everything parsing continues from the reader position after the switched rule has been matched.</td></tr></tbody></table></div></div><div class=sect2><h3 id=_loops>Loops</h3><h4 id=_lexydsluntil class=discrete><code>lexy::dsl::until</code></h4><div class=listingblock><div class=title><code>lexy/dsl/until.hpp</code></div><div class=content><pre>until(token)          : Token
until(token).or_eof() : Token = until(token / eof)</pre></div></div><div class=paragraph><p>The <code>until</code> token consumes all input until the specified <code>token</code> matches, then consumes that.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>If the closing <code>token</code> matches, consumes it and succeeds.
Otherwise, consumes one code unit and tries again.
If EOF is reached, fails, unless <code>.or_eof()</code> was called, in which case it also succeeds having consumed everything until the end of the input.</p></dd><dt class=hdlist1>Errors</dt><dd><p>It can only fail if the reader has reached the end of the input without matching the condition.
Then it raises the same error as raised if the condition would be matched at EOF.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=Yn4WTj class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Matches a C style comment.
// Note that we don&#39;t care what it contains.
LEXY_LIT(&#34;/*&#34;) &gt;&gt; dsl::until(LEXY_LIT(&#34;*/&#34;))</code></pre></div></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content><code>until</code> includes the <code>token</code>.</td></tr></tbody></table></div><h4 id=_lexydslloop class=discrete><code>lexy::dsl::loop</code></h4><div class=listingblock><div class=title><code>lexy/dsl/loop.hpp</code></div><div class=content><pre>loop(rule) : Rule

break_ : Rule</pre></div></div><div class=paragraph><p>The <code>loop</code> rule matches the given rule repeatedly until it either fails to match or a <code>break_</code> rule was matched.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p><code>rule</code> must not produce any values.
<code>break_</code> must be used inside a loop.</p></dd><dt class=hdlist1>Matches</dt><dd><p>While the rule matches, consumes it and repeats.
If a <code>break_</code> is matched, parsing will stop immediately and it succeeds.
If the rule does not match, it fails.</p></dd><dt class=hdlist1>Values</dt><dd><p>No values are produced.</p></dd><dt class=hdlist1>Errors</dt><dd><p>Any errors raised when the rule fails to match.</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The <code>loop</code> rule is mainly used to implement other rules.
It is unlikely that you are going to need it yourself.</td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><div class=title>Warning</div></td><td class=content>If <code>rule</code> contains a branch that will not consume any characters but does not break, <code>loop</code> will loop forever.</td></tr></tbody></table></div><h4 id=_lexydslwhile class=discrete><code>lexy::dsl::while_</code></h4><div class=listingblock><div class=title><code>lexy/dsl/while.hpp</code></div><div class=content><pre>while_(branch) : Rule</pre></div></div><div class=paragraph><p>The <code>while</code> rule matches a branch as long as it condition has matched.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p><code>branch</code> must not produce any values.</p></dd><dt class=hdlist1>Matches</dt><dd><p>While the branch condition matches, matches and consumes the then then repeats.
If the branch condition does not match anymore, succeeds without consuming additional input.</p></dd><dt class=hdlist1>Values</dt><dd><p>No values are produced.</p></dd><dt class=hdlist1>Errors</dt><dd><p>The rule can only fail if the then of the branch fails.
Then it will raise its error unchanged.</p></dd></dl></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><div class=title>Warning</div></td><td class=content>If the branch does not consume any characters, <code>while_</code> will loop forever.</td></tr></tbody></table></div><h4 id=_lexydslwhile_one class=discrete><code>lexy::dsl::while_one()</code></h4><div class=listingblock><div class=title><code>lexy/dsl/while.hpp</code></div><div class=content><pre>while_one(branch)  : Branch  = branch &gt;&gt; while_(branch)</pre></div></div><div class=paragraph><p>The <code>while_one</code> rule matches a rule one or more times.</p></div><h4 id=_lexydsldo_while class=discrete><code>lexy::dsl::do_while()</code></h4><div class=listingblock><div class=title><code>lexy/dsl/while.hpp</code></div><div class=content><pre>do_while(rule, condition_branch)   : Rule   = rule + while_(condition_branch &gt;&gt; rule)
do_while(branch, condition_branch) : Branch = branch &gt;&gt; while_(condition_branch &gt;&gt; rule)</pre></div></div><div class=paragraph><p>The <code>do_while</code> rule matches a rule first unconditionally, and then again repeatedly while the rule matches.</p></div><details><summary class=title>Example</summary><div class=content><div id=4dzEK7 class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Equivalent to `dsl::list(dsl::ascii::alpha, dsl::sep(dsl::comma))` but does not produce a value.
dsl::do_while(dsl::ascii::alpha, dsl::comma)</code></pre></div></div></div></details><h4 id=_lexydslsep_and_lexydsltrailing_sep class=discrete><code>lexy::dsl::sep</code> and <code>lexy::dsl::trailing_sep</code></h4><div class=listingblock><div class=title><code>lexy/dsl/separator.hpp</code></div><div class=content><pre>sep(branch)
trailing_sep(branch)</pre></div></div><div class=paragraph><p><code>sep</code> and <code>trailing_sep</code> are used to specify a separator between repeated items; they are not rules that can be parsed directly.</p></div><div class=paragraph><p>Use <code>sep(branch)</code> to indicate that <code>branch</code> has to be consumed between two items.
If it would match after the last item, it is not consumed by the rule.</p></div><div class=paragraph><p>Use <code>trailing_sep(branch)</code> to indicate that <code>branch</code> has to be consumed between two items and can occur after the final item.
If it matches after the last item, it is consumed as well.</p></div><h4 id=_lexydsltimes class=discrete><code>lexy::dsl::times</code></h4><div class=listingblock><div class=title><code>lexy/dsl/times.hpp</code></div><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>namespace lexy
{
    template &lt;std::size_t N, typename T&gt;
    using times = T (&amp;)[N];

    template &lt;typename T&gt;
    using twice = times&lt;2, T&gt;;
}</code></pre></div></div><div class=listingblock><div class=title><code>lexy/dsl/times.hpp</code></div><div class=content><pre>times&lt;N&gt;(rule)      : Rule
times&lt;N&gt;(rule, sep) : Rule

twice(rule)      : Rule = times&lt;2&gt;(rule)
twice(rule, sep) : Rule = times&lt;2&gt;(rule, sep)</pre></div></div><div class=paragraph><p>The <code>times</code> rule repeats the rule <code>N</code> times with optional separator in between and collects all produced values into an array.
The <code>twice</code> rule is a convenience alias for <code>N = 2</code>.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p>The separator must not produce any values.
All values produced by the parsing the rule must have a common type.
In particular, the rule must only produce one value.</p></dd><dt class=hdlist1>Matches</dt><dd><p>If no separator is specified, matches and consumes <code>rule</code> <code>N</code> times.
If a separator is specified, matches and consumes <code>rule</code> <code>N</code> times, consuming the separator between two items and potentially after all items if the separator is trailing.</p></dd><dt class=hdlist1>Values</dt><dd><p>Produces a single array containing <code>N</code> items which are all the values produced by each repetition.
The typedef <code>lexy::times</code> or <code>lexy::twice</code> can be used to process that array.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by matching the rule or separator.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=hrTKaT class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Parses an IPv4 address (4 uint8_t&#39;s seperated by periods).
dsl::times&lt;4&gt;(dsl::integer&lt;std::uint8_t&gt;(dsl::digits&lt;&gt;), dsl::sep(dsl::period))</code></pre></div></div></div></details><h4 id=_lexydsllist class=discrete><code>lexy::dsl::list</code></h4><div class=listingblock><div class=title><code>lexy/dsl/list.hpp</code></div><div class=content><pre>list(rule)   : Rule
list(branch) : Branch

list(rule, sep)   : Rule
list(branch, sep) : Branch</pre></div></div><div class=paragraph><p>The <code>list</code> rule matches a rule one or more times, optionally separated by a separator.
Values produced by the list items are forwarded to a sink callback.</p></div><div class=dlist><dl><dt class=hdlist1>Branch Condition</dt><dd><p>Whatever <code>branch</code> uses as branch condition.</p></dd><dt class=hdlist1>Requires</dt><dd><p>The item rule must be a branch unless a non-trailing separator is used (in that case the separator can be used as condition).
A production whose rule contains <code>list()</code> must provide a sink.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes the item rule one or more times.
In between items and potentially after the final item, a separator is matched and consumed if provided according to its rules.
If the separator is provided and non-trailing, the existence of a separator determines whether or not the rule should be matched again.
Otherwise, the branch condition of the branch rule or an added else branch of the choice rule is used to determine that.</p></dd><dt class=hdlist1>Values</dt><dd><p>Only a single value, which is the result of the finished sink.
Every time the item rule is parsed, all values it produces are passed to the sink which is invoked once per iteration.
If the separator is captured, its lexeme is also passed to the sink, but in a separate invocation.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised when parsing the item rule or separator.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=sE873v class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Parses a list of integers seperated by (a potentially trailing) comma.
// As the separator is trailing, it cannot be used to determine the end of the list.
// As such we peek whether the input contains a digit in our item condition.
// The sink is invoked with each integer.
dsl::list(dsl::peek(dsl::digit&lt;&gt;) &gt;&gt; dsl::integer&lt;int&gt;(dsl::digits&lt;&gt;),
          dsl::trailing_sep(dsl::comma))</code></pre></div></div></div></details><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use one of the bracketing rules if your list item does not have an easy condition and the list is surrounded by given tokens anyway.</td></tr></tbody></table></div><h4 id=_lexydslopt_list class=discrete><code>lexy::dsl::opt_list</code></h4><div class=listingblock><div class=title><code>lexy/dsl/list.hpp</code></div><div class=content><pre>opt_list(branch)      : Rule
opt_list(branch, sep) : Rule</pre></div></div><div class=paragraph><p>The <code>opt_list</code> rule matches a rule zero or more times, optionally separated by a separator.
Values produced by the list items are forwarded to a sink callback.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p>The item rule must be a branch.
A production whose rule contains <code>opt_list()</code> must provide a sink.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Checks whether the item rule would match using its branch condition.
If it does, matches and consumes <code>list(branch, sep)</code>.
Otherwise, consumes nothing and succeeds.</p></dd><dt class=hdlist1>Values</dt><dd><p>If the list is non-empty, the result of the sink produced by parsing the <code>list()</code> rule.
Otherwise, the result of a sink that is immediately finished without invoking it once.</p></dd><dt class=hdlist1>Errors</dt><dd><p>If the list is non-empty, all errors raised by parsing the <code>list()</code> rule.</p></dd></dl></div><h4 id=_lexydslcombination class=discrete><code>lexy::dsl::combination</code></h4><div class=listingblock><div class=title><code>lexy/dsl/combination.hpp</code></div><div class=content><pre>combination(branch1, branch2, ...) : Rule
combination&lt;Tag&gt;(branch1, branch2, ...) : Rule</pre></div></div><div class=paragraph><p>The <code>combination</code> rule matches each of the sub-rules exactly once but in any order.
Values produced by the rules are forwarded to a sink.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p>A production whose rule contains <code>combination()</code> must provide a sink.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes all rules in an arbitrary order.
This is done by parsing the choice created from the branches exactly <code>N</code> times.
Branches that have already been taken are not excluded on future iterations.
If they are taken again, the rule fails.</p></dd><dt class=hdlist1>Values</dt><dd><p>Only a single value, which is the result of the finished sink.
All values produced by the branches are passed to the sink which is invoked once per iteration.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by parsing the branches.
If no branch is matched, but there are still missing branches,
a generic error with tag <code>lexy::exhausted_choice</code> is raised.
If a branch is matched twice, a generic error is raised.
It has the specified tag or <code>lexy::combination_duplicate</code> if none was specified.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=bjKqvj class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Matches &#39;a&#39;, &#39;b&#39;, or &#39;c&#39;, in any order.
dsl::combination(dsl::lit_c&lt;&#39;a&#39;&gt;, dsl::lit_c&lt;&#39;b&#39;&gt;, dsl::lit_c&lt;&#39;c&#39;&gt;)</code></pre></div></div></div></details><div class="admonitionblock warning"><table><tbody><tr><td class=icon><div class=title>Warning</div></td><td class=content>The branches are tried in order. If an earlier branch always takes precedence over a later one, the combination can never be successful.</td></tr></tbody></table></div><h4 id=_lexydslpartial_combination class=discrete><code>lexy::dsl::partial_combination</code></h4><div class=listingblock><div class=title><code>lexy/dsl/combination.hpp</code></div><div class=content><pre>partial_combination(branch1, branch2, ...) : Rule
partial_combination&lt;Tag&gt;(branch1, branch2, ...) : Rule</pre></div></div><div class=paragraph><p>The <code>partial_combination</code> rule matches each of the sub-rules at most once but in any order.
Values produced by the rules are forwarded to a sink.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p>A production whose rule contains <code>partial_combination()</code> must provide a sink.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes a subset of the rules in an arbitrary order.
This is done by parsing the choice created from the branches exactly <code>N</code> times.
Branches that have already been taken are not excluded on future iterations.
If they are taken again, the rule fails.
If no branch is taken, the rule succeeds.</p></dd><dt class=hdlist1>Values</dt><dd><p>Only a single value, which is the result of the finished sink.
All values produced by the branches are passed to the sink which is invoked once per iteration.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by parsing the branches.
If a rule is matched twice, a generic error is raised.
It has the specified tag or <code>lexy::combination_duplicate</code> if none was specified.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=85dv9W class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Matches a subset of &#39;a&#39;, &#39;b&#39;, or &#39;c&#39;, in any order.
dsl::partial_combination(dsl::lit_c&lt;&#39;a&#39;&gt;, dsl::lit_c&lt;&#39;b&#39;&gt;, dsl::lit_c&lt;&#39;c&#39;&gt;)</code></pre></div></div></div></details><div class="admonitionblock warning"><table><tbody><tr><td class=icon><div class=title>Warning</div></td><td class=content>The branches are tried in order. If an earlier branch always takes precedence over a later one, the combination can never be successful.</td></tr></tbody></table></div></div><div class=sect2><h3 id=_productions>Productions</h3><div class=paragraph><p>Every rule is owned by a production.
The following rules allow interaction with other productions.</p></div><h4 id=_lexydslp_and_lexydslrecurse class=discrete><code>lexy::dsl::p</code> and <code>lexy::dsl::recurse</code></h4><div class=listingblock><div class=title><code>lexy/dsl/production.hpp</code></div><div class=content><pre>p&lt;Production&gt; : Rule or Branch
recurse&lt;Production&gt; : Rule</pre></div></div><div class=paragraph><p>The <code>p</code> and <code>recurse</code> rules parses the rule of another production.
The <code>p</code> rule is a branch, if the rule of the other production is a branch.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p>For <code>p</code>, the <code>Production</code> is a complete type at the point of the rule definition.
The <code>recurse</code> rule has no such limitations.</p></dd><dt class=hdlist1>Branch Condition</dt><dd><p>Whatever the production’s rule uses as a branch condition.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes <code>Production::rule</code>.
If <code>Production</code> inherits from <code>lexy::token_production</code>,
automatic whitespace is skipped afterwards by matching and consuming the <code>lexy::dsl::whitespace</code> rule.</p></dd><dt class=hdlist1>Values</dt><dd><p>A single value, which is the result of parsing the production.
All values produced by parsing its rule are forwarded to the productions value callback.</p></dd><dt class=hdlist1>Errors</dt><dd><p>If matching fails, <code>Production::rule</code> will raise an error which is handled in the context of <code>Production</code>.
This results in a failed result object, which is converted to our result type and returned.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=oj9T3n class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Parse a sub production followed by an exclamation mark.
dsl::p&lt;sub_production&gt; + dsl::lit_c&lt;&#39;!&#39;&gt;</code></pre></div></div></div></details><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>While <code>recurse</code> can be used to implement direct recursion (e.g. <code>prefix >> dsl::p&lt;current_production> | dsl::else_ >> end</code> to match zero or more <code>prefix</code> followed by <code>end</code>), it is better to use loops instead.</td></tr></tbody></table></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><div class=title>Warning</div></td><td class=content>Left recursion will create an infinite loop.</td></tr></tbody></table></div><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>If a production is parsed while whitespace skipping has been disabled using <code>lexy::dsl::no_whitespace()</code>,
it is temporarily re-enabled while <code>Production::rule</code> is parsed.
If whitespace skipping has been disabled because the parent production inherits from <code>lexy::token_production</code>,
whitespace skipping is still disabled while parsing <code>Production::rule</code>.</td></tr></tbody></table></div><h4 id=_lexydslreturn class=discrete><code>lexy::dsl::return_</code></h4><div class=listingblock><div class=title><code>lexy/dsl/return.hpp</code></div><div class=content><pre>return_ : Rule</pre></div></div><div class=paragraph><p>Conceptually, each production has an associated function that parses the specified rule.
The <code>return_</code> rule will exit that function early, without parsing subsequent rules.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p>It must not be used inside loops.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Any input, but does not consume anything.
Subsequent rules are not matched further.</p></dd><dt class=hdlist1>Values</dt><dd><p>It does not produce any values, but all values produced so far are forwarded to the callback.</p></dd><dt class=hdlist1>Errors</dt><dd><p>n/a (it does not fail)</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=zrbcaq class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Match an opening parenthesis followed by &#39;a&#39; or &#39;b&#39;.
// If it is followed by &#39;b&#39;, the closing parenthesis is not matched anymore.
dsl::parenthesized(dsl::lit_c&lt;&#39;a&#39;&gt; | dsl::lit_c&lt;&#39;b&#39;&gt; &gt;&gt; dsl::return_)</code></pre></div></div></div></details><div class="admonitionblock caution"><table><tbody><tr><td class=icon><div class=title>Caution</div></td><td class=content>When using <code>return_</code> together with the context sensitive parsing facilities, remember to pop all context objects before the return.</td></tr></tbody></table></div></div><div class=sect2><h3 id=_brackets_and_terminator>Brackets and terminator</h3><h4 id=_terminator class=discrete>Terminator</h4><div class=listingblock><div class=title><code>lexy/dsl/terminator.hpp</code></div><div class=content><pre>terminator(branch)
terminator(branch).terminator() : Branch = branch</pre></div></div><div class=paragraph><p>A terminator can be specified using <code>terminator()</code>.
The result is not a rule, but a DSL for specifying that a rule is followed by the terminator.
The terminator is defined using a branch; it is returned by calling <code>.terminator()</code>.</p></div><div class=listingblock><div class=title><code>lexy/dsl/terminator.hpp</code></div><div class=content><pre>t(rule) : Rule = rule + t.terminator()</pre></div></div><div class=paragraph><p>Calling <code>t(rule)</code>, where <code>t</code> is the result of a <code>terminator()</code> call, results in a rule that parses the given <code>rule</code> followed by the terminator.</p></div><div class=listingblock><div class=title><code>lexy/dsl/terminator.hpp</code></div><div class=content><pre>t.while_(rule) : Rule
t.while_one(rule) : Rule

t.opt(rule) : Rule

t.list(rule) : Rule
t.list(rule, sep) : Rule

t.opt_list(rule) : Rule
t.opt_list(rule, sep) : Rule</pre></div></div><div class=paragraph><p>Using <code>t.while_()</code>, <code>t.while_one()</code> <code>t.opt()</code>, <code>t.list()</code>, or <code>t.opt_list()</code>, where <code>t</code> is the result of a <code>terminator()</code> call,
results in a rule that parses <code>while_(rule)</code>, <code>while_one(rule)</code>, <code>opt(rule)</code>, <code>list(rule)</code> and <code>opt_list(rule)</code>, respectively, but followed by the terminator.
The <code>rule</code> does not need to be a branch, as the terminator is used as the branch condition for the <code>while_()</code>, <code>opt()</code> and <code>list()</code> rule.</p></div><h4 id=_brackets class=discrete>Brackets</h4><div class=listingblock><div class=title><code>lexy/dsl/brackets.hpp</code></div><div class=content><pre>brackets(open_branch, close_branch)
brackets(open_branch, close_branch).open()  : Branch = open_branch
brackets(open_branch, close_branch).close() : Branch = close_branch</pre></div></div><div class=paragraph><p>A set of open and close brackets can be specified using <code>brackets()</code>.
The result is not a rule, but a DSL for specifying that a rule is surrounded by brackets.
The open and close brackets are defined using branches; they are returned by calling <code>.open()</code> and <code>.close()</code>.</p></div><div class=listingblock><div class=title><code>lexy/dsl/brackets.hpp</code></div><div class=content><pre>b(rule) : Branch = b.open() &gt;&gt; rule + b.close()</pre></div></div><div class=paragraph><p>Calling <code>b(rule)</code>, where <code>b</code> is the result of a <code>brackets()</code> call, results in a rule that parses the given <code>rule</code> surrounded by brackets.
The rule is a branch that uses the opening bracket as a branch condition.</p></div><div class=listingblock><div class=title><code>lexy/dsl/brackets.hpp</code></div><div class=content><pre>b.while_(rule) : Branch
b.while_one(rule) : Branch

b.opt(rule) : Branch

b.list(rule) : Branch
b.list(rule, sep) : Branch

b.opt_list(rule) : Branch
b.opt_list(rule, sep) : Branch</pre></div></div><div class=paragraph><p>Using <code>b.while_()</code>, <code>b.while_one()</code> <code>b.opt()</code>, <code>b.list()</code>, or <code>b.opt_list()</code>, where <code>b</code> is the result of a <code>brackets()</code> call, results in a branch that parses <code>while_(rule)</code>, <code>while_one(rule)</code>, <code>opt(rule)</code>, <code>list(rule)</code> and <code>opt_list(rule)</code>, respectively, but surrounded as brackets.
The <code>rule</code> does not need to be a branch, as the closing brackets is used as the branch condition for the <code>while_()</code>, <code>opt()</code> and <code>list()</code> rule.</p></div><div class=listingblock><div class=title><code>lexy/dsl/brackets.hpp</code></div><div class=content><pre>round_bracketed  = brackets(lit_c&lt;&#39;(&#39;&gt;, lit_c&lt;&#39;)&#39;&gt;)
square_bracketed = brackets(lit_c&lt;&#39;[&#39;&gt;, lit_c&lt;&#39;]&#39;&gt;)
curly_bracketed  = brackets(lit_c&lt;&#39;{&#39;&gt;, lit_c&lt;&#39;}&#39;&gt;)
angle_bracketed  = brackets(lit_c&lt;&#39;&lt;&#39;&gt;, lit_c&lt;&#39;&gt;&#39;&gt;)

parenthesized = round_bracketed</pre></div></div><div class=paragraph><p>Common sets of open and close brackets are pre-defined.</p></div><details><summary class=title>Example</summary><div class=content><div id=G9MPKh class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Parses a list of integers seperated by (a potentially trailing) comma surrounded by parentheses.
// The same example without the parentheses was also used for list,
// but we required a list condition that needed to perform lookahead.
// Now, the closing parentheses is used as the condition and we don&#39;t need to lookahead.
dsl::parenthesized.list(dsl::integer&lt;int&gt;(dsl::digits&lt;&gt;),
                        dsl::trailing_sep(dsl::comma))</code></pre></div></div></div></details></div><div class=sect2><h3 id=_numbers>Numbers</h3><div class=paragraph><p>The facilities for parsing integers are split into the digit token, which do not produce any values,
and the <code>integer</code> rule, which matches a digit token and converts it into an integer.
The integer conversion has to be done during and parsing and not as a callback, as overflow creates a parse error.</p></div><h4 id=_base class=discrete>Base</h4><div class=listingblock><div class=title><code>lexy/dsl/digit.hpp</code></div><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>namespace lexy::dsl
{
    struct binary;
    struct octal;
    struct decimal;
    struct hex_lower;
    struct hex_upper;
    struct hex;
}</code></pre></div></div><div class=paragraph><p>The set of allowed digits and their values is specified using a <code>Base</code>, which is a policy class passed to the rules.</p></div><div class=dlist><dl><dt class=hdlist1><code>binary</code></dt><dd><p>Matches the base 2 digits <code>0</code> and <code>1</code>.</p></dd><dt class=hdlist1><code>octal</code></dt><dd><p>Matches the base 8 digits <code>0-7</code>.</p></dd><dt class=hdlist1><code>decimal</code></dt><dd><p>Matches the base 10 digits <code>0-9</code>. If no base is specified, this is the default.</p></dd><dt class=hdlist1><code>hex_lower</code></dt><dd><p>Matches the lower-case base 16 digits <code>0-9</code> and <code>a-f</code>.</p></dd><dt class=hdlist1><code>hex_upper</code></dt><dd><p>Matches the upper-case base 16 digits <code>0-9</code> and <code>A-F</code>.</p></dd><dt class=hdlist1><code>hex</code></dt><dd><p>Matches the base 16 digits <code>0-9</code>, <code>A-F</code>, and <code>a-f</code>.</p></dd></dl></div><h4 id=_lexyinteger_traits class=discrete><code>lexy::integer_traits</code></h4><div class=listingblock><div class=title><code>lexy/dsl/integer.hpp</code></div><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>namespace lexy
{
    template &lt;typename T&gt;
    struct integer_traits
    {
        using type = T;

        static constexpr bool is_bounded;

        template &lt;int Radix&gt;
        static constexpr std::size_t max_digit_count;

        template &lt;int Radix&gt;
        static constexpr void add_digit_unchecked(type&amp; result, unsigned digit);
        template &lt;int Radix&gt;
        static constexpr bool add_digit_checked(type&amp; result, unsigned digit)
    };

    template &lt;&gt;
    struct integer_traits&lt;lexy::code_point&gt;;

    template &lt;typename T&gt;
    struct unbounded
    {};
    template &lt;typename T&gt;
    struct integer_traits&lt;unbounded&lt;T&gt;&gt;
    {
        using type                       = typename integer_traits&lt;T&gt;::type;
        static constexpr bool is_bounded = false;

        template &lt;int Radix&gt;
        static constexpr void add_digit_unchecked(type&amp; result, unsigned digit);
    };
}</code></pre></div></div><div class=paragraph><p>The <code>lexy::integer_traits</code> are used for parsing an integer.
It controls its maximal value and abstracts away the required integer operations.</p></div><div class=paragraph><p>The <code>type</code> member is the actual type that will be returned by the parse operation. It is usually <code>T</code>.
The parsing algorithm does not require that <code>type</code> is an integer type, it only needs to have a constructor that initializes it from an <code>int</code>.
If <code>is_bounded</code> is <code>true</code>, parsing requires overflow checking.
Otherwise, parsing does not require overflow checking and <code>max_digit_count</code> and <code>add_digit_checked</code> are not required.
<code>max_digit_count</code> returns the number of digits necessary to express the bounded integers maximal value in the given radix.
It must be bigger than <code>1</code>.
<code>add_digit_unchecked</code> and <code>add_digit_checked</code> add <code>digit</code> to result by doing the equivalent of <code>result = result * Radix + digit</code>.
The <code>_checked</code> version returns <code>true</code> if that has lead to an integer overflow.</p></div><div class=paragraph><p>The primary template works with any integer type and there is a specialization for <code>lexy::code_point</code>.
By wrapping your integer type in <code>lexy::unbounded</code>, you can disable bounds checking during parsing.
It specialization of <code>lexy::integer_traits</code> is built on top of the specialization of <code>lexy::integer_traits&lt;T></code>,
but disables all bounds checking.
You can specialize <code>lexy::integer_traits</code> for your own integer types.</p></div><h4 id=_lexydslzero class=discrete><code>lexy::dsl::zero</code></h4><div class=listingblock><div class=title><code>lexy/dsl/digit.hpp</code></div><div class=content><pre>zero : Token</pre></div></div><div class=paragraph><p>The <code>zero</code> token matches the zero digit.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes the zero digit <code>0</code>.</p></dd><dt class=hdlist1>Errors</dt><dd><p>Raises a <code>lexy::expected_char_class</code> error with the name <code>digit.zero</code>.</p></dd></dl></div><h4 id=_lexydsldigit class=discrete><code>lexy::dsl::digit</code></h4><div class=listingblock><div class=title><code>lexy/dsl/digit.hpp</code></div><div class=content><pre>digit&lt;Base&gt; : Token</pre></div></div><div class=paragraph><p>The <code>digit</code> token matches a digit of the specified base or <code>decimal</code> if no base was specified.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes any of the valid digits of the base.</p></dd><dt class=hdlist1>Errors</dt><dd><p>Raises a <code>lexy::expected_char_class</code> error with the name <code>digit.&lt;base></code>, where <code>&lt;base></code> is <code>binary</code>, <code>hex-lower</code>, etc.</p></dd></dl></div><h4 id=_lexydsldigits class=discrete><code>lexy::dsl::digits</code></h4><div class=listingblock><div class=title><code>lexy/dsl/digit.hpp</code></div><div class=content><pre>digits&lt;Base&gt; : Token

digits&lt;Base&gt;.sep(token)        : Token
digits&lt;Base&gt;.no_leading_zero() : Token</pre></div></div><div class=paragraph><p>The <code>digits</code> token matches a non-empty sequence of digits in the specified base or <code>decimal</code> if no base was specified.
Calling <code>.sep()</code> allows adding a digit separator token that can be present at any point between two digits, but is not required.
Calling <code>.no_leading_zero()</code> raises an error if one or more leading zeros are encountered.
The calls to <code>.sep()</code> and <code>.no_leading_zero()</code> can be chained.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes one or more digits of the specified base.
If a separator was added, it tries to match it after every digit.
It is consumed if it was matched, but it does not fail if no separator was present.
If a separator is matched without a following digit, it fails.
If <code>.no_leading_zero()</code> was called, fails if the first digit was zero and it is followed by another digit or separator.
If it could not match any more digits after the initial one, matching succeeds.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by <code>digit&lt;Base></code>, which can only happen for the initial digit.
Raises a generic error with tag <code>lexy::forbidden_leading_zero</code> if a leading zero was matched.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=Kq1vez class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Matches upper-case hexadecimal digits seperated by &#39; without leading zeroes.
dsl::digits&lt;dsl::hex_upper&gt;.sep(dsl::digit_sep_tick).no_leading_zero()</code></pre></div></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The separator can be placed at any point between two digits.
There is no validation of rules to ensure it is a thousand separator or similar conventions.</td></tr></tbody></table></div><hr><div class=listingblock><div class=title><code>lexy/dsl/digit.hpp</code></div><div class=content><pre>digit_sep_underscore : Token = lit&lt;&#34;_&#34;&gt;
digit_sep_tick       : Token = lit&lt;&#34;&#39;&#34;&gt;</pre></div></div><div class=paragraph><p>For convenience, two common digit separators <code>_</code> and <code>'</code> are predefined as <code>digit_sep_underscore</code> and <code>digit_sep_tick</code> respectively.
However, the digit separator can be an arbitrarily complex token.</p></div><h4 id=_lexydsln_digits class=discrete><code>lexy::dsl::n_digits</code></h4><div class=listingblock><div class=title><code>lexy/dsl/digit.hpp</code></div><div class=content><pre>n_digits&lt;N, Base&gt; : Token

n_digits&lt;N, Base&gt;.sep(token) : Token</pre></div></div><div class=paragraph><p>The <code>n_digits</code> token matches exactly <code>N</code> digits in the specified base or <code>decimal</code> if no base was specified.
Calling <code>.sep()</code> allows adding a digit separator token that can be present at any point between two digits, but is not required.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes exactly <code>N</code> digits of the specified base.
If a separator was added, it tries to match it after every digit.
It is consumed if it was matched, but it does not fail if no separator was present.
If a separator is matched without a following digit, it fails.
Separators do not count towards the digit count.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by <code>digit&lt;Base></code>, which can happen if less than <code>N</code> digits are available.
Raises a generic error with tag <code>lexy::forbidden_leading_zero</code> if a leading zero was matched.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=1YcrGa class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Matches 4 upper-case hexadecimal digits seperated by &#39;.
dsl::n_digits&lt;4, dsl::hex_upper&gt;.sep(dsl::digit_sep_tick)</code></pre></div></div></div></details><h4 id=_lexydslinteger class=discrete><code>lexy::dsl::integer</code></h4><div class=listingblock><div class=title><code>lexy/dsl/integer.hpp</code></div><div class=content><pre>integer&lt;T, Base&gt;(token) : Rule</pre></div></div><div class=paragraph><p>The <code>integer</code> rule converts the lexeme matched by the <code>token</code> into an integer of type <code>T</code> using the given base.
The <code>Base</code> can be omitted if the token is <code>digits</code> or <code>n_digits</code>.
It will then be deduced from the token.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes what <code>token</code> matches.</p></dd><dt class=hdlist1>Values</dt><dd><p>An integer of type <code>T</code> that is created by the characters the token has consumed.
If the token matches characters that are not valid digits of the base (e.g. a digit separator), those characters are skipped.
Otherwise, the character is converted to a digit and added to the resulting integer using the <code>lexy::integer_traits</code>.</p></dd><dt class=hdlist1>Errors</dt><dd><p>Any errors raised by matching the token.
If the integer type <code>T</code> is bounded and the integer value would overflow, a generic error with tag <code>lexy::integer_overflow</code> is raised.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=6ThWPn class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Matches upper-case hexadecimal digits seperated by &#39; without leading zeroes.
// Converts them into an integer, the base is deduced from the token.
dsl::integer&lt;int&gt;(dsl::digits&lt;dsl::hex_upper&gt;
                        .sep(dsl::digit_sep_tick).no_leading_zero())</code></pre></div></div></div></details><h4 id=_lexydslcode_point_id class=discrete><code>lexy::dsl::code_point_id</code></h4><div class=listingblock><div class=title><code>lexy/dsl/integer.hpp</code></div><div class=content><pre>code_point_id&lt;N, Base&gt; : Rule = integer&lt;lexy::code_point&gt;(n_digits&lt;N, Base&gt;)</pre></div></div><div class=paragraph><p>The <code>code_point_id</code> rule is a convenience rule that parses a code point.
It matches <code>N</code> digits in the specified base, which defaults to <code>hex</code>, and converts it into a code point.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes exactly <code>N</code> digits of the specified base.</p></dd><dt class=hdlist1>Values</dt><dd><p>The <code>lexy::code_point</code> that is specified using those digits.</p></dd><dt class=hdlist1>Errors</dt><dd><p>The same error as <code>digit&lt;Base></code> if fewer than <code>N</code> digits are available.
A generic error with tag <code>lexy::integer_overflow</code> if the code point value would exceed the maximum code point.</p></dd></dl></div><h4 id=_lexydslplus_sign_lexydslminus_sign_and_lexydslsign class=discrete><code>lexy::dsl::plus_sign</code>, <code>lexy::dsl::minus_sign</code>, and <code>lexy::dsl::sign</code></h4><div class=listingblock><div class=title><code>lexy/dsl/sign.hpp</code></div><div class=content><pre>plus_sign  : Rule
minus_sign : Rule

sign : Rule</pre></div></div><div class=paragraph><p>The <code>plus_sign</code>, <code>minus_sign</code>, and <code>sign</code> rule match an optional sign.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><div class=dlist><dl><dt class=hdlist1><code>plus_sign</code></dt><dd><p>Matches and consumes a <code>+</code> character, if there is one.</p></dd><dt class=hdlist1><code>minus_sign</code></dt><dd><p>Matches and consumes a <code>-</code> character, if there is one.</p></dd><dt class=hdlist1><code>sign</code></dt><dd><p>Matches and consumes a <code>+</code> or <code>-</code> character, if there is one.</p></dd><dt class=hdlist1>Values</dt><dd><p>If a <code>+</code> sign was consumed, the value is <code>+1</code>.
If a <code>-</code> sign was consumed, the value is <code>-1</code>.
If no sign was consumed, the value is <code>+1</code>.</p></dd></dl></div></dd><dt class=hdlist1>Errors</dt><dd><p>n/a (they don’t fail)</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=7exP55 class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Parse a decimal integer with optional minus sign.
dsl::minus_sign + dsl::integer&lt;int&gt;(dsl::digits&lt;&gt;)</code></pre></div></div></div></details><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>The callback <code>lexy::as_integer</code> takes the value produced by the sign rules together with an integer produced by the <code>integer</code> rule and negates it if necessary.</td></tr></tbody></table></div></div><div class=sect2><h3 id=_delimited_and_quoted>Delimited and quoted</h3><div class=listingblock><div class=title><code>lexy/dsl/delimited.hpp</code></div><div class=content><pre>delimited(open_branch, close_branch)
delimited(open_branch, close_branch).open()  : Branch = open_branch
delimited(open_branch, close_branch).close() : Branch = close_branch</pre></div></div><div class=paragraph><p>A set of open and close delimiters can be specified using <code>delimited()</code>.
The result is not a rule, but a DSL for specifying a sequence of code points to be matched between the delimiters.
The open and close delimiters are defined using branches; they are returned by calling <code>.open()</code> and <code>.close()</code>.</p></div><div class=listingblock><div class=title><code>lexy/dsl/delimited.hpp</code></div><div class=content><pre>delimited(branch) = delimited(branch, branch)</pre></div></div><div class=paragraph><p>There is a convenience overload if the same rule is used for the open and closing delimiters.</p></div><div class=listingblock><div class=title><code>lexy/dsl/delimited.hpp</code></div><div class=content><pre>quoted        = delimited(lit&lt;&#34;\&#34;&#34;&gt;)
triple_quoted = delimited(lit&lt;&#34;\&#34;\&#34;\&#34;&#34;&gt;)

single_quoted = delimited(lit&lt;&#34;&#39;&#34;&gt;)

backticked        = delimited(lit&lt;&#34;`&#34;&gt;)
double_backticked = delimited(lit&lt;&#34;``&#34;&gt;)
triple_backticked = delimited(lit&lt;&#34;```&#34;&gt;)</pre></div></div><div class=paragraph><p>Common delimiters are predefined.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The naming of <code>quoted</code>, <code>triple_quoted</code> and <code>single_quoted</code> is not very logical, but reflects common usage.</td></tr></tbody></table></div><h4 id=_simple_delimited class=discrete>Simple delimited</h4><div class=listingblock><div class=title><code>lexy/dsl/delimited.hpp</code></div><div class=content><pre>d(token) : Branch</pre></div></div><div class=paragraph><p>Calling <code>d(token)</code>, where <code>d</code> is the result of a <code>delimiter()</code> call, results in a rule that matches <code>token</code> as often as possible surrounded by the delimiters.
Everything between the delimiters is captured and forwarded to a sink callback.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p>A production whose rule contains a delimited rule must provide a sink.</p></dd><dt class=hdlist1>Branch Condition</dt><dd><p>Whatever the opening delimiter uses as branch condition.</p></dd><dt class=hdlist1>Matching</dt><dd><p>Matches and consumes the opening delimiter, followed by zero or more occurrences of <code>token</code>, followed by the closing delimiter.
It determines whether or not to parse another instance of <code>token</code> using the condition of the closing delimiter.
Automatic whitespace skipping is disabled while matching the opening and closing delimiter, as well as <code>token</code> using <code>lexy::dsl::no_whitespace()</code>.
After the closing delimiter has been matched and consumed, whitespace is skipped by matching and consuming <code>lexy::dsl::whitespace</code>.</p></dd><dt class=hdlist1>Values</dt><dd><p>Values produced by the opening delimiter, the finished sink (which might be empty), and values produced by the closing delimiter.
Everything captured by matching the <code>token</code> is forwarded to the sink.
The captured lexeme spans over multiple tokens; there isn’t a separate one for each occurrence.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised when matching the opening delimiter and the token.
If EOF is reached without a closing delimiter, a generic error with tag <code>lexy::missing_delimiter</code> is raised.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=nnoMYv class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Match a string consisting of code points that aren&#39;t control characters.
dsl::quoted(dsl::code_point - dsl::ascii::control)</code></pre></div></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The sink is only invoked once. A sink callback is only required for consistency with the overload that takes an escape sequence.</td></tr></tbody></table></div><h4 id=_delimited_with_escape_sequences class=discrete>Delimited with escape sequences</h4><div class=listingblock><div class=title><code>lexy/dsl/delimited.hpp</code></div><div class=content><pre>d(token, escape)  : Branch</pre></div></div><div class=paragraph><p>This overload is used to to specify escape sequences in the delimited.
It behaves like the other overload, but also matches the <code>escape</code> rule.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p>A production whose rule contains a delimited rule must provide a sink.
<code>escape</code> must be a branch.</p></dd><dt class=hdlist1>Branch Condition</dt><dd><p>Whatever the opening delimiter uses as branch condition.</p></dd><dt class=hdlist1>Matching</dt><dd><p>Matches and consumes the opening delimiter, followed by zero or more occurrences of <code>escape</code> or <code>token</code>, followed by the closing delimiter.
It determines whether or not to parse another instance of <code>token</code> using the condition of the closing delimiter.
It first tries to match <code>escape</code>, and only then <code>token</code>.
.
Automatic whitespace skipping is disabled while matching the opening and closing delimiter, as well as <code>token</code> using <code>lexy::dsl::no_whitespace()</code>.
After the closing delimiter has been matched and consumed, whitespace is skipped by matching and consuming <code>lexy::dsl::whitespace</code>.</p></dd><dt class=hdlist1>Values</dt><dd><p>Values produced by the opening delimiter, the finished sink (which might be empty), and values produced by the closing delimiter.
Everything captured by matching the <code>token</code> is forwarded to the sink, as well as all values produced by <code>escape</code>.
The captured lexeme spans over multiple tokens; there isn’t a separate one for each occurrence.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised when matching the opening delimiter, <code>escape</code> and the token.
If EOF is reached without a closing delimiter, a generic error with tag <code>lexy::missing_delimiter</code> is raised.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=vqsfM4 class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Match a string consisting of code points that aren&#39;t control characters.
// `\&#34;` can be used to add a `&#34;` to the string.
dsl::quoted(dsl::code_point - dsl::ascii::control,
            LEXY_LIT(&#34;\\\&#34;&#34;) &gt;&gt; dsl::value_c&lt;&#39;&#34;&#39;&gt;)</code></pre></div></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The closing delimiter is used as termination condition here as well.
If the escape sequence starts with a closing delimiter, it will not be matched.</td></tr></tbody></table></div><h4 id=_lexydslescape class=discrete><code>lexy::dsl::escape()</code></h4><div class=listingblock><div class=title><code>lexy/dsl/delimited.hpp</code></div><div class=content><pre>escape(token) : Rule</pre></div></div><div class=paragraph><p>For convenience, the <code>escape</code> rule can be used to specify the escape token.</p></div><div class=paragraph><p>An escape rule consists of a leading token that matches the escape character (e.g. <code>\</code>), and zero or more alternatives for characters that can be escaped.
It then is equivalent to <code>token >> (alt0 | alt1 | alt2 | error&lt;lexy::invalid_escape_sequence>)</code>.
It will only be considered after the leading token has been matched and then tries to match one of the alternatives.
If no alternative matches, it raises a generic error with tag <code>lexy::invalid_escape_sequence</code>.</p></div><div class=listingblock><div class=title><code>lexy/dsl/delimited.hpp</code></div><div class=content><pre>e.rule(branch) : Rule
  = escape_token &gt;&gt; ( ... | branch
                      | else_ &gt;&gt; error&lt;lexy::invalid_escape_sequence&gt;)</pre></div></div><div class=paragraph><p>Calling <code>e.rule(branch)</code>, where <code>e</code> is an escape rule, adds <code>branch</code> to the end of the choice.</p></div><div class=listingblock><div class=title><code>lexy/dsl/delimited.hpp</code></div><div class=content><pre>e.capture(token) : Rule
  = escape_token &gt;&gt; (... | capture(token)
                      | else_ &gt;&gt; error&lt;lexy::invalid_escape_sequence&gt;)</pre></div></div><div class=paragraph><p>Calling <code>e.capture(token)</code>, where <code>e</code> is an escape rule, adds an escape sequence that matches and captures token to the end of the choice.</p></div><div class=listingblock><div class=title><code>lexy/dsl/delimited.hpp</code></div><div class=content><pre>e.lit&lt;Str&gt;(rule) : Rule
  = escape_token &gt;&gt; (... | lit&lt;Str&gt; &gt;&gt; rule
                      | else_ &gt;&gt; error&lt;lexy::invalid_escape_sequence&gt;)
e.lit&lt;Str&gt;() : Rule
  = e.lit&lt;Str&gt;(value_str&lt;Str&gt;)

e.lit_c&lt;C&gt;(rule) : Rule
  = escape_token &gt;&gt; (... | lit_c&lt;C&gt; &gt;&gt; rule
                      | else_ &gt;&gt; error&lt;lexy::invalid_escape_sequence&gt;)
e.lit_c&lt;C&gt;() : Rule
  = e.lit_c&lt;C&gt;(value_c&lt;C&gt;)</pre></div></div><div class=paragraph><p>Calling <code>e.lit()</code> or <code>e.lit_c()</code>, where <code>e</code> is an escape rule, adds an escape sequences that matches the literal and produces the values of the rule to the end of the choice.
If no rule is specified, it defaults to producing the literal itself.</p></div><div class=listingblock><div class=title><code>lexy/dsl/delimited.hpp</code></div><div class=content><pre>backslash_escape = escape(lit_c&lt;&#39;\\&#39;&gt;)
dollar_escape    = escape(lit_c&lt;&#39;$&#39;&gt;)</pre></div></div><div class=paragraph><p>Common escape characters are predefined.</p></div><details><summary class=title>Example</summary><div class=content><div id=71EEWY class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Match a string consisting of code points that aren&#39;t control characters.
// `\&#34;` can be used to add a `&#34;` to the string.
// `\uXXXX` can be used to add the code point with the specified value.
dsl::quoted(dsl::code_point - dsl::ascii::control,
            dsl::backslash_escape
              .lit_c&lt;&#39;&#34;&#39;&gt;()
              .rule(dsl::lit_c&lt;&#39;u&#39;&gt; &gt;&gt; dsl::code_point_id&lt;4&gt;)</code></pre></div></div></div></details></div><div class=sect2><h3 id=_aggregates>Aggregates</h3><div class=listingblock><div class=title><code>lexy/dsl/member.hpp</code></div><div class=content><pre>member&lt;MemPtr&gt; = rule   : Rule
member&lt;MemPtr&gt; = branch : Branch

LEXY_MEM(Name) = rule   : Rule
LEXY_MEM(Name) = branch : Branch</pre></div></div><div class=paragraph><p>The <code>member</code> rule together with the <code>lexy::as_aggregate&lt;T></code> callback assigns the values produced by the rule given to it via <code>=</code> to the specified member of the aggregate <code>T</code>.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p>A production that contains a member rule needs to use <code>lexy::as_aggregate&lt;T></code> as sink or callback.
The rule must produce exactly one value.</p></dd><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes the <code>rule</code> given to it via <code>=</code>.</p></dd><dt class=hdlist1>Values</dt><dd><p>Produces two values.
The first value identifiers the targeted member.
For <code>member&lt;MemPtr></code>, this is the member pointed to by the member pointer.
For <code>LEXY_MEM(Name)</code>, it is the member with the given <code>Name</code>.
The second value is the value produced by the rule.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised during parsing of the assigned rule.</p></dd></dl></div><div class=paragraph><p>The <code>lexy::as_aggregate&lt;T></code> callback, collects all member and value pairs.
It then constructs an object of type <code>T</code> using value initialization and for each pair assigns the value to the specified member of it.
This works either as callback or a sink.
If a member is specified more than once, the final value is stored at the end.</p></div><details><summary class=title>Example</summary><div class=content><div id=EMYGx1 class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Parses two integers separated by commas.
// The first integer is assigned to a member called `second`,
// the second integer is assigned to a member called `first`.
(LEXY_MEM(second) = dsl::integer&lt;int&gt;(dsl::digits&lt;&gt;))
+ dsl::comma
+ (LEXY_MEM(first) = dsl::integer&lt;int&gt;(dsl::digits&lt;&gt;))</code></pre></div></div></div></details></div><div class=sect2><h3 id=_context_sensitive_parsing>Context sensitive parsing</h3><div class=paragraph><p>To parse context sensitive grammars, <code>lexy</code> allows the creation of <em>context variables</em>.
They allow to save state between different rules which can be used to parse context sensitive elements such as XML with matching opening and closing tag names.</p></div><div class=paragraph><p>A context variable has a type, which is limited to <code>bool</code>, <code>int</code> and <code>lexy::lexeme</code>, and an identifier, which is given by a type.
Before a variable can be used it needs to be created with <code>.create()</code>.
It is then available for all rules of the current production: child and parent production cannot access them.
Variables are not persistent between multiple invocations of a production;
every time a production is parsed it starts out with no variables.</p></div><div class=paragraph><p>See <code>example/xml.cpp</code> for an example that uses the context sensitive parsing facilities.</p></div><h4 id=_lexydslcontext_flag class=discrete><code>lexy::dsl::context_flag</code></h4><div class=listingblock><div class=title><code>lexy/dsl/context_flag.hpp</code></div><div class=content><pre>context_flag&lt;Id&gt;</pre></div></div><div class=paragraph><p>A <code>lexy::dsl::context_flag</code> controls a boolean that can be <code>true</code> or <code>false</code>.
Each object is uniquely identified by the type <code>Id</code>.
It is not a rule but a DSL for specifying operations which are then rules.</p></div><div class=listingblock><div class=content><pre>context_flag&lt;Id&gt;.create() : Rule
context_flag&lt;Id&gt;.create&lt;Value&gt;() : Rule</pre></div></div><div class=paragraph><p>The <code>.create()</code> rule does not interact with the input at all.
When it is parsed, it creates the flag with the given <code>Id</code> and initializes it to the <code>Value</code> (defaulting to <code>false</code>).</p></div><div class=listingblock><div class=content><pre>context_flag&lt;Id&gt;.set()   : Rule
context_flag&lt;Id&gt;.reset() : Rule</pre></div></div><div class=paragraph><p>The <code>.set()</code>/<code>.reset()</code> rules do not interact with the input at all.
When they are parsed, they set the flag with the given <code>Id</code> to <code>true</code>/<code>false</code> respectively.</p></div><div class=listingblock><div class=content><pre>context_flag&lt;Id&gt;.toggle() : Rule</pre></div></div><div class=paragraph><p>The <code>.toggle()</code> rule does not interact with the input at all.
When it is parsed, it toggles the value of the flag with the given <code>Id</code>.</p></div><div class=listingblock><div class=content><pre>context_counter&lt;Id&gt;.select(rule_true, rule_false) : Rule</pre></div></div><div class=paragraph><p>The <code>.select()</code> rule selects on the given rules depending on the value of the flag with the given <code>Id</code>.
It then parses the selected rule.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>If the value of the flag is <code>true</code>, matches and consumes <code>rule_true</code>.
Otherwise, matches and consumes <code>rule_false</code>.</p></dd><dt class=hdlist1>Values</dt><dd><p>All values produced by parsing the selected rule.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by parsing the selected rule.</p></dd></dl></div><div class=listingblock><div class=content><pre>context_flag&lt;Id&gt;.require&lt;ErrorTag&gt;()        : Rule
context_flag&lt;Id&gt;.require&lt;Value, ErrorTag&gt;() : Rule</pre></div></div><div class=paragraph><p>The <code>.require()</code> rule does not interact with the input at all.
When it is parsed, it checks that the value of the flag with the given <code>Id</code> is the given <code>Value</code> (defaults to <code>true</code>).
If that is the case, parsing continues.
Otherwise, the rule fails, producing an error with the given <code>ErrorTag</code>.</p></div><h4 id=_lexydslcontext_counter class=discrete><code>lexy::dsl::context_counter</code></h4><div class=listingblock><div class=title><code>lexy/dsl/context_counter.hpp</code></div><div class=content><pre>context_counter&lt;Id&gt;</pre></div></div><div class=paragraph><p>A <code>lexy::dsl::context_counter</code> controls a C++ <code>int</code>.
Each object is uniquely identified by the type <code>Id</code>.
It is not a rule but a DSL for specifying operations which are then rules.</p></div><div class=listingblock><div class=content><pre>context_counter&lt;Id&gt;.create() : Rule
context_counter&lt;Id&gt;.create&lt;Value&gt;() : Rule</pre></div></div><div class=paragraph><p>The <code>.create()</code> rule does not interact with the input at all.
When it is parsed, it creates the counter with the given <code>Id</code> and initializes it to the <code>Value</code> (defaulting to <code>0</code>).</p></div><div class=listingblock><div class=content><pre>context_counter&lt;Id&gt;.inc() : Rule
context_counter&lt;Id&gt;.dec() : Rule</pre></div></div><div class=paragraph><p>The <code>.inc()</code>/<code>.dec()</code> rules do not interact with the input at all.
When they are parsed, they increment/decrement the counter with the given <code>Id</code> respectively.</p></div><div class=listingblock><div class=content><pre>context_counter&lt;Id&gt;.push(rule) : Rule
context_counter&lt;Id&gt;.pop(rule)  : Rule</pre></div></div><div class=paragraph><p>The <code>.push()</code>/<code>.pop()</code> rules parse the given <code>rule</code>.
The counter with the given <code>Id</code> is then incremented/decremented by the number of characters (code units) consumed by <code>rule</code>.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes <code>rule</code>.</p></dd><dt class=hdlist1>Values</dt><dd><p>All values produced by parsing <code>rule</code>.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by parsing <code>rule</code>.</p></dd></dl></div><div class=listingblock><div class=content><pre>context_counter&lt;Id&gt;.compare&lt;Value&gt;(rule_less, rule_eq, rule_greater) : Rule</pre></div></div><div class=paragraph><p>The <code>.compare()</code> rule compares the value of the counter with the given <code>Id</code> to <code>Value</code>.
It then parses one of the three given rules, depending on the result.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>If the value of the counter is less than <code>Value</code>, matches and consumes <code>rule_less</code>.
If the value of the counter is equal than <code>Value</code>, matches and consumes <code>rule_eq</code>.
If the value of the counter is greater than <code>Value</code>, matches and consumes <code>rule_greater</code>.</p></dd><dt class=hdlist1>Values</dt><dd><p>All values produced by parsing the selected rule.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by parsing the selected rule.</p></dd></dl></div><div class=listingblock><div class=content><pre>context_counter&lt;Id&gt;.require&lt;ErrorTag&gt;()        : Rule
context_counter&lt;Id&gt;.require&lt;Value, ErrorTag&gt;() : Rule</pre></div></div><div class=paragraph><p>The <code>.require()</code> rule does not interact with the input at all.
When it is parsed, it checks that the value of the counter with the given <code>Id</code> is the given <code>Value</code> (defaults to <code>0</code>).
If that is the case, parsing continues.
Otherwise, the rule fails, producing an error with the given <code>ErrorTag</code>.</p></div><h4 id=_lexydslcontext_lexeme class=discrete><code>lexy::dsl::context_lexeme</code></h4><div class=listingblock><div class=title><code>lexy/dsl/context_lexeme.hpp</code></div><div class=content><pre>context_lexeme&lt;Id&gt;</pre></div></div><div class=paragraph><p>A <code>lexy::dsl::context_flag</code> controls a <code>lexy::lexeme</code> (i.e. a string view on part of the input).
Each object is uniquely identified by the type <code>Id</code>.
It is not a rule but a DSL for specifying operations which are then rules.</p></div><div class=listingblock><div class=content><pre>context_lexeme&lt;Id&gt;.create() : Rule</pre></div></div><div class=paragraph><p>The <code>.create()</code> rule does not interact with the input at all.
When it is parsed, it creates the lexeme with the given <code>Id</code> and initializes it to an empty view.</p></div><div class=listingblock><div class=content><pre>context_lexeme&lt;Id&gt;.capture(rule) : Rule</pre></div></div><div class=paragraph><p>The <code>.capture()</code> rule parses the given <code>rule</code>.
The lexeme with the given <code>Id</code> is then set to view everything the <code>rule</code> has consumed as-if <code>lexy::dsl::capture()</code> was used.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes <code>rule.</code></p></dd><dt class=hdlist1>Values</dt><dd><p>All values produced by parsing <code>rule</code>.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by parsing <code>rule</code>.</p></dd></dl></div><div class=listingblock><div class=content><pre>context_lexeme&lt;Id&gt;.require&lt;ErrorTag&gt;(rule) : Rule</pre></div></div><div class=paragraph><p>The <code>.require()</code> rule parses the given <code>rule</code>, capturing it in a temporary lexeme.
The temporary lexeme is then compared with the lexeme given by the <code>Id</code>.
If the two lexemes are equal, parsing continues.
Otherwise, the rule fails, producing an error with the given <code>ErrorTag</code>.</p></div><div class=dlist><dl><dt class=hdlist1>Matches</dt><dd><p>Matches and consumes <code>rule.</code></p></dd><dt class=hdlist1>Values</dt><dd><p>Discards values produced by <code>rule</code>.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by parsing <code>rule</code>.</p></dd></dl></div></div><div class=sect2><h3 id=_raw_input>Raw input</h3><div class=paragraph><p>The following facilities are meant for parsing input that uses the <code>lexy::raw_encoding</code>, that is input consisting of bytes, not text.</p></div><h4 id=_lexydslbom class=discrete><code>lexy::dsl::bom</code></h4><div class=listingblock><div class=title><code>lexy/dsl/bom.hpp</code></div><div class=content><pre>bom&lt;Encoding, Endianness&gt; : Token</pre></div></div><div class=paragraph><p>The <code>bom</code> token matches the byte-order mark (BOM) for the given encoding and <code>lexy::encoding_endianness</code>.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p><code>Endianness</code> is <code>lexy::encoding_endianness::little</code> or <code>lexy::encoding_endianness::big</code>.</p></dd><dt class=hdlist1>Matches</dt><dd><p>If the encoding has a BOM, matches and consumes the BOM written in the given endianness.</p></dd><dt class=hdlist1>Errors</dt><dd><p>A <code>lexy::expected_char_class</code> error with the name <code>BOM.&lt;encoding>-&lt;endianness></code> if the BOM was not matched.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=xbnEYs class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Matches the UTF-16 big endian BOM (0xFE, 0xFF).
dsl::bom&lt;lexy::utf16_encoding, lexy::encoding_endianness::big&gt;</code></pre></div></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>There is a UTF-8 BOM, but it is the same regardless of endianness.</td></tr></tbody></table></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>This rule is only necessary when you have a raw encoding that contains a BOM.
For example, <code>lexy::read_file()</code> already handles and deals with BOMs for you by default.</td></tr></tbody></table></div><h4 id=_lexydslencode class=discrete><code>lexy::dsl::encode</code></h4><hr><div class=paragraph><p>encode&lt;Encoding, Endianness>(rule) : Rule
---</p></div><div class=paragraph><p>The <code>encode</code> rule temporarily changes the encoding of the input.
The specified <code>rule</code> will be matched using a <code>Reader</code> whose encoding is <code>Encoding</code> converted from the raw bytes using the specified endianness.
If no <code>Endianness</code> is specified, the default is <code>lexy::encoding_endianness::bom</code>, and a BOM is matched on the input to determine the endianness.
If no BOM is present, big endian is assumed.</p></div><div class=dlist><dl><dt class=hdlist1>Requires</dt><dd><p>The input’s encoding is a single-byte encoding (usually <code>lexy::raw_encoding</code>).</p></dd><dt class=hdlist1>Matches</dt><dd><p>If the endianness is <code>lexy::encoding_endianness::bom</code>, matches and consumes an optional BOM to determine endianness.
Matches and consumes <code>rule</code>.
However, the input of rule are characters according to <code>Encoding</code> and <code>Endianness</code>, not the single bytes of the actual input.</p></dd><dt class=hdlist1>Values</dt><dd><p>All values produced by the rule.</p></dd><dt class=hdlist1>Errors</dt><dd><p>All errors raised by the rule.
The error type uses the original reader, not the encoded reader that does the input translation.</p></dd></dl></div><details><summary class=title>Example</summary><div class=content><div id=Y51r9v class=listingblock><div class=content><pre class=highlight><code class=language-cpp data-lang=cpp>// Matches a UTF-8 code point, followed by an ASCII code point.
dsl::encode&lt;lexy::utf8_encoding&gt;(dsl::code_point)
    + dsl::encode&lt;lexy::ascii_encoding&gt;(dsl::code_point)</code></pre></div></div></div></details></div><div class=sect2><h3 id=_custom_rules>Custom rules</h3><div class=paragraph><p>The exact interface for the <code>Rule</code>, <code>Token</code> and <code>Branch</code> concepts is currently still experimental.
Refer to the existing rules if you want to add your own.</p></div></div></div></div></article></main><footer id=page-footer><section class=copyright>&copy; 2020-2021</section><section class=patreon><a target=_blank href=https://jonathanmueller.dev/support-me/>Support me!</a>.</section><section class=poweredby>Made with <a target=_blank href=https://gohugo.io>Hugo</a>.</section></footer></body></html>