<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Reference — lexy</title><style>:root{--white:white;--header-white:rgba(255, 255, 255, .75);--background-color:#fdfdfd;--default-color:#101010;--heading-color:#0A0A0A;--link-color:#2A2A2A;--gray-highlight-color:#aaaaaa;--highlight-color:#2861ce}@media(prefers-color-scheme:dark){:root{--white:#020202;--header-white:rgba(2, 2, 2, .75);--background-color:#222222;--default-color:#efefef;--heading-color:#f5f5f5;--link-color:#d5d5d5;--gray-highlight-color:#555555}}nav#menu div.menu-container,main{max-width:1200px;margin:0 auto;padding:0 10px}@media(min-width:800px){article{max-width:900px;margin:0 auto;padding:0 10px}}html{position:relative;min-height:100%;margin:0;padding:0}body{font-family:serif;font-size:18px;color:var(--default-color);background-color:var(--background-color);width:100%;padding:0;margin:0}main{margin-bottom:75px}h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:700;line-height:1.15em;color:var(--heading-color);margin:0 0 .4em;hyphens:auto}h1{font-size:2em}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h5{font-size:1.15em}h6{font-size:1.1em}a,a svg,button svg{color:var(--link-color);transition:color ease .3s}a:hover,a svg:hover,button svg:hover{color:var(--highlight-color)}a:focus,a svg:focus,button svg:focus{outline:none}br{margin:1em}article p,article ul,article ol,article dl,article td{hyphens:auto;text-align:justify}nav#menu{width:100%;padding:0;background-color:var(--white);border-bottom:2px solid var(--highlight-color);font-family:sans-serif;font-size:1.3em}nav#menu div.menu-container{display:flex}nav#menu div.menu-container ul{display:flex;flex-direction:row;align-items:center;padding:0;list-style:none}nav#menu div.menu-container ul li a{text-decoration:none}nav#menu div.menu-container ul li a svg{height:1em}nav#menu div.menu-container ul li a.active{border-width:0 0 2px;border-style:solid;border-color:var(--highlight-color)}nav#menu div.menu-container ul#home{padding-left:0;padding-right:10px}nav#menu div.menu-container ul#home .title{font-weight:700}nav#menu div.menu-container ul#main{margin-left:auto}nav#menu div.menu-container ul#main li{padding-left:20px}@media(max-width:600px){nav#menu div.menu-container ul#main{flex-direction:column;align-items:flex-end;margin:5px 10px 0 auto}}footer#page-footer{position:absolute;bottom:0;left:0;right:0;height:2em;display:flex;justify-content:space-between;font-size:.8em;font-weight:200;line-height:1em;border-top:1px solid #ccc}footer#page-footer section{padding-left:1em;padding-right:1em;padding-top:.5em;width:100%}footer#page-footer .copyright{text-align:left}footer#page-footer .patreon{text-align:center}footer#page-footer .poweredby{text-align:right}@media(max-width:450px){footer#page-footer{flex-direction:column;align-items:flex-start}footer#page-footer section{text-align:initial!important;width:initial}}aside.toc{display:none}@media(min-width:1100px){aside.toc{display:initial;position:sticky;top:1em;float:left;width:300px}aside.toc header{font-weight:700}aside.toc ul{list-style:none;padding:0}aside.toc ul ul{padding-left:1em;padding-bottom:.5em}aside.toc a{text-decoration:none}aside.toc~article{padding-left:300px}}article header{margin-top:1em;margin-bottom:1em}article header nav{display:flex;flex-wrap:wrap}article header nav a{text-decoration:none;padding-right:7px}article header nav a svg{height:1em;position:relative;top:2px}@media(min-width:700px){article header nav form.search{margin-left:auto}}article header nav form.search input[type=search]{padding:2px;width:250px}article header nav form.search input[type=search]:focus{border-color:var(--highlight-color);outline:solid var(--highlight-color)1px}article header nav form.search button[type=submit]{margin-left:-25px;border:none;background:initial}article header nav form.search button[type=submit] svg{height:1em}article .lead p{font-weight:500;font-size:1.1em}article .admonitionblock{margin-bottom:1em}article .admonitionblock td.icon{font-weight:700}article .admonitionblock td.content div:first-child p{margin-top:0}article .admonitionblock td.content div:last-child p{margin-bottom:0}@media(max-width:600px){article .admonitionblock tr{display:block;float:left;padding-left:.5em;padding-right:.5em}article .admonitionblock tr td{display:block}}@media(min-width:600px){article .admonitionblock td.icon{width:75px;text-align:center;border-right:1px solid var(--gray-highlight-color)}article .admonitionblock td.content{padding-left:.5em}}article .exampleblock{margin-top:1em;margin-bottom:1em}article .exampleblock .title{font-style:italic}article a.github-example{text-decoration:none}article a.github-example svg{height:.8em;position:relative;top:2px}article .playground-example .title,article .godbolt-example .title{position:relative}article .playground-example .title a,article .godbolt-example .title a{position:absolute;top:7px;right:7px}article .playground-example .title a svg,article .godbolt-example .title a svg{height:1em}article details{margin-bottom:1em}article details summary{font-style:italic}article ul p,article ol p{margin:.2em}article div ul:not(:first-child),article div ol:not(:first-child){margin-top:0}article dl dt{margin-top:.5em;font-weight:700}article dl dd p,article dl dd div:only-child ul{margin:0;padding:0}article div dl:not(:first-child){margin-top:0}article table.tableblock{background:var(--white);margin:0 auto;border-collapse:collapse}article table.tableblock td,article table.tableblock th{border:1px solid var(--gray-highlight-color);padding:5px;text-align:left}article table.tableblock td p,article table.tableblock th p{margin:0}article div.sidebarblock{border:1px solid var(--gray-highlight-color);padding:.75em;margin:1em}article div.sidebarblock p{margin:0}article code{font-family:Inconsolata,monospace,sans-serif}article pre{margin:0;overflow:auto;padding:10px;background:var(--white);border:1px solid var(--gray-highlight-color);line-height:1.1}article .colist{margin-top:-.5em}article .colist ol{counter-reset:list}article .colist ol li{counter-increment:list;padding-left:1em}article .colist ol ::marker{content:"(" counter(list)")";font-weight:700}article .colist p{margin:0}.highlight .tok-c,.highlight .tok-cm,.highlight .tok-cp,.highlight .tok-c1,.highlight .tok-cs,.ace_editor .tok-c,.ace_editor .tok-cm,.ace_editor .tok-cp,.ace_editor .tok-c1,.ace_editor .tok-cs{color:#998;font-style:italic;font-weight:initial}.highlight .tok-k,.highlight .tok-kc,.highlight .tok-kd,.highlight .tok-kp,.highlight .tok-kr,.highlight .tok-kt,.highlight .ace_storage,.highlight .ace_keyword,.ace_editor .tok-k,.ace_editor .tok-kc,.ace_editor .tok-kd,.ace_editor .tok-kp,.ace_editor .tok-kr,.ace_editor .tok-kt,.ace_editor .ace_storage,.ace_editor .ace_keyword{color:#458;font-style:initial;font-weight:700}.highlight .tok-o,.highlight .tok-p,.highlight .ace_keyword.ace_operator,.highlight .ace_paren,.highlight .ace_punctuation,.ace_editor .tok-o,.ace_editor .tok-p,.ace_editor .ace_keyword.ace_operator,.ace_editor .ace_paren,.ace_editor .ace_punctuation{color:red;font-style:initial;font-weight:initial}.highlight .ace_dsl,.ace_editor .ace_dsl{text-decoration:underline;cursor:pointer;pointer-events:auto}.highlight .tok-m,.highlight .tok-mf,.highlight .tok-mh,.highlight .tok-mi,.highlight .tok-mo,.highlight .ace_constant,.ace_editor .tok-m,.ace_editor .tok-mf,.ace_editor .tok-mh,.ace_editor .tok-mi,.ace_editor .tok-mo,.ace_editor .ace_constant{color:#ff8000;font-style:initial;font-weight:initial}.highlight .tok-s,.highlight .tok-sb,.highlight .tok-sc,.highlight .tok-sd,.highlight .tok-s2,.highlight .tok-s3,.highlight .tok-sh,.highlight .tok-si,.highlight .tok-sx,.highlight .tok-sr,.highlight .tok-s1,.highlight .tok-ss,.highlight .tok-se,.highlight .ace_string,.ace_editor .tok-s,.ace_editor .tok-sb,.ace_editor .tok-sc,.ace_editor .tok-sd,.ace_editor .tok-s2,.ace_editor .tok-s3,.ace_editor .tok-sh,.ace_editor .tok-si,.ace_editor .tok-sx,.ace_editor .tok-sr,.ace_editor .tok-s1,.ace_editor .tok-ss,.ace_editor .tok-se,.ace_editor .ace_string{color:green;font-style:initial;font-weight:initial}.highlight .tok-cp,.ace_editor .tok-cp{color:green;font-style:initial;font-weight:700}.highlight .tok-err,.highlight .ace_invalid,.ace_editor .tok-err,.ace_editor .ace_invalid{color:red;font-style:initial;font-weight:initial}.highlight strong,.ace_editor strong{font-weight:initial}.highlight strong:not(:empty)::before,.ace_editor strong:not(:empty)::before{content:"*";color:red}.highlight strong:not(:empty)::after,.ace_editor strong:not(:empty)::after{content:"*";color:red}</style></head><body><nav id=menu><div class=menu-container><ul id=home><li><a href=/><span class=title>lexy:</span> C++ parser combinator library</a></li></ul><ul id=main><li><a href=/tutorial/>Tutorial</a></li><li><a class=active href=/reference/>Reference</a></li><li><a href=/reference/dsl/>DSL</a></li><li><a href=/playground/>Playground</a></li><li><a href=https://github.com/foonathan/lexy title=GitHub><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li></ul></div></nav><main><aside class=toc><header><a href=#>Table of Contents</a></header><nav id=TableOfContents><ul><li><a href=#_infrastructure>Infrastructure</a></li><li><a href=#_inputs_and_encodings>Inputs and Encodings</a></li><li><a href=#_tokens>Tokens</a><ul><li><a href=#_token_kind>Token Kind</a></li><li><a href=#_token_kind_map>Token Kind Map</a></li><li><a href=#_token>Token</a></li></ul></li><li><a href=#_matching_parsing_and_validating>Matching, parsing and validating</a><ul><li><a href=#_callbacks>Callbacks</a></li><li><a href=#_error_handling>Error handling</a></li><li><a href=#_parse_tree>Parse Tree</a></li></ul></li><li><a href=#_the_rule_dsl>The rule DSL</a></li><li><a href=#_glossary>Glossary</a></li></ul></nav></aside><article><div class=paragraph><p>This is the reference documentation for lexy.</p></div><div class=sidebarblock><div class=content><div class=paragraph><p>The documentation is currently in the process of being rewritten.
As such, some parts of this page are already transformed into high-level entry points with links to the actual documentation,
while others are still the full documentation inline.</p></div></div></div><div class=sect1><h2 id=_infrastructure>Infrastructure</h2><div class=sectionbody><div class=dlist><dl><dt class=hdlist1><a href=/reference/code_point/#code_point><code>lexy::code_point</code></a></dt><dd><p>A Unicode code point.</p></dd><dt class=hdlist1><a href=/reference/lexeme/#lexeme><code>lexy::lexeme</code></a></dt><dd><p>A lexeme, i.e. a subrange of the input.</p></dd></dl></div></div></div><div class=sect1><h2 id=_inputs_and_encodings>Inputs and Encodings</h2><div class=sectionbody><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>T</span><span class=tok-o>&gt;</span>
<span class=tok-k>concept</span> <span class=tok-nc>reader</span> <span class=tok-o>=</span> <span class=tok-err>…</span><span class=tok-p>;</span>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-o>&gt;</span>
<span class=tok-k>concept</span> <span class=tok-nc>input</span> <span class=tok-o>=</span> <span class=tok-k>requires</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>obj</span><span class=tok-p>)</span> <span class=tok-p>{</span>
  <span class=tok-p>{</span> <span class=tok-n>obj</span><span class=tok-p>.</span><span class=tok-n>reader</span><span class=tok-p>()</span> <span class=tok-p>}</span> <span class=tok-o>-&gt;</span> <span class=tok-n>reader</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>An input defines the input that will be parsed by lexy.
It has a corresponding <a href=/reference/encoding/#doc>encoding</a> that controls, among other things, its character type and whether certain rules are available.
The input itself is unchanging and it produces a reader which remembers the current position of the input during parsing.</p></div><div class=dlist><div class=title>The supported encodings:</div><dl><dt class=hdlist1><a href=/reference/encoding/#encoding><code>lexy::default_encoding</code></a></dt><dd><p>An unknown single byte encoding.</p></dd><dt class=hdlist1><a href=/reference/encoding/#encoding><code>lexy::ascii_encoding</code></a></dt><dd><p>ASCII</p></dd><dt class=hdlist1><a href=/reference/encoding/#encoding><code>lexy::utf8_encoding</code></a>, <a href=/reference/encoding/#encoding><code>lexy::utf16_encoding</code></a>, <a href=/reference/encoding/#encoding><code>lexy::utf32_encoding</code></a></dt><dd><p>UTF-8, UTF-16, UTF-32</p></dd><dt class=hdlist1><a href=/reference/encoding/#encoding><code>lexy::byte_encoding</code></a></dt><dd><p>Bytes, not text.</p></dd></dl></div><div class=dlist><div class=title>The pre-defined inputs:</div><dl><dt class=hdlist1><a href=/reference/input/range_input/#range_input><code>lexy::range_input</code></a></dt><dd><p>Use a generic iterator range as input.</p></dd><dt class=hdlist1><a href=/reference/input/string_input/#string_input><code>lexy::string_input</code></a> and <a href=/reference/input/string_input/#zstring_input><code>lexy::zstring_input</code></a></dt><dd><p>Use a string as input.</p></dd><dt class=hdlist1><a href=/reference/input/buffer/#buffer><code>lexy::buffer</code></a></dt><dd><p>Create a buffer that contains the input.</p></dd><dt class=hdlist1><a href=/reference/input/file/#read_file><code>lexy::read_file</code></a></dt><dd><p>Use a file as input.</p></dd><dt class=hdlist1><a href=/reference/input/argv_input/#argv_input><code>lexy::argv_input</code></a></dt><dd><p>Use the command-line arguments as input.</p></dd></dl></div></div></div><div class=sect1><h2 id=_tokens>Tokens</h2><div class=sectionbody><div class=sect2><h3 id=_token_kind>Token Kind</h3><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>enum</span> <span class=tok-nc>predefined_token_kind</span>
    <span class=tok-p>{</span>
        <span class=tok-n>unknown_token_kind</span><span class=tok-p>,</span>
        <span class=tok-n>eof_token_kind</span><span class=tok-p>,</span>
        <span class=tok-n>position_token_kind</span><span class=tok-p>,</span>
        <span class=tok-n>identifier_token_kind</span><span class=tok-p>,</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span> <span class=tok-o>=</span> <span class=tok-kt>void</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>token_kind</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>token_kind</span><span class=tok-p>()</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-nf>token_kind</span><span class=tok-p>(</span><span class=tok-n>predefined_token_kind</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-nf>token_kind</span><span class=tok-p>(</span><span class=tok-n>TokenKind</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>TokenRule</span><span class=tok-o>&gt;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>token_kind</span><span class=tok-p>(</span><span class=tok-n>TokenRule</span> <span class=tok-n>token_rule</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-k>operator</span> <span class=tok-kt>bool</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_predefined</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>name</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-n>TokenKind</span> <span class=tok-n>get</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>static</span> <span class=tok-k>constexpr</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>uint_least16_t</span> <span class=tok-n>to_raw</span><span class=tok-p>(</span><span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>kind</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>static</span> <span class=tok-k>constexpr</span> <span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>from_raw</span><span class=tok-p>(</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>uint_least16_t</span> <span class=tok-n>kind</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>friend</span> <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>token_kind</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>token_kind</span> <span class=tok-n>rhs</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>friend</span> <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>token_kind</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>token_kind</span> <span class=tok-n>rhs</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The class <code>lexy::token_kind</code> identifies a token rule.
It is merely a wrapper over the specified <code>TokenKind</code>, which is an enum.
If <code>TokenKind</code> is <code>void</code>, it is a wrapper over an <code>int</code>.</p></div><div class=paragraph><p>A token kind can represent any of the <code>lexy::predefined_token_kind</code> as well as any values specified in the given enum,
or any integer value.
Predefined token kinds are mapped to spare enum values.</p></div><div class=sect3><h4 id=_constructors>Constructors</h4><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-nf>token_kind</span><span class=tok-p>()</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>                         // <b class=conum>(1)</b>

<span class=tok-k>constexpr</span> <span class=tok-nf>token_kind</span><span class=tok-p>(</span><span class=tok-n>predefined_token_kind</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b>

<span class=tok-k>constexpr</span> <span class=tok-nf>token_kind</span><span class=tok-p>(</span><span class=tok-n>TokenKind</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(3)</b>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>TokenRule</span><span class=tok-o>&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-n>token_kind</span><span class=tok-p>(</span><span class=tok-n>TokenRule</span> <span class=tok-n>token_rule</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(4)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Creates an unknown token kind.</p></li><li><p>Creates a predefined token kind.</p></li><li><p>Creates the specified token kind, if <code>TokenKind</code> is <code>void</code>, constructor takes an <code>int</code>.</p></li><li><p>Creates a token kind from a token rule.</p></li></ol></div><div class=paragraph><p>The token kind of a rule is computed as follows:</p></div><div class=ulist><ul><li><p>If the token rule was associated with a token kind by calling <code>.kind&lt;value></code>, the resulting kind is the specified <code>value></code>.</p></li><li><p>Otherwise, if the map found at <code>lexy::token_kind_map_for&lt;TokenKind></code> contains a mapping for the <code>TokenRule</code>, it uses that.</p></li><li><p>Otherwise, the token kind is unknown.</p></li></ul></div></div><div class=sect3><h4 id=_access>Access</h4><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-k>operator</span> <span class=tok-kt>bool</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>

<span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_predefined</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b>

<span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>name</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(3)</b>

<span class=tok-k>constexpr</span> <span class=tok-n>TokenKind</span> <span class=tok-n>get</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(4)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns <code>true</code> if the token kind is not unknown, <code>false</code> otherwise.</p></li><li><p>Returns <code>true</code> if the token kind one of the <code>lexy::predefined_token_kind`s, `false</code> otherwise.</p></li><li><p>Returns the name of the token kind.</p></li><li><p>Returns the underlying value of the token kind, which is some other value for predefined tokens.</p></li></ol></div><div class=paragraph><p>The name of a token kind is determined as follows:</p></div><div class=ulist><ul><li><p>If the <code>TokenKind</code> is <code>void</code>, the name is <code>"token"</code> for all token kinds.</p></li><li><p>Otherwise, if the token kind is unknown, the name is <code>"token"</code>.</p></li><li><p>Otherwise, if the token kind is predefined, the name describes the predefined token.</p></li><li><p>Otherwise, if ADL finds an overload <code>const char* token_kind_name(TokenKind kind)</code>,
returns that as the name.</p></li><li><p>Otherwise, the name is <code>"token"</code> for all tokens.</p></li></ul></div></div></div><div class=sect2><h3 id=_token_kind_map>Token Kind Map</h3><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>class</span> <span class=tok-nc>Token</span><span class=tok-o>-</span><span class=tok-n>Kind</span><span class=tok-o>-</span><span class=tok-n>Map</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>auto</span> <span class=tok-n>TokenKind</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenRule</span><span class=tok-o>&gt;</span>
        <span class=tok-k>consteval</span> <span class=tok-n>Token</span><span class=tok-o>-</span><span class=tok-n>Kind</span><span class=tok-o>-</span><span class=tok-n>Map</span> <span class=tok-n>map</span><span class=tok-p>(</span><span class=tok-n>TokenRule</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-kr>inline</span> <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>token_kind_map</span> <span class=tok-o>=</span> <span class=tok-n>Token</span><span class=tok-o>-</span><span class=tok-n>Kind</span><span class=tok-o>-</span><span class=tok-n>Map</span><span class=tok-p>{};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>token_kind_map_for</span> <span class=tok-o>=</span> <span class=tok-n>token_kind_map</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>There are two ways to associate a token kind with a token rule.
Either by calling <code>.kind&lt;Kind></code> on the token rule and giving it a value there,
or by specializing the <code>lexy::token_kind_map_for</code> for your <code>TokenKind</code> enumeration.</p></div><details><summary class=title>Example</summary><div class=content><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>enum</span> <span class=tok-k>class</span> <span class=tok-nc>my_token_kind</span> // <b class=conum>(1)</b>
<span class=tok-p>{</span>
    <span class=tok-n>code_point</span><span class=tok-p>,</span>
    <span class=tok-n>period</span><span class=tok-p>,</span>
    <span class=tok-n>open_paren</span><span class=tok-p>,</span>
    <span class=tok-n>close_paren</span><span class=tok-p>,</span>
<span class=tok-p>};</span>

// <b class=conum>(2)</b>
<span class=tok-k>template</span> <span class=tok-o>&lt;&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>token_kind_map_for</span><span class=tok-o>&lt;</span><span class=tok-n>my_token_kind</span><span class=tok-o>&gt;</span>
    <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>token_kind_map</span><span class=tok-p>.</span><span class=tok-n>map</span><span class=tok-o>&lt;</span><span class=tok-n>my_token_kind</span><span class=tok-o>::</span><span class=tok-n>code_point</span><span class=tok-o>&gt;</span><span class=tok-p>(</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>dsl</span><span class=tok-o>::</span><span class=tok-n>code_point</span><span class=tok-p>)</span>
                          <span class=tok-p>.</span><span class=tok-n>map</span><span class=tok-o>&lt;</span><span class=tok-n>my_token_kind</span><span class=tok-o>::</span><span class=tok-n>period</span><span class=tok-o>&gt;</span><span class=tok-p>(</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>dsl</span><span class=tok-o>::</span><span class=tok-n>period</span><span class=tok-p>)</span>
                          <span class=tok-p>.</span><span class=tok-n>map</span><span class=tok-o>&lt;</span><span class=tok-n>my_token_kind</span><span class=tok-o>::</span><span class=tok-n>open_paren</span><span class=tok-o>&gt;</span><span class=tok-p>(</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>dsl</span><span class=tok-o>::</span><span class=tok-n>parenthesized</span><span class=tok-p>.</span><span class=tok-n>open</span><span class=tok-p>())</span>
                          <span class=tok-p>.</span><span class=tok-n>map</span><span class=tok-o>&lt;</span><span class=tok-n>my_token_kind</span><span class=tok-o>::</span><span class=tok-n>close_paren</span><span class=tok-o>&gt;</span><span class=tok-p>(</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>dsl</span><span class=tok-o>::</span><span class=tok-n>parenthesized</span><span class=tok-p>.</span><span class=tok-n>close</span><span class=tok-p>());</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Define your <code>TokenKind</code> enumeration.</p></li><li><p>Define the mapping of token rules to enumeration values.</p></li></ol></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The token kind is only relevant when <code>lexy::parse_as_tree()</code> is used to parse the input.</td></tr></tbody></table></div></div><div class=sect2><h3 id=_token>Token</h3><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre>namespace lexy
{
    template &lt;typename Reader, typename TokenKind = void&gt;
    class token
    {
    public:
        explicit constexpr token(token_kind&lt;TokenKind&gt; kind, lexy::lexeme&lt;Reader&gt; lex) noexcept;
        explicit constexpr token(token_kind&lt;TokenKind&gt; kind,
                                 typename Reader::iterator begin,
                                 typename Reader::iterator end) noexcept;

        constexpr token_kind&lt;TokenKind&gt; kind() const noexcept;
        constexpr auto lexeme() const noexcept;

        constexpr auto name() const noexcept { return kind().name(); }

        constexpr auto position() const noexcept -&gt; typename Reader::iterator
        {
            return lexeme().begin();
        }
    };

    template &lt;typename Input, typename TokenKind = void&gt;
    using token_for = token&lt;input_reader&lt;Input&gt;, TokenKind&gt;;
}</pre></div></div><div class=paragraph><p>The class <code>lexy::token</code> just combines a <code>lexy::token_kind</code> and a <code>lexy::lexeme</code>.</p></div></div></div></div><div class=sect1><h2 id=_matching_parsing_and_validating>Matching, parsing and validating</h2><div class=sectionbody><div class=listingblock><div class=title>The <code>Production</code> concept</div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>struct</span> <span class=tok-nc>Production</span>
<span class=tok-p>{</span>
    <span class=tok-k>static</span> <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>rule</span> <span class=tok-o>=</span> <span class=tok-err>…</span><span class=tok-p>;</span>
    <span class=tok-k>static</span> <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>whitespace</span> <span class=tok-o>=</span> <span class=tok-err>…</span><span class=tok-p>;</span> <span class=tok-c1>// optional</span>

    <span class=tok-k>static</span> <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>value</span> <span class=tok-o>=</span> <span class=tok-err>…</span><span class=tok-p>;</span> <span class=tok-c1>// optional</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>A <code>Production</code> is type containing a rule and optional callbacks that produce the value.
A grammar contains an entry production where parsing begins and all productions referenced by it.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>It is recommended to put all productions of a grammar into a separate namespace.</td></tr></tbody></table></div><div class=paragraph><p>By passing the entry production of the grammar to <code>lexy::match()</code>, <code>lexy::parse()</code>, or <code>lexy::validate()</code>, the production is parsed.</p></div><h3 id=_matching class=discrete>Matching</h3><div class=listingblock><div class=title><code>lexy/match.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>match</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>);</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The function <code>lexy::match()</code> matches the <code>Production</code> on the given <code>input</code>.
If the production accepts the input, returns <code>true</code>, otherwise, returns <code>false</code>.
It will discard any values produced and does not give detailed information about why the production did not accept the input.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>A production does not necessarily need to consume the entire input for it to match.
Add <code>lexy::dsl::eof</code> to the end if the production should consume the entire input.
42</td></tr></tbody></table></div><h3 id=_validating class=discrete>Validating</h3><div class=listingblock><div class=title><code>lexy/validate.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>ErrorCallback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>validate_result</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>using</span> <span class=tok-n>error_callback</span> <span class=tok-o>=</span> <span class=tok-n>ErrorCallback</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>error_type</span>     <span class=tok-o>=</span> <span class=tok-cm>/* return type of the sink */</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-k>operator</span> <span class=tok-kt>bool</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span>
        <span class=tok-p>{</span>
            <span class=tok-k>return</span> <span class=tok-nf>is_success</span><span class=tok-p>();</span>
        <span class=tok-p>}</span>

        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_success</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_recovered_error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(3)</b>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_fatal_error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(4)</b>

        <span class=tok-k>constexpr</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>error_count</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-n>error_type</span><span class=tok-o>&amp;</span> <span class=tok-n>errors</span><span class=tok-p>()</span> <span class=tok-k>const</span><span class=tok-o>&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>error_type</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>errors</span><span class=tok-p>()</span> <span class=tok-o>&amp;&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>ErrorCallback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>validate</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>,</span> <span class=tok-n>ErrorCallback</span> <span class=tok-n>error_callback</span><span class=tok-p>)</span>
        <span class=tok-o>-&gt;</span> <span class=tok-n>validate_result</span><span class=tok-o>&lt;</span><span class=tok-n>ErrorCallback</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns <code>true</code> if no error occurred during validation.</p></li><li><p>Returns <code>true</code> if at least one error occurred during validation.</p></li><li><p>Returns <code>true</code> if at least one error occurred during validation, but parsing could recover after all of them.</p></li><li><p>Returns <code>true</code> if at least one error occurred during validation and parsing had to cancel.</p></li></ol></div><div class=paragraph><p>The function <code>lexy::validate()</code> validates that the <code>Production</code> matches on the given <code>input</code>.
If a parse error occurs, it will invoke the error callback (see <a href=#_error_handling>Error handling</a>); all errors are then returned.
It will discard any values produced.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>A production does not necessarily need to consume the entire input for it to match.
Add <code>lexy::dsl::eof</code> to the end if the production should consume the entire input.</td></tr></tbody></table></div><h3 id=_parsing class=discrete>Parsing</h3><div class=listingblock><div class=title><code>lexy/parse.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>T</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>ErrorCallback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>parse_result</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>using</span> <span class=tok-n>value_type</span>     <span class=tok-o>=</span> <span class=tok-n>T</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>error_callback</span> <span class=tok-o>=</span> <span class=tok-n>ErrorCallback</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>error_type</span>     <span class=tok-o>=</span> <span class=tok-cm>/* return type of the sink */</span><span class=tok-p>;</span>

        <span class=tok-c1>//=== status ===//</span>
        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-k>operator</span> <span class=tok-kt>bool</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span>
        <span class=tok-p>{</span>
            <span class=tok-k>return</span> <span class=tok-nf>is_success</span><span class=tok-p>();</span>
        <span class=tok-p>}</span>

        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_success</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_recovered_error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(3)</b>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_fatal_error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(4)</b>

        <span class=tok-c1>//=== value ===//</span>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>has_value</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(5)</b>

        <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-n>T</span><span class=tok-o>&amp;</span> <span class=tok-n>value</span><span class=tok-p>()</span> <span class=tok-k>const</span><span class=tok-o>&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>T</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>value</span><span class=tok-p>()</span> <span class=tok-o>&amp;&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-c1>//=== error ===//</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>error_count</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-n>error_type</span><span class=tok-o>&amp;</span> <span class=tok-n>errors</span><span class=tok-p>()</span> <span class=tok-k>const</span><span class=tok-o>&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>error_type</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>errors</span><span class=tok-p>()</span> <span class=tok-o>&amp;&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>ErrorCallback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>parse</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>,</span> <span class=tok-n>ErrorCallback</span> <span class=tok-n>error_callback</span><span class=tok-p>)</span>
        <span class=tok-o>-&gt;</span> <span class=tok-n>parse_result</span><span class=tok-o>&lt;</span><span class=tok-cm>/* see below */</span><span class=tok-p>,</span> <span class=tok-n>ErrorCallback</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>State</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>ErrorCallback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>parse</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>,</span> <span class=tok-k>const</span> <span class=tok-n>State</span><span class=tok-o>&amp;</span> <span class=tok-n>state</span><span class=tok-p>,</span> <span class=tok-n>ErrorCallback</span> <span class=tok-n>error_callback</span><span class=tok-p>)</span>
        <span class=tok-o>-&gt;</span> <span class=tok-n>parse_result</span><span class=tok-o>&lt;</span><span class=tok-cm>/* see below */</span><span class=tok-p>,</span> <span class=tok-n>ErrorCallback</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns <code>true</code> if no error occurred during parsing.</p></li><li><p>Returns <code>true</code> if at least one error occurred during parsing.</p></li><li><p>Returns <code>true</code> if at least one error occurred during parsing, but parsing could recover after all of them.</p></li><li><p>Returns <code>true</code> if at least one error occurred during parsing and parsing had to cancel.</p></li><li><p>Returns <code>true</code> if parsing could produce a value. This can only happen if there was no fatal error.</p></li></ol></div><div class=paragraph><p>The function <code>lexy::parse()</code> parses the <code>Production</code> on the given <code>input</code>.
The return value is a <code>lexy::parse_result&lt;T, ErrorCallback></code>, where <code>T</code> is the return type of the <code>Production::value</code> or <code>Production::list</code> callback.
If the production accepts the input or there are only recoverable errors, invokes <code>Production::value</code> (see below) with the produced values and returns their result.
Invokes the error callback for each parse error (see <a href=#_error_handling>Error handling</a>) and collects the errors.</p></div><div class=paragraph><p>The return value on success is determined using <code>Production::value</code> depending on three cases:</p></div><div class=ulist><ul><li><p><code>Production::rule</code> does not contain a list. Then all arguments will be forwarded to <code>Production::value</code> as a callback whose result is returned.</p></li><li><p><code>Production::rule</code> contains a list and no other rule produces a value. Then <code>Production::value</code> will be used as sink for the list values.
If <code>Production::value</code> is also a callback that accepts the result of the sink as argument,
it will be invoked with the sink result and the processed result returned.
Otherwise, the result of the sink is the final result.</p></li><li><p><code>Production::rule</code> contains a list and other rules produce values as well.
Then <code>Production::value</code> will be used as sink for the list values.
The sink result will be added to the other values in order and everything forwarded to <code>Production::value</code> as a callback.
The callback result is then returned.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The callback <code>operator>></code> is useful for case 3 to create a combined callback and sink with the desired behavior.</td></tr></tbody></table></div><div class=paragraph><p>The second overload of <code>lexy::parse()</code> allows passing an arbitrary state argument.
This state will be made available to <code>lexy::parse_state</code> (see <a href="#Binding arguments">[Binding arguments]</a>) and passed to the <code>.sink()</code> of <code>Production::value</code>, if it accepts it.
That way, you can access other information (e.g. allocators for your containers) in the callbacks.</p></div><div class=sect2><h3 id=_callbacks>Callbacks</h3><div class=paragraph><p>This documentation has been moved <a href=/reference/callback/>here</a>.</p></div></div><div class=sect2><h3 id=_error_handling>Error handling</h3><div class=paragraph><p>Parsing errors are reported by constructing a <code>lexy::error</code> object and passing it to the error callback of <code>lexy::parse</code> and <code>lexy::validate</code> together with the <code>lexy::error_context</code>.
The error callback must either be a sink, in which case it can return an arbitrary type that represents a collection of all the errors,
or is a non-sink callback that returns <code>void</code>, in which case it will be passed to <code>lexy::collect()</code> to turn it into a sink.</p></div><div class=paragraph><p>The <code>error_type</code> of <code>lexy::validate_result</code> and <code>lexy::parse_result</code> will be the return type of the sink.
For a <code>void</code> returning non-sink callback it will be <code>std::size_t</code>, which is the result of <code>lexy::collect()</code>.</p></div><details><summary class=title>Example</summary><div class=content><div class=listingblock><div class=title>A <code>void</code>-returning error callback that is not a sink.</div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>ErrorCallbackVoid</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>using</span> <span class=tok-n>return_type</span> <span class=tok-o>=</span> <span class=tok-kt>void</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-o>&gt;</span>
    <span class=tok-kt>void</span> <span class=tok-k>operator</span><span class=tok-p>()(</span><span class=tok-k>const</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>error_context</span><span class=tok-o>&lt;</span><span class=tok-n>Production</span><span class=tok-p>,</span> <span class=tok-n>Input</span><span class=tok-o>&gt;&amp;</span> <span class=tok-n>context</span><span class=tok-p>,</span>
                           <span class=tok-k>const</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>error</span><span class=tok-o>&lt;</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>Tag</span><span class=tok-o>&gt;&amp;</span> <span class=tok-n>error</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=listingblock><div class=title>A non-<code>void</code>-returning error callback that is a sink.</div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>ErrorCallbackSink</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>class</span> <span class=tok-nc>Sink</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>using</span> <span class=tok-n>return_type</span> <span class=tok-o>=</span> <span class=tok-cm>/* ... */</span><span class=tok-p>;</span>

        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-o>&gt;</span>
        <span class=tok-kt>void</span> <span class=tok-k>operator</span><span class=tok-p>()(</span><span class=tok-k>const</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>error_context</span><span class=tok-o>&lt;</span><span class=tok-n>Production</span><span class=tok-p>,</span> <span class=tok-n>Input</span><span class=tok-o>&gt;&amp;</span> <span class=tok-n>context</span><span class=tok-p>,</span>
                               <span class=tok-k>const</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>error</span><span class=tok-o>&lt;</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>Tag</span><span class=tok-o>&gt;&amp;</span> <span class=tok-n>error</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>

        <span class=tok-n>return_type</span> <span class=tok-nf>finish</span><span class=tok-p>()</span> <span class=tok-o>&amp;&amp;</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-n>Sink</span> <span class=tok-nf>sink</span><span class=tok-p>();</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>Of course, overloading can be used to differentiate between various error types and contexts.</p></div></div></details><div class=sect3><h4 id=_error_types>Error types</h4><div class=listingblock><div class=title><code>lexy/error.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-p>;</span>

    <span class=tok-k>struct</span> <span class=tok-nc>expected_literal</span> <span class=tok-p>{};</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>expected_literal</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>

    <span class=tok-k>struct</span> <span class=tok-nc>expected_keyword</span> <span class=tok-p>{};</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>expected_keyword</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>

    <span class=tok-k>struct</span> <span class=tok-nc>expected_char_class</span> <span class=tok-p>{};</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>expected_char_class</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-o>&gt;</span>
    <span class=tok-k>using</span> <span class=tok-n>error_for</span> <span class=tok-o>=</span> <span class=tok-n>error</span><span class=tok-o>&lt;</span><span class=tok-n>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>Tag</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-p>...</span> <span class=tok-n>Args</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>make_error</span><span class=tok-p>(</span><span class=tok-n>Args</span><span class=tok-o>&amp;&amp;</span><span class=tok-p>...</span> <span class=tok-n>args</span><span class=tok-p>);</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>All errors are represented by instantiations of <code>lexy::error&lt;Reader, Tag></code>.
The <code>Tag</code> is an empty type that specifies the kind of error.
There are specializations for two tags to store additional information.</p></div><div class=paragraph><p>The function <code>lexy::make_error</code> constructs an error object given the reader and tag by forwarding all the arguments.</p></div><div class=sect4><h5 id=_generic_error>Generic error</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>error</span>
<span class=tok-p>{</span>
    <span class=tok-k>using</span> <span class=tok-n>iterator</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span><span class=tok-p>;</span>

<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>error</span><span class=tok-p>(</span><span class=tok-n>iterator</span> <span class=tok-n>pos</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>error</span><span class=tok-p>(</span><span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>message</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>The primary class template <code>lexy::error&lt;Reader, Tag></code> represents a generic error without additional metadata.
It can either be constructed giving it a single position, then <code>position() == begin() == end()</code>;
or a range of the input, then <code>position() == begin() ⇐ end()</code>.</p></div><div class=paragraph><p>The <code>message()</code> is determined using the <code>Tag</code>.
By default, it returns the type name of <code>Tag</code> after removing the top-level namespace name.
This can be overridden by defining either <code>Tag::name()</code> or <code>Tag::name</code>.</p></div></div><div class=sect4><h5 id=_expected_literal_error>Expected literal error</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>struct</span> <span class=tok-nc>expected_literal</span>
<span class=tok-p>{};</span>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>expected_literal</span><span class=tok-o>&gt;</span>
<span class=tok-p>{</span>
    <span class=tok-k>using</span> <span class=tok-n>iterator</span>    <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span><span class=tok-p>;</span>

<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>error</span><span class=tok-p>(</span><span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>,</span>
                             <span class=tok-k>const</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-o>*</span> <span class=tok-n>string</span><span class=tok-p>,</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>index</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>string</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span> <span class=tok-o>-&gt;</span> <span class=tok-k>const</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-o>*</span><span class=tok-p>;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>character</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span> <span class=tok-o>-&gt;</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>index</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>A specialization of <code>lexy::error</code> is provided if <code>Tag == lexy::expected_literal</code>.
It represents the error where a literal string was expected, but could not be matched.
It is mainly raised by the <code>lexy::dsl::lit</code> rule.</p></div><div class=paragraph><p>The error happens at a given <code>position()</code> and with a given <code>string()</code>.
The <code>index()</code> is the index into the string where matching failed; e.g. <code>0</code> if the input starts with a different character, <code>2</code> if the first two characters matched, etc.
The <code>character()</code> is the string character at that index.</p></div></div><div class=sect4><h5 id=_expected_keyword_error>Expected keyword error</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>struct</span> <span class=tok-nc>expected_keyword</span>
<span class=tok-p>{};</span>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>expected_keyword</span><span class=tok-o>&gt;</span>
<span class=tok-p>{</span>
    <span class=tok-k>using</span> <span class=tok-n>iterator</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span><span class=tok-p>;</span>

<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>error</span><span class=tok-p>(</span><span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>,</span>
                             <span class=tok-k>const</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-o>*</span> <span class=tok-n>str</span><span class=tok-p>);</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>string</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span> <span class=tok-o>-&gt;</span> <span class=tok-k>const</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-o>*</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>A specialization of <code>lexy::error</code> is provided if <code>Tag == lexy::expected_keyword</code>.
It represents the error where a keyword was expected, but could not be matched.
It is raised by the <code>lexy::dsl::keyword</code> rule.</p></div><div class=paragraph><p>The error happens at a given <code>position()</code> and with a given <code>string()</code>, which is the text of the keyword.
<code>begin()</code> and <code>end()</code> span the entire range of the identifier, which should have been <code>string()</code> but wasn’t.</p></div></div><div class=sect4><h5 id=_character_class_error>Character class error</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>struct</span> <span class=tok-nc>expected_char_class</span>
<span class=tok-p>{};</span>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>expected_char_class</span><span class=tok-o>&gt;</span>
<span class=tok-p>{</span>
    <span class=tok-k>using</span> <span class=tok-n>iterator</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span><span class=tok-p>;</span>

<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>error</span><span class=tok-p>(</span><span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>,</span> <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>name</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>name</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>A specialization of <code>lexy::error</code> is provided if <code>Tag == lexy::expected_char_class</code>.
It represents the error where any character from a given set of characters was expected, but could not be matched.
It is raised by the <code>lexy::dsl::ascii::*</code> rules or <code>lexy::dsl::newline</code>, among others.</p></div><div class=paragraph><p>The error happens at the given <code>position()</code> and a symbolic name of the character class is returned by <code>name()</code>.
By convention, the name format used is <code>&lt;group>.&lt;name></code> or <code>&lt;name></code>, where both <code>&lt;group></code> and <code>&lt;name></code> consist of characters.
Examples include <code>newline</code>, <code>ASCII.alnum</code> and <code>digit.decimal</code>.</p></div></div></div><div class=sect3><h4 id=_error_context>Error context</h4><div class=listingblock><div class=title><code>lexy/error.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>error_context</span>
    <span class=tok-p>{</span>
        <span class=tok-k>using</span> <span class=tok-n>iterator</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;::</span><span class=tok-n>iterator</span><span class=tok-p>;</span>

    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>error_context</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>,</span> <span class=tok-n>iterator</span> <span class=tok-n>pos</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>static</span> <span class=tok-k>consteval</span> <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>production</span><span class=tok-p>();</span>

        <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The class <code>lexy::error_context&lt;Production, Input></code> contain information about the context where the error occurred.</p></div><div class=paragraph><p>The entire input containing the error is returned by <code>input()</code>.</p></div><div class=paragraph><p>The <code>Production</code> whose rule has raised the error is specified as template parameter and its name returned by <code>production()</code>.
Like <code>lexy::error&lt;Reader, Tag>::message()</code>, it returns the name of the type without the top level namespace name.
This can be overridden by defining <code>Production::name()</code> or <code>Production::name</code>.</p></div><div class=paragraph><p>The <code>position()</code> of the error context is the input position where the production started parsing.</p></div></div></div><div class=sect2><h3 id=_parse_tree>Parse Tree</h3><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>enum</span> <span class=tok-k>class</span> <span class=tok-nc>traverse_event</span>
    <span class=tok-p>{</span>
        <span class=tok-n>enter</span><span class=tok-p>,</span>
        <span class=tok-n>exit</span><span class=tok-p>,</span>
        <span class=tok-n>leaf</span><span class=tok-p>,</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span> <span class=tok-o>=</span> <span class=tok-kt>void</span><span class=tok-p>,</span>
              <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default */</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>parse_tree</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>class</span> <span class=tok-nc>builder</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-nf>parse_tree</span><span class=tok-p>();</span>
        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>parse_tree</span><span class=tok-p>(</span><span class=tok-n>MemoryResource</span><span class=tok-o>*</span> <span class=tok-n>resource</span><span class=tok-p>);</span>

        <span class=tok-kt>bool</span> <span class=tok-nf>empty</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-kt>void</span> <span class=tok-nf>clear</span><span class=tok-p>()</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>class</span> <span class=tok-nc>node</span><span class=tok-p>;</span>
        <span class=tok-k>class</span> <span class=tok-nc>node_kind</span><span class=tok-p>;</span>

        <span class=tok-n>node</span> <span class=tok-nf>root</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> <span class=tok-c1>// requires: !empty()</span>

        <span class=tok-k>class</span> <span class=tok-nc>traverse_range</span><span class=tok-p>;</span>

        <span class=tok-n>traverse_range</span> <span class=tok-nf>traverse</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>node</span><span class=tok-o>&amp;</span> <span class=tok-n>n</span><span class=tok-p>)</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-n>traverse_range</span> <span class=tok-nf>traverse</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span> <span class=tok-o>=</span> <span class=tok-kt>void</span><span class=tok-p>,</span>
              <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default */</span><span class=tok-o>&gt;</span>
    <span class=tok-k>using</span> <span class=tok-n>parse_tree_for</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>parse_tree</span><span class=tok-o>&lt;</span><span class=tok-n>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span>
              <span class=tok-k>typename</span> <span class=tok-nc>ErrorCallback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>auto</span> <span class=tok-n>parse_as_tree</span><span class=tok-p>(</span><span class=tok-n>parse_tree</span><span class=tok-o>&lt;</span><span class=tok-n>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;&amp;</span> <span class=tok-n>tree</span><span class=tok-p>,</span>
                       <span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>,</span> <span class=tok-n>ErrorCallback</span> <span class=tok-n>error_callback</span><span class=tok-p>)</span>
      <span class=tok-o>-&gt;</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>validate_result</span><span class=tok-o>&lt;</span><span class=tok-n>ErrorCallback</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The class <code>lexy::parse_tree</code> represents a lossless untyped syntax tree.</p></div><div class=paragraph><p>The function <code>lexy::parse_as_tree()</code> parses a <code>Production</code> on the given <code>input</code> and constructs a lossless parse tree from the result.
All parse errors are passed to the error callback (see <a href=#_error_handling>Error handling</a>) and later returned.
If a non-recoverable parse error happens, the tree will be cleared, otherwise it contains the (partial) parse tree of the input.
It will discard any values produced by parsing the rules.</p></div><div class=paragraph><p>The resulting parse tree will contain a parent node for each production, and leaf node for every token.
If a token is empty and has an unknown token kind, it will not be added to the parse tree.
If a production inherits from <code>lexy::transparent_production</code>, no separate node will be created;
instead all child nodes will be added to its parent.
If a production inherits from <code>lexy::token_production</code>, tokens are merged when possible:
if there are two or more tokens with the same kind directly after each other, only a single node spanning all of them will be added,
as opposed to multiple nodes for each individual token.</p></div><div class=paragraph><p>Traversing the tree and concatenating the lexemes of all tokens will result in the original input.</p></div><div class=sect3><h4 id=_manual_tree_building>Manual Tree Building</h4><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>parse_tree</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;::</span><span class=tok-n>builder</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-k>explicit</span> <span class=tok-n>builder</span><span class=tok-p>(</span><span class=tok-n>parse_tree</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>tree</span><span class=tok-p>,</span> <span class=tok-n>Production</span> <span class=tok-n>production</span><span class=tok-p>);</span> // <b class=conum>(1)</b>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-k>explicit</span> <span class=tok-n>builder</span><span class=tok-p>(</span><span class=tok-n>Production</span> <span class=tok-n>production</span><span class=tok-p>);</span> // <b class=conum>(2)</b>

    <span class=tok-k>struct</span> <span class=tok-nc>production_state</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-n>production_state</span> <span class=tok-n>start_production</span><span class=tok-p>(</span><span class=tok-n>Production</span> <span class=tok-n>production</span><span class=tok-p>);</span> // <b class=conum>(3)</b>

    <span class=tok-kt>void</span> <span class=tok-nf>token</span><span class=tok-p>(</span><span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>kind</span><span class=tok-p>,</span>
               <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>);</span> // <b class=conum>(4)</b>

    <span class=tok-kt>void</span> <span class=tok-nf>finish_production</span><span class=tok-p>(</span><span class=tok-n>production_state</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>s</span><span class=tok-p>);</span> // <b class=conum>(5)</b>
    <span class=tok-kt>void</span> <span class=tok-nf>backtrack_production</span><span class=tok-p>(</span><span class=tok-n>production_state</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>s</span><span class=tok-p>);</span> // <b class=conum>(6)</b>

    <span class=tok-n>parse_tree</span> <span class=tok-nf>finish</span><span class=tok-p>()</span> <span class=tok-o>&amp;&amp;</span><span class=tok-p>;</span> // <b class=conum>(7)</b>
<span class=tok-p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Create a builder that will re-use the memory of the existing <code>tree</code>.
Its root node will be associated with the given <code>Production</code>.</p></li><li><p>Same as above, but does not re-use memory.</p></li><li><p>Adds a production child node as last child of the current node and activates it.
Returns a handle that remembers the previous current node.</p></li><li><p>Adds a token node to the current node.</p></li><li><p>Finishes with a child production and activates its parent.</p></li><li><p>Cancels the currently activated node, by deallocating it and all children.
Activates its parent node again.</p></li><li><p>Returns the finished tree.</p></li></ol></div></div><div class=sect3><h4 id=_tree_node>Tree Node</h4><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>parse_tree</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;::</span><span class=tok-n>node_kind</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-kt>bool</span> <span class=tok-n>is_token</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-kt>bool</span> <span class=tok-nf>is_production</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-kt>bool</span> <span class=tok-nf>is_root</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-kt>bool</span> <span class=tok-nf>is_token_production</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>name</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>node_kind</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>node_kind</span> <span class=tok-n>rhs</span><span class=tok-p>);</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>node_kind</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>node_kind</span> <span class=tok-n>rhs</span><span class=tok-p>);</span>

    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>,</span> <span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>tk</span><span class=tok-p>);</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>tk</span><span class=tok-p>,</span> <span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>);</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>,</span> <span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>tk</span><span class=tok-p>);</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>tk</span><span class=tok-p>,</span> <span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>);</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>,</span> <span class=tok-n>Production</span><span class=tok-p>);</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>Production</span> <span class=tok-n>p</span><span class=tok-p>,</span> <span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>);</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>,</span> <span class=tok-n>Production</span> <span class=tok-n>p</span><span class=tok-p>);</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>Production</span> <span class=tok-n>p</span><span class=tok-p>,</span> <span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>);</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>The class <code>node_kind</code> stores information over the kind of node.
Nodes are either associated with a <code>Production</code> or a token rule.
The root node is always a <code>Production</code> node.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>parse_tree</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;::</span><span class=tok-n>node</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-kt>void</span><span class=tok-o>*</span> <span class=tok-n>address</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-n>node_kind</span> <span class=tok-nf>kind</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-n>node</span> <span class=tok-nf>parent</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-cm>/* sized range */</span> <span class=tok-n>children</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-cm>/* range */</span> <span class=tok-n>siblings</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-kt>bool</span> <span class=tok-nf>is_last_child</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>lexeme</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-o>&gt;</span> <span class=tok-n>lexeme</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>token</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>token</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>node</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>node</span> <span class=tok-n>rhs</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>node</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>node</span> <span class=tok-n>rhs</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>The class <code>node</code> is a reference to a node in the tree.
Two nodes are equal if and only if they point to the same node in the same tree.</p></div><div class=sect4><h5 id=_parent_access>Parent Access</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-n>node</span> <span class=tok-nf>parent</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span></code></pre></div></div><div class=paragraph><p>Returns a reference to a parent node.
For the root node, returns a reference to itself.</p></div><div class=paragraph><p>This operation is <code>O(number of siblings)</code>.</p></div></div><div class=sect4><h5 id=_child_access>Child Access</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>children_range</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>class</span> <span class=tok-nc>iterator</span><span class=tok-p>;</span> <span class=tok-c1>// value_type = node</span>
    <span class=tok-k>class</span> <span class=tok-nc>sentinel</span><span class=tok-p>;</span>

    <span class=tok-n>iterator</span> <span class=tok-nf>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-n>sentinel</span> <span class=tok-nf>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-kt>bool</span> <span class=tok-nf>empty</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>size</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span>

<span class=tok-n>children_range</span> <span class=tok-nf>children</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span></code></pre></div></div><div class=paragraph><p>Returns a range object that iterates over all children of the node.
For a token node, this is always the empty range.</p></div></div><div class=sect4><h5 id=_sibling_access>Sibling Access</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>sibling_range</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>class</span> <span class=tok-nc>iterator</span><span class=tok-p>;</span> <span class=tok-c1>// value_type = node</span>

    <span class=tok-n>iterator</span> <span class=tok-nf>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-n>iterator</span> <span class=tok-nf>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-kt>bool</span> <span class=tok-nf>empty</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span>

<span class=tok-n>sibling_range</span> <span class=tok-nf>siblings</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span></code></pre></div></div><div class=paragraph><p>Returns a range object that iterates over all siblings of a node.
It begins with the sibling that is immediately following the node,
and continues until it reached the last child of the parent.
Then iteration wraps around to the first child of the parent until it ends at the original node.
The original node is not included in the sibling range.</p></div></div><div class=sect4><h5 id=_token_access>Token Access</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>lexeme</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-o>&gt;</span> <span class=tok-n>lexeme</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
<span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>token</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>token</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns the spelling of a token node. For a production node, returns the empty lexeme.</p></li><li><p>Returns the spelling and token kind of a token node; must not be called on a production node.</p></li></ol></div></div></div><div class=sect3><h4 id=_tree_traversal>Tree Traversal</h4><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>enum</span> <span class=tok-k>class</span> <span class=tok-nc>traverse_event</span>
<span class=tok-p>{</span>
    <span class=tok-n>enter</span><span class=tok-p>,</span>
    <span class=tok-n>exit</span><span class=tok-p>,</span>
    <span class=tok-n>leaf</span><span class=tok-p>,</span>
<span class=tok-p>};</span></code></pre></div></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>traverse_range</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>class</span> <span class=tok-nc>iterator</span><span class=tok-p>;</span> <span class=tok-c1>// value_type = { traverse_event, node }</span>

    <span class=tok-n>iterator</span> <span class=tok-nf>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-n>iterator</span> <span class=tok-nf>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-kt>bool</span> <span class=tok-nf>empty</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span>

<span class=tok-n>traverse_range</span> <span class=tok-nf>traverse</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>node</span><span class=tok-o>&amp;</span> <span class=tok-n>n</span><span class=tok-p>)</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
<span class=tok-n>traverse_range</span> <span class=tok-nf>traverse</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns a range that traverses descendants of the given node.</p></li><li><p>Returns a range that traverses the root node, or an empty range if the tree is empty.</p></li></ol></div><div class=paragraph><p>The <code>traverse_range</code> iterates over a node and all its children and their children and so on.
Its value type is a (unspecified) pair whose first member is a <code>lexy::traverse_event</code> and whose second member is a <code>node</code> reference.</p></div><div class=paragraph><p>For a token node, the range contains only the original node with event <code>leaf</code>.</p></div><div class=paragraph><p>For a production node, the range begins with the original node and event <code>enter</code>.
It then does an in-order traversal of all descendants, beginning with the children of a node.
When it reaches a token node, produces it with event <code>leaf</code>.
When it reaches a production node, produces it with event <code>enter</code>, then all its descendants recursively, and then with event <code>exit</code>.
After all descendants of the original node have been produced, finishes with the original node again and event <code>exit</code>.</p></div><details><summary class=title>Example</summary><div class=content><div class=paragraph><p>Prints a tree.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>auto</span> <span class=tok-n>depth</span> <span class=tok-o>=</span> <span class=tok-mi>0</span><span class=tok-p>;</span>
<span class=tok-k>for</span> <span class=tok-p>(</span><span class=tok-k>auto</span> <span class=tok-p>[</span><span class=tok-n>event</span><span class=tok-p>,</span> <span class=tok-n>node</span><span class=tok-p>]</span> <span class=tok-o>:</span> <span class=tok-n>tree</span><span class=tok-p>.</span><span class=tok-n>traverse</span><span class=tok-p>())</span>
<span class=tok-p>{</span>
    <span class=tok-k>switch</span> <span class=tok-p>(</span><span class=tok-n>event</span><span class=tok-p>)</span>
    <span class=tok-p>{</span>
    <span class=tok-k>case</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>traverse_event</span><span class=tok-o>::</span><span class=tok-nl>enter</span><span class=tok-p>:</span>
        <span class=tok-o>++</span><span class=tok-n>depth</span><span class=tok-p>;</span>
        <span class=tok-n>indent</span><span class=tok-p>(</span><span class=tok-n>depth</span><span class=tok-p>);</span>
        <span class=tok-n>print_node</span><span class=tok-p>(</span><span class=tok-n>node</span><span class=tok-p>);</span>
        <span class=tok-k>break</span><span class=tok-p>;</span>
    <span class=tok-k>case</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>traverse_event</span><span class=tok-o>::</span><span class=tok-nl>exit</span><span class=tok-p>:</span>
        <span class=tok-o>--</span><span class=tok-n>depth</span><span class=tok-p>;</span>
        <span class=tok-k>break</span><span class=tok-p>;</span>

    <span class=tok-k>case</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>traverse_event</span><span class=tok-o>::</span><span class=tok-nl>leaf</span><span class=tok-p>:</span>
        <span class=tok-n>indent</span><span class=tok-p>(</span><span class=tok-n>depth</span><span class=tok-p>);</span>
        <span class=tok-n>print_node</span><span class=tok-p>(</span><span class=tok-n>node</span><span class=tok-p>);</span>
        <span class=tok-k>break</span><span class=tok-p>;</span>
    <span class=tok-p>}</span>
<span class=tok-p>}</span></code></pre></div></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>Traversing a node just does pointer chasing.
There is no allocation or recursion involved.</td></tr></tbody></table></div></div></div></div></div><div class=sect1><h2 id=_the_rule_dsl>The rule DSL</h2><div class=sectionbody><div class=paragraph><p>This documentation has been moved <a href=/reference/dsl/>here</a>.</p></div></div></div><div class=sect1><h2 id=_glossary>Glossary</h2><div class=sectionbody><div class="dlist glossary"><dl><dt>Branch</dt><dd><p>A rule that has an associated condition and will only be taken if the condition matches.
It is used to make decisions in the parsing algorithm.</p></dd><dt>Callback</dt><dd><p>A function object with a <code>return_type</code> member typedef.</p></dd><dt>Encoding</dt><dd><p>Set of pre-defined classes that define the text encoding of the input.</p></dd><dt>Error Callback</dt><dd><p>The callback used to report errors.</p></dd><dt>Grammar</dt><dd><p>An entry production and all productions referenced by it.</p></dd><dt>Input</dt><dd><p>Defines the input that will be parsed.</p></dd><dt>Production</dt><dd><p>Building-block of a grammar consisting of a rule and an optional callback that produces the parsed value.</p></dd><dt>Rule</dt><dd><p>Matches a specific input and then produces a value or an error.</p></dd><dt>Sink</dt><dd><p>A type with a <code>sink()</code> method that then returns a function object that can be called multiple times.</p></dd><dt>Token</dt><dd><p>A rule that is an atomic building block of the input.</p></dd></dl></div></div></div></article></main><footer id=page-footer><section class=copyright>&copy; <a target=_blank href=https://github.com/foonathan/lexy/blob/main/LICENSE title=License>2020-2021</a></section><section class=patreon><a target=_blank href=https://jonathanmueller.dev/support-me/>Support me!</a></section><section class=poweredby>Made with <a target=_blank href=https://gohugo.io>Hugo</a> and <a target=_blank href=https://fontawesome.com/license>Font Awesome</a>.</section></footer></body></html>