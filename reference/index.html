<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Reference — lexy</title><style>:root{--white:white;--header-white:rgba(255, 255, 255, .75);--background-color:#fdfdfd;--default-color:#101010;--heading-color:#0A0A0A;--link-color:#2A2A2A;--gray-highlight-color:#aaaaaa;--highlight-color:#2861ce}@media(prefers-color-scheme:dark){:root{--white:#020202;--header-white:rgba(2, 2, 2, .75);--background-color:#222222;--default-color:#efefef;--heading-color:#f5f5f5;--link-color:#d5d5d5;--gray-highlight-color:#555555}}nav#menu div.menu-container,main{max-width:1200px;margin:0 auto;padding:0 10px}@media(min-width:800px){article{max-width:900px;margin:0 auto;padding:0 10px}}html{position:relative;min-height:100%;margin:0;padding:0}body{font-family:serif;font-size:18px;color:var(--default-color);background-color:var(--background-color);width:100%;padding:0;margin:0}main{margin-bottom:75px}h1,h2,h3,h4,h5,h6{font-family:sans-serif;font-weight:700;line-height:1.15em;color:var(--heading-color);margin:0 0 .4em;hyphens:auto}h1{font-size:2em}h2{font-size:1.75em}h3{font-size:1.5em}h4{font-size:1.25em}h5{font-size:1.15em}h6{font-size:1.1em}a,a svg,button svg{color:var(--link-color);transition:color ease .3s}a:hover,a svg:hover,button svg:hover{color:var(--highlight-color)}a:focus,a svg:focus,button svg:focus{outline:none}br{margin:1em}article p,article ul,article ol,article dl,article td{hyphens:auto;text-align:justify}nav#menu{width:100%;padding:0;background-color:var(--white);border-bottom:2px solid var(--highlight-color);font-family:sans-serif;font-size:1.3em}nav#menu div.menu-container{display:flex}nav#menu div.menu-container ul{display:flex;flex-direction:row;align-items:center;padding:0;list-style:none}nav#menu div.menu-container ul li a{text-decoration:none}nav#menu div.menu-container ul li a svg{height:1em}nav#menu div.menu-container ul li a.active{border-width:0 0 2px;border-style:solid;border-color:var(--highlight-color)}nav#menu div.menu-container ul#home{padding-left:0;padding-right:10px}nav#menu div.menu-container ul#home .title{font-weight:700}nav#menu div.menu-container ul#main{margin-left:auto}nav#menu div.menu-container ul#main li{padding-left:20px}@media(max-width:600px){nav#menu div.menu-container ul#main{flex-direction:column;align-items:flex-end;margin:5px 10px 0 auto}}footer#page-footer{position:absolute;bottom:0;left:0;right:0;height:2em;display:flex;justify-content:space-between;font-size:.8em;font-weight:200;line-height:1em;border-top:1px solid #ccc}footer#page-footer section{padding-left:1em;padding-right:1em;padding-top:.5em;width:100%}footer#page-footer .copyright{text-align:left}footer#page-footer .patreon{text-align:center}footer#page-footer .poweredby{text-align:right}@media(max-width:450px){footer#page-footer{flex-direction:column;align-items:flex-start}footer#page-footer section{text-align:initial!important;width:initial}}aside.toc{display:none}@media(min-width:1100px){aside.toc{display:initial;position:sticky;top:1em;float:left;width:300px}aside.toc header{font-weight:700}aside.toc ul{list-style:none;padding:0}aside.toc ul ul{padding-left:1em;padding-bottom:.5em}aside.toc a{text-decoration:none}aside.toc~article{padding-left:300px}}article header{margin-top:1em;margin-bottom:1em}article header nav{display:flex;flex-wrap:wrap}article header nav a{text-decoration:none;padding-right:7px}article header nav a svg{height:1em;position:relative;top:2px}@media(min-width:700px){article header nav form.search{margin-left:auto}}article header nav form.search input[type=search]{padding:2px;width:250px}article header nav form.search input[type=search]:focus{border-color:var(--highlight-color);outline:solid var(--highlight-color)1px}article header nav form.search button[type=submit]{margin-left:-25px;border:none;background:initial}article header nav form.search button[type=submit] svg{height:1em}article .lead p{font-weight:500;font-size:1.1em}article .admonitionblock{margin-bottom:1em}article .admonitionblock td.icon{width:75px;font-weight:700;border-right:1px solid var(--gray-highlight-color);padding:.5em}article .admonitionblock td.content{padding-left:.5em}article .admonitionblock td.content div:first-child p{margin-top:0}article .admonitionblock td.content div:last-child p{margin-bottom:0}article .exampleblock{margin-top:1em;margin-bottom:1em}article .exampleblock .title{font-style:italic}article a.github-example{text-decoration:none}article a.github-example svg{height:.8em;position:relative;top:2px}article .playground-example .title,article .godbolt-example .title{position:relative}article .playground-example .title a,article .godbolt-example .title a{position:absolute;top:7px;right:7px}article .playground-example .title a svg,article .godbolt-example .title a svg{height:1em}article details{padding-bottom:1em}article details summary{font-style:italic}article ul p,article ol p{margin:.2em}article dl dt{margin-top:.5em;font-weight:700}article dl dd p,article dl dd div:only-child ul{margin:0;padding:0}article table.tableblock{background:var(--white);margin:0 auto;border-collapse:collapse}article table.tableblock td,article table.tableblock th{border:1px solid var(--gray-highlight-color);padding:5px;text-align:left}article table.tableblock td p,article table.tableblock th p{margin:0}article div.sidebarblock{border:1px solid var(--gray-highlight-color);padding:.75em;margin:1em}article div.sidebarblock p{margin:0}article code{font-family:Inconsolata,monospace,sans-serif}article pre{margin:0;overflow:auto;padding:10px;background:var(--white);border:1px solid var(--gray-highlight-color);line-height:1.1}article .colist{margin-top:-.5em}article .colist ol{counter-reset:list}article .colist ol li{counter-increment:list;padding-left:1em}article .colist ol ::marker{content:"(" counter(list)")";font-weight:700}article .colist p{margin:0}.highlight .tok-c,.highlight .tok-cm,.highlight .tok-cp,.highlight .tok-c1,.highlight .tok-cs,.ace_editor .tok-c,.ace_editor .tok-cm,.ace_editor .tok-cp,.ace_editor .tok-c1,.ace_editor .tok-cs{color:#998;font-style:italic;font-weight:initial}.highlight .tok-k,.highlight .tok-kc,.highlight .tok-kd,.highlight .tok-kp,.highlight .tok-kr,.highlight .tok-kt,.highlight .ace_storage,.highlight .ace_keyword,.ace_editor .tok-k,.ace_editor .tok-kc,.ace_editor .tok-kd,.ace_editor .tok-kp,.ace_editor .tok-kr,.ace_editor .tok-kt,.ace_editor .ace_storage,.ace_editor .ace_keyword{color:#458;font-style:initial;font-weight:700}.highlight .tok-o,.highlight .tok-p,.highlight .ace_keyword.ace_operator,.highlight .ace_paren,.highlight .ace_punctuation,.ace_editor .tok-o,.ace_editor .tok-p,.ace_editor .ace_keyword.ace_operator,.ace_editor .ace_paren,.ace_editor .ace_punctuation{color:red;font-style:initial;font-weight:initial}.highlight .ace_dsl,.ace_editor .ace_dsl{text-decoration:underline;cursor:pointer;pointer-events:auto}.highlight .tok-m,.highlight .tok-mf,.highlight .tok-mh,.highlight .tok-mi,.highlight .tok-mo,.highlight .ace_constant,.ace_editor .tok-m,.ace_editor .tok-mf,.ace_editor .tok-mh,.ace_editor .tok-mi,.ace_editor .tok-mo,.ace_editor .ace_constant{color:#ff8000;font-style:initial;font-weight:initial}.highlight .tok-s,.highlight .tok-sb,.highlight .tok-sc,.highlight .tok-sd,.highlight .tok-s2,.highlight .tok-s3,.highlight .tok-sh,.highlight .tok-si,.highlight .tok-sx,.highlight .tok-sr,.highlight .tok-s1,.highlight .tok-ss,.highlight .tok-se,.highlight .ace_string,.ace_editor .tok-s,.ace_editor .tok-sb,.ace_editor .tok-sc,.ace_editor .tok-sd,.ace_editor .tok-s2,.ace_editor .tok-s3,.ace_editor .tok-sh,.ace_editor .tok-si,.ace_editor .tok-sx,.ace_editor .tok-sr,.ace_editor .tok-s1,.ace_editor .tok-ss,.ace_editor .tok-se,.ace_editor .ace_string{color:green;font-style:initial;font-weight:initial}.highlight .tok-cp,.ace_editor .tok-cp{color:green;font-style:initial;font-weight:700}.highlight .tok-err,.highlight .ace_invalid,.ace_editor .tok-err,.ace_editor .ace_invalid{color:red;font-style:initial;font-weight:initial}</style></head><body><nav id=menu><div class=menu-container><ul id=home><li><a href=/><span class=title>lexy:</span> C++ parser combinator library</a></li></ul><ul id=main><li><a href=/tutorial/>Tutorial</a></li><li><a class=active href=/reference/>Reference</a></li><li><a href=/reference/dsl/>DSL</a></li><li><a href=/playground/>Playground</a></li><li><a href=https://github.com/foonathan/lexy title=GitHub><svg aria-hidden="true" focusable="false" data-prefix="fab" data-icon="github" class="svg-inline--fa fa-github fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><path fill="currentcolor" d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6.0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6.0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3.0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1.0-6.2-.3-40.4-.3-61.4.0.0-70 15-84.7-29.8.0.0-11.4-29.1-27.8-36.6.0.0-22.9-15.7 1.6-15.4.0.0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5.0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9.0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4.0 33.7-.3 75.4-.3 83.6.0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6.0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9.0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></a></li></ul></div></nav><main><aside class=toc><header><a href=#>Table of Contents</a></header><nav id=TableOfContents><ul><li><a href=#_inputs_and_encodings>Inputs and Encodings</a><ul><li><a href=#_encodings>Encodings</a></li><li><a href=#_the_pre_defined_inputs>The pre-defined Inputs</a></li><li><a href=#_lexemes_and_tokens>Lexemes and Tokens</a></li><li><a href=#_writing_custom_inputs>Writing custom Inputs</a></li></ul></li><li><a href=#_matching_parsing_and_validating>Matching, parsing and validating</a><ul><li><a href=#_callbacks>Callbacks</a></li><li><a href=#_error_handling>Error handling</a></li><li><a href=#_parse_tree>Parse Tree</a></li></ul></li><li><a href=#_the_rule_dsl>The rule DSL</a></li><li><a href=#_glossary>Glossary</a></li></ul></nav></aside><article><div class=paragraph><p>This is the reference documentation for <code>lexy</code>.</p></div><div class=sidebarblock><div class=content><div class=paragraph><p>If anything in the documentation could be improved (and there is probably a lot),
please raise an issue or — even better — create a PR.
Thank you!</p></div></div></div><div class=sect1><h2 id=_inputs_and_encodings>Inputs and Encodings</h2><div class=sectionbody><div class=paragraph><p>An <code>Input</code> defines the input that will be parsed by <code>lexy</code>.
It has a corresponding <code>Encoding</code> that controls, among other things, its character type and whether certain rules are available.
The <code>Input</code> itself is unchanging and it produces a <code>Reader</code> which remembers the current position of the input during parsing.</p></div><div class=sect2><h3 id=_encodings>Encodings</h3><div class=listingblock><div class=title><code>lexy/encoding.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>struct</span> <span class=tok-nc>default_encoding</span><span class=tok-p>;</span>
    <span class=tok-k>struct</span> <span class=tok-nc>ascii_encoding</span><span class=tok-p>;</span>
    <span class=tok-k>struct</span> <span class=tok-nc>utf8_encoding</span><span class=tok-p>;</span>
    <span class=tok-k>struct</span> <span class=tok-nc>utf16_encoding</span><span class=tok-p>;</span>
    <span class=tok-k>struct</span> <span class=tok-nc>utf32_encoding</span><span class=tok-p>;</span>
    <span class=tok-k>struct</span> <span class=tok-nc>byte_encoding</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>CharT</span><span class=tok-o>&gt;</span>
    <span class=tok-k>using</span> <span class=tok-n>deduce_encoding</span> <span class=tok-o>=</span> <span class=tok-cm>/* see below */</span><span class=tok-p>;</span>

    <span class=tok-k>enum</span> <span class=tok-k>class</span> <span class=tok-nc>encoding_endianness</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>An <code>Encoding</code> is a set of pre-defined policy classes that determine the text encoding of an input.</p></div><div class=paragraph><p>Each encoding has a <em>primary character type</em>, which is the character type of the input.
It can also have a <em>secondary character type</em>, which the input should accept, but internally convert to the primary character type.
For example, <code>lexy::utf8_encoding’s primary character type is `char8_t</code>, but it also accepts <code>char</code>.</p></div><div class=paragraph><p>The encoding also has an <em>integer type</em>, which can store either any valid character (code unit to be precise) or a special EOF value, similar to <code>std::char_traits</code>.
For some encodings, the integer type can be the same as the character type as not all values are valid code units.
This allows optimizations.</p></div><div class=paragraph><p>Certain rules can require a certain encodings.
For example, <code>lexy::dsl::code_point</code> does not work with the <code>lexy::default_encoding</code>, and <code>lexy::dsl::encode</code> requires <code>lexy::byte_encoding</code>.</p></div><div class=sect3><h4 id=_the_supported_encodings>The supported encodings</h4><div class=dlist><dl><dt class=hdlist1><code>lexy::default_encoding</code></dt><dd><p>The encoding that will be used when no other encoding is specified.
Its character type is <code>char</code> and it can work with any 8-bit encoding (ASCII, UTF-8, extended ASCII etc.).
Only use this encoding if you don’t know the exact encoding of your input.</p></dd><dt class=hdlist1><code>lexy::ascii_encoding</code></dt><dd><p>Assumes the input is valid ASCII. Its character type is <code>char</code>.</p></dd><dt class=hdlist1><code>lexy::utf8_encoding</code></dt><dd><p>Assumes the input is valid UTF-8. Its character type is <code>char8_t</code>, but it also accepts <code>char</code>.</p></dd><dt class=hdlist1><code>lexy::utf16_encoding</code></dt><dd><p>Assumes the input is valid UTF-16. Its character type is <code>char16_t</code>, but it also accepts <code>wchar_t</code> on Windows.</p></dd><dt class=hdlist1><code>lexy::utf32_encoding</code></dt><dd><p>Assumes the input is valid UTF-32. Its character type is <code>char32_t</code>, but it also accepts <code>wchar_t</code> on Linux.</p></dd><dt class=hdlist1><code>lexy::byte_encoding</code></dt><dd><p>Does not assume the input is text. Its character type is <code>unsigned char</code>, but it also accepts <code>char</code> and <code>std::byte</code>.
Use this encoding if you’re not parsing text or if you’re parsing text consisting of multiple encodings.</p></dd></dl></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>If you specify an encoding that does not match the inputs actual encoding, e.g. you say it is UTF-8 but in reality it is some Windows code page, the library will handle it by generating parse errors.
The worst that can happen is that you’ll get an unexpected EOF error because the input contains the character that is used to signal EOF in the encoding.</td></tr></tbody></table></div></div><div class=sect3><h4 id=_deducing_encoding>Deducing encoding</h4><div class=paragraph><p>If you don’t specify an encoding for your input, <code>lexy</code> can sometimes deduce it by matching the character type to the primary character type.
For example, a string of <code>char8_t</code> will be deduce it to be <code>lexy::utf8_encoding</code>.
If the character type is <code>char</code>, <code>lexy</code> will deduce <code>lexy::default_encoding</code> (unless that has been overriden by a build option).</p></div></div><div class=sect3><h4 id=_encoding_endianness>Encoding endianness</h4><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>enum</span> <span class=tok-k>class</span> <span class=tok-nc>encoding_endianness</span>
<span class=tok-p>{</span>
    <span class=tok-n>little</span><span class=tok-p>,</span>
    <span class=tok-n>big</span><span class=tok-p>,</span>
    <span class=tok-n>bom</span><span class=tok-p>,</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>In-memory, UTF-16 and UTF-32 come in two flavors: big and little endian.
Which version is used, can be specified with the <code>encoding_endianness</code> enumeration.
This is only relevant when e.g. reading data from files.</p></div><div class=dlist><dl><dt class=hdlist1>little</dt><dd><p>The encoding is written using little endian.
For single-byte encodings, this has no effect.</p></dd><dt class=hdlist1>big</dt><dd><p>The encoding is written using big endian.
For single-byte encodings, this has no effect.</p></dd><dt class=hdlist1>bom</dt><dd><p>The endianness is determined using the byte-order mark (BOM) of the encoding.
If no BOM is present, defaults to big endian as per Unicode recommendation.
For UTF-8, this will skip the optional BOM, but has otherwise no effect.
For non-Unicode encodings, this has no effect.</p></dd></dl></div></div></div><div class=sect2><h3 id=_the_pre_defined_inputs>The pre-defined Inputs</h3><div class=sect3><h4 id=_range_input>Range input</h4><div class=listingblock><div class=title><code>lexy/input/range_input.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Iterator</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Sentinel</span> <span class=tok-o>=</span> <span class=tok-n>Iterator</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>range_input</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>using</span> <span class=tok-n>encoding</span>  <span class=tok-o>=</span> <span class=tok-n>Encoding</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>char_type</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>encoding</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>iterator</span>  <span class=tok-o>=</span> <span class=tok-n>Iterator</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-nf>range_input</span><span class=tok-p>()</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-nf>range_input</span><span class=tok-p>(</span><span class=tok-n>Iterator</span> <span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-n>Sentinel</span> <span class=tok-n>end</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-n>Reader</span> <span class=tok-n>reader</span><span class=tok-p>()</span> <span class=tok-k>const</span><span class=tok-o>&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The class <code>lexy::range_input</code> is an input that represents the range <code>[begin, end)</code>.
CTAD can be used to deduce the encoding from the value type of the iterator.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The input is a lightweight view and does not own any data.</td></tr></tbody></table></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use <code>lexy::string_input</code> instead if the range is contiguous.</td></tr></tbody></table></div><details><summary class=title>Example</summary><div class=content><div class=paragraph><p>Using the range input to parse content from a list.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>list</span><span class=tok-o>&lt;</span><span class=tok-kt>char8_t</span><span class=tok-o>&gt;</span> <span class=tok-n>list</span> <span class=tok-o>=</span> <span class=tok-err>…</span><span class=tok-p>;</span>

<span class=tok-c1>// Create the input, deducing the encoding.</span>
<span class=tok-k>auto</span> <span class=tok-n>input</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>range_input</span><span class=tok-p>(</span><span class=tok-n>list</span><span class=tok-p>.</span><span class=tok-n>begin</span><span class=tok-p>(),</span> <span class=tok-n>list</span><span class=tok-p>.</span><span class=tok-n>end</span><span class=tok-p>());</span></code></pre></div></div></div></details></div><div class=sect3><h4 id=_string_input>String input</h4><div class=listingblock><div class=title><code>lexy/input/string_input.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span> <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>string_input</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>using</span> <span class=tok-n>encoding</span>  <span class=tok-o>=</span> <span class=tok-n>Encoding</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>char_type</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>encoding</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>iterator</span>  <span class=tok-o>=</span> <span class=tok-k>const</span> <span class=tok-n>char_type</span><span class=tok-o>*</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-nf>string_input</span><span class=tok-p>()</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>CharT</span><span class=tok-o>&gt;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>string_input</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>end</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>CharT</span><span class=tok-o>&gt;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>string_input</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>data</span><span class=tok-p>,</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>size</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>View</span><span class=tok-o>&gt;</span>
        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>string_input</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>View</span><span class=tok-o>&amp;</span> <span class=tok-n>view</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-n>Reader</span> <span class=tok-n>reader</span><span class=tok-p>()</span> <span class=tok-k>const</span><span class=tok-o>&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>CharT</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>zstring_input</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>str</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>CharT</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>zstring_input</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>str</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span> <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-o>&gt;</span>
    <span class=tok-k>using</span> <span class=tok-n>string_lexeme</span> <span class=tok-o>=</span> <span class=tok-n>lexeme_for</span><span class=tok-o>&lt;</span><span class=tok-n>string_input</span><span class=tok-o>&lt;</span><span class=tok-n>Encoding</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>;</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Encoding</span> <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-o>&gt;</span>
    <span class=tok-k>using</span> <span class=tok-n>string_error</span> <span class=tok-o>=</span> <span class=tok-n>error_for</span><span class=tok-o>&lt;</span><span class=tok-n>string_input</span><span class=tok-o>&lt;</span><span class=tok-n>Encoding</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>Tag</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Encoding</span> <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-o>&gt;</span>
    <span class=tok-k>using</span> <span class=tok-n>string_error_context</span> <span class=tok-o>=</span> <span class=tok-n>error_context</span><span class=tok-o>&lt;</span><span class=tok-n>Production</span><span class=tok-p>,</span> <span class=tok-n>string_input</span><span class=tok-o>&lt;</span><span class=tok-n>Encoding</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>;</span>
<span class=tok-p>}</span> <span class=tok-c1>// namespace lexy</span></code></pre></div></div><div class=paragraph><p>The class <code>lexy::string_input</code> is an input that represents the string view defined by the constructors.
CTAD can be used to deduce the encoding from the character type.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The input is a lightweight view and does not own any data.
Use <code>lexy::buffer</code> if you want an owning version.</td></tr></tbody></table></div><div class=sect4><h5 id=_pointer_constructor>Pointer constructor</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>CharT</span><span class=tok-o>&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-n>string_input</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>end</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>CharT</span><span class=tok-o>&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-n>string_input</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>data</span><span class=tok-p>,</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>size</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>The input is the contiguous range <code>[begin, end)</code>.</p></li><li><p>The input is the contiguous range <code>[data, data + size)</code>.</p></li></ol></div><div class=paragraph><p><code>CharT</code> must be the primary or secondary character type of the encoding.</p></div></div><div class=sect4><h5 id=_view_constructor>View constructor</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>View</span><span class=tok-o>&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>string_input</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>View</span><span class=tok-o>&amp;</span> <span class=tok-n>view</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span></code></pre></div></div><div class=paragraph><p>The input is given by the <code>View</code>, which requires a <code>.data()</code> and <code>.size()</code> member.
The character type of the <code>View</code> must be the primary or secondary character type of the encoding.</p></div></div><div class=sect4><h5 id=_null_terminated_string_functions>Null-terminated string functions</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>CharT</span><span class=tok-o>&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>zstring_input</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>str</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>CharT</span><span class=tok-o>&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>zstring_input</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>str</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Use the specified encoding.</p></li><li><p>Deduce the encoding from the character type.</p></li></ol></div><div class=paragraph><p>The input is given by the range <code>[str, end)</code>, where <code>end</code> is a pointer to the first null character of the string.
The return type is an appropriate <code>lexy::string_input</code> instantiation.</p></div><details><summary class=title>Example</summary><div class=content><div class=paragraph><p>Using the string input to parse content from a <code>std::string</code>.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>string</span> <span class=tok-n>str</span> <span class=tok-o>=</span> <span class=tok-err>…</span><span class=tok-p>;</span>
<span class=tok-k>auto</span> <span class=tok-n>input</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>string_input</span><span class=tok-p>(</span><span class=tok-n>str</span><span class=tok-p>);</span></code></pre></div></div><div class=paragraph><p>Using the string input to parse content from a string literal.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>auto</span> <span class=tok-n>input</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>zstring_input</span><span class=tok-p>(</span><span class=tok-sa>u</span><span class=tok-s>&#34;Hello World!&#34;</span><span class=tok-p>);</span></code></pre></div></div></div></details></div></div><div class=sect3><h4 id=_buffer_input>Buffer Input</h4><div class=listingblock><div class=title><code>lexy/input/buffer.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span>       <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-p>,</span>
          <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default resource */</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>buffer</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>using</span> <span class=tok-n>encoding</span>  <span class=tok-o>=</span> <span class=tok-n>Encoding</span><span class=tok-p>;</span>
    <span class=tok-k>using</span> <span class=tok-n>char_type</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>encoding</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-p>;</span>

    <span class=tok-k>class</span> <span class=tok-nc>builder</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-nf>buffer</span><span class=tok-p>()</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>buffer</span><span class=tok-p>(</span><span class=tok-n>MemoryResource</span><span class=tok-o>*</span> <span class=tok-n>resource</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>CharT</span><span class=tok-o>&gt;</span>
    <span class=tok-k>explicit</span> <span class=tok-n>buffer</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>data</span><span class=tok-p>,</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>size</span><span class=tok-p>,</span>
                    <span class=tok-n>MemoryResource</span><span class=tok-o>*</span> <span class=tok-n>resource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default resource */</span><span class=tok-p>);</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>CharT</span><span class=tok-o>&gt;</span>
    <span class=tok-k>explicit</span> <span class=tok-n>buffer</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-k>const</span> <span class=tok-n>CharT</span><span class=tok-o>*</span> <span class=tok-n>end</span><span class=tok-p>,</span>
                    <span class=tok-n>MemoryResource</span><span class=tok-o>*</span> <span class=tok-n>resource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default resource */</span><span class=tok-p>);</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>View</span><span class=tok-o>&gt;</span>
    <span class=tok-k>explicit</span> <span class=tok-n>buffer</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>View</span><span class=tok-o>&amp;</span>     <span class=tok-n>view</span><span class=tok-p>,</span>
                    <span class=tok-n>MemoryResource</span><span class=tok-o>*</span> <span class=tok-n>resource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default resource */</span><span class=tok-p>);</span>

    <span class=tok-n>buffer</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>buffer</span><span class=tok-o>&amp;</span> <span class=tok-n>other</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>*</span> <span class=tok-n>resource</span><span class=tok-p>);</span>

    <span class=tok-k>const</span> <span class=tok-n>char_type</span><span class=tok-o>*</span> <span class=tok-n>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>const</span> <span class=tok-n>char_type</span><span class=tok-o>*</span> <span class=tok-n>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>const</span> <span class=tok-n>char_type</span><span class=tok-o>*</span> <span class=tok-n>data</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-kt>bool</span> <span class=tok-nf>empty</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>size</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>length</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-n>Reader</span> <span class=tok-nf>reader</span><span class=tok-p>()</span> <span class=tok-k>const</span><span class=tok-o>&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span><span class=tok-p>,</span> <span class=tok-n>encoding_endianness</span> <span class=tok-n>Endianness</span><span class=tok-o>&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>make_buffer_from_raw</span><span class=tok-p>;</span>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span>       <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-p>,</span>
          <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default resource */</span><span class=tok-o>&gt;</span>
<span class=tok-k>using</span> <span class=tok-n>buffer_lexeme</span> <span class=tok-o>=</span> <span class=tok-n>lexeme_for</span><span class=tok-o>&lt;</span><span class=tok-n>buffer</span><span class=tok-o>&lt;</span><span class=tok-n>Encoding</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>;</span>
<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Encoding</span> <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-p>,</span>
          <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default resource */</span><span class=tok-o>&gt;</span>
<span class=tok-k>using</span> <span class=tok-n>buffer_error</span> <span class=tok-o>=</span> <span class=tok-n>error_for</span><span class=tok-o>&lt;</span><span class=tok-n>buffer</span><span class=tok-o>&lt;</span><span class=tok-n>Encoding</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>Tag</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Encoding</span> <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-p>,</span>
          <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default resource */</span><span class=tok-o>&gt;</span>
<span class=tok-k>using</span> <span class=tok-n>buffer_error_context</span> <span class=tok-o>=</span> <span class=tok-n>error_context</span><span class=tok-o>&lt;</span><span class=tok-n>Production</span><span class=tok-p>,</span> <span class=tok-n>buffer</span><span class=tok-o>&lt;</span><span class=tok-n>Encoding</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The class <code>lexy::buffer</code> is an immutable, owning variant of <code>lexy::string_input</code>.
The memory for the input is allocated using the <code>MemoryResource</code>, which is a class with the same interface as <code>std::pmr::memory_resource</code>.
By default, it uses a <code>new</code> and <code>delete</code> for the allocation, just like <code>std::pmr::new_delete_resource</code>.
Construction of the buffer is just like <code>lexy::string_input</code>, except for the additional <code>MemoryResource</code> parameter.
Once a memory resource has been specified, it will not propagate on assignment.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>As the buffer owns the input, it can terminate it with the EOF character for encodings that have the same character and integer type.
This eliminates the "is the reader at eof?"-branch during parsing.</td></tr></tbody></table></div><div class=sect4><h5 id=_builder>Builder</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>builder</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>explicit</span> <span class=tok-n>builder</span><span class=tok-p>(</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span>     <span class=tok-n>size</span><span class=tok-p>,</span>
                     <span class=tok-n>MemoryResource</span><span class=tok-o>*</span> <span class=tok-n>resource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default resource */</span><span class=tok-p>);</span>

    <span class=tok-n>char_type</span><span class=tok-o>*</span> <span class=tok-nf>data</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>size</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-n>buffer</span> <span class=tok-nf>finish</span><span class=tok-p>()</span> <span class=tok-o>&amp;&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>The <code>builder</code> class separates the allocation and copying of the buffer data.
This allows, for example, writing into the immutable buffer from a file.
The constructor allocates memory for <code>size</code> characters, then <code>data()</code> gives a mutable pointer to that memory.</p></div></div><div class=sect4><h5 id=_make_buffer_from_raw_memory>Make buffer from raw memory</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>struct</span> <span class=tok-cm>/* unspecified */</span>
<span class=tok-p>{</span>
    <span class=tok-k>auto</span> <span class=tok-nf>operator</span><span class=tok-p>()(</span><span class=tok-k>const</span> <span class=tok-kt>void</span><span class=tok-o>*</span> <span class=tok-n>memory</span><span class=tok-p>,</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>size</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span><span class=tok-o>&gt;</span>
    <span class=tok-k>auto</span> <span class=tok-k>operator</span><span class=tok-p>()(</span><span class=tok-k>const</span> <span class=tok-kt>void</span><span class=tok-o>*</span> <span class=tok-n>memory</span><span class=tok-p>,</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>size</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>*</span> <span class=tok-n>resource</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>
<span class=tok-p>};</span>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span><span class=tok-p>,</span> <span class=tok-n>encoding_endianness</span> <span class=tok-n>Endianness</span><span class=tok-o>&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>make_buffer_from_raw</span> <span class=tok-o>=</span> <span class=tok-cm>/* unspecified */</span><span class=tok-p>;</span></code></pre></div></div><div class=paragraph><p><code>lexy::make_buffer_from_raw</code> is a function object that constructs a <code>lexy::buffer</code> of the specified encoding from raw memory.
If necessary, it will take care of the endianness conversion as instructed by the <code>lexy::encoding_endianness</code> enumeration.
Any BOM, if present, will not be part of the input.</p></div><details><summary class=title>Example</summary><div class=content><div class=paragraph><p>Using a buffer to parse content from a <code>std::string</code> using UTF-8.
This enables the sentinel optimization.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>string</span> <span class=tok-n>str</span> <span class=tok-o>=</span> <span class=tok-err>…</span><span class=tok-p>;</span>
<span class=tok-k>auto</span> <span class=tok-n>input</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>buffer</span><span class=tok-o>&lt;</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>utf8_encoding</span><span class=tok-o>&gt;</span><span class=tok-p>(</span><span class=tok-n>str</span><span class=tok-p>);</span></code></pre></div></div><div class=paragraph><p>Using a buffer to parse a memory-mapped file containing little endian UTF-16.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>auto</span> <span class=tok-n>ptr</span> <span class=tok-o>=</span> <span class=tok-n>mmap</span><span class=tok-p>(</span><span class=tok-err>…</span><span class=tok-p>);</span>

<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>make_utf16_little</span>
  <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>make_buffer_from_raw</span><span class=tok-o>&lt;</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>utf16_encoding</span><span class=tok-p>,</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>encoding_endianness</span><span class=tok-o>::</span><span class=tok-n>little</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
<span class=tok-k>auto</span> <span class=tok-n>input</span> <span class=tok-o>=</span> <span class=tok-n>make_utf16_little</span><span class=tok-p>(</span><span class=tok-n>ptr</span><span class=tok-p>,</span> <span class=tok-n>length</span><span class=tok-p>);</span></code></pre></div></div></div></details></div></div><div class=sect3><h4 id=_file_input>File Input</h4><div class=listingblock><div class=title><code>lexy/input/file.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>enum</span> <span class=tok-k>class</span> <span class=tok-nc>file_error</span>
    <span class=tok-p>{</span>
        <span class=tok-n>os_error</span><span class=tok-p>,</span>
        <span class=tok-n>file_not_found</span><span class=tok-p>,</span>
        <span class=tok-n>permission_denied</span><span class=tok-p>,</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span>       <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-p>,</span>
              <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default resource */</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>read_file_result</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>using</span> <span class=tok-n>encoding</span>  <span class=tok-o>=</span> <span class=tok-n>Encoding</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>char_type</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>encoding</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-p>;</span>

        <span class=tok-k>explicit</span> <span class=tok-k>operator</span> <span class=tok-kt>bool</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-n>file_error</span> <span class=tok-nf>error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>const</span> <span class=tok-n>char_type</span><span class=tok-o>*</span> <span class=tok-n>data</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>size</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-n>Reader</span> <span class=tok-nf>reader</span><span class=tok-p>()</span> <span class=tok-k>const</span><span class=tok-o>&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span>          <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-p>,</span>
              <span class=tok-n>encoding_endianness</span> <span class=tok-n>Endian</span> <span class=tok-o>=</span> <span class=tok-n>encoding_endianness</span><span class=tok-o>::</span><span class=tok-n>bom</span><span class=tok-p>,</span>
              <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span><span class=tok-o>&gt;</span>
    <span class=tok-k>auto</span> <span class=tok-n>read_file</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span>     <span class=tok-n>path</span><span class=tok-p>,</span>
                   <span class=tok-n>MemoryResource</span><span class=tok-o>*</span> <span class=tok-n>resource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default resource */</span><span class=tok-p>)</span>
        <span class=tok-o>-&gt;</span> <span class=tok-n>read_file_result</span><span class=tok-o>&lt;</span><span class=tok-n>Encoding</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The function <code>lexy::read_file()</code> reads the file at the specified path using the specified encoding and endianness.
It returns a <code>lexy::read_file_result</code>.
If reading failed, the <code>operator bool</code> will return <code>false</code> and <code>.error()</code> will return the error code.
If reading was successful, the <code>operator bool</code> will return <code>true</code> and you can call <code>.data()</code>/<code>.size()</code> to get the file contents or treat it as an <code>Input</code>.</p></div><details><summary class=title>Example</summary><div class=content><div class=paragraph><p>Reading UTF-16 from a file with a BOM.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>auto</span> <span class=tok-n>result</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>read_file</span><span class=tok-o>&lt;</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>utf16_encoding</span><span class=tok-o>&gt;</span><span class=tok-p>(</span><span class=tok-s>&#34;input.txt&#34;</span><span class=tok-p>);</span>
<span class=tok-k>if</span> <span class=tok-p>(</span><span class=tok-o>!</span><span class=tok-n>result</span><span class=tok-p>)</span>
    <span class=tok-k>throw</span> <span class=tok-n>my_file_read_error_exception</span><span class=tok-p>(</span><span class=tok-n>result</span><span class=tok-p>.</span><span class=tok-n>error</span><span class=tok-p>());</span> // <b class=conum>(1)</b>

<span class=tok-err>…</span> <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Throw an exception giving it the <code>lexy::file_error</code>.</p></li><li><p>Now you can use <code>result</code> as an <code>Input</code> or access the file contents.</p></li></ol></div></div></details></div><div class=sect3><h4 id=_command_line_argument_input>Command-line argument Input</h4><div class=listingblock><div class=title><code>lexy/input/argv_input.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>class</span> <span class=tok-nc>argv_sentinel</span><span class=tok-p>;</span>
    <span class=tok-k>class</span> <span class=tok-nc>argv_iterator</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>argv_iterator</span> <span class=tok-n>argv_begin</span><span class=tok-p>(</span><span class=tok-kt>int</span> <span class=tok-n>argc</span><span class=tok-p>,</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>argv</span><span class=tok-p>[])</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>constexpr</span> <span class=tok-n>argv_iterator</span> <span class=tok-n>argv_end</span><span class=tok-p>(</span><span class=tok-kt>int</span> <span class=tok-n>argc</span><span class=tok-p>,</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>argv</span><span class=tok-p>[])</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span> <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>argv_input</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>using</span> <span class=tok-n>encoding</span>  <span class=tok-o>=</span> <span class=tok-n>Encoding</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>char_type</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>encoding</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>iterator</span>  <span class=tok-o>=</span> <span class=tok-n>argv_iterator</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-nf>argv_input</span><span class=tok-p>()</span> <span class=tok-o>=</span> <span class=tok-k>default</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-nf>argv_input</span><span class=tok-p>(</span><span class=tok-n>argv_iterator</span> <span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-n>argv_iterator</span> <span class=tok-n>end</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-nf>argv_input</span><span class=tok-p>(</span><span class=tok-kt>int</span> <span class=tok-n>argc</span><span class=tok-p>,</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>argv</span><span class=tok-p>[])</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-n>Reader</span> <span class=tok-n>reader</span><span class=tok-p>()</span> <span class=tok-k>const</span><span class=tok-o>&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Encoding</span> <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-o>&gt;</span>
    <span class=tok-k>using</span> <span class=tok-n>argv_lexeme</span> <span class=tok-o>=</span> <span class=tok-n>lexeme_for</span><span class=tok-o>&lt;</span><span class=tok-n>argv_input</span><span class=tok-o>&lt;</span><span class=tok-n>Encoding</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>;</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Encoding</span> <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-o>&gt;</span>
    <span class=tok-k>using</span> <span class=tok-n>argv_error</span> <span class=tok-o>=</span> <span class=tok-n>error_for</span><span class=tok-o>&lt;</span><span class=tok-n>argv_input</span><span class=tok-o>&lt;</span><span class=tok-n>Encoding</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>Tag</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Encoding</span> <span class=tok-o>=</span> <span class=tok-n>default_encoding</span><span class=tok-o>&gt;</span>
    <span class=tok-k>using</span> <span class=tok-n>argv_error_context</span> <span class=tok-o>=</span> <span class=tok-n>error_context</span><span class=tok-o>&lt;</span><span class=tok-n>Production</span><span class=tok-p>,</span> <span class=tok-n>argv_input</span><span class=tok-o>&lt;</span><span class=tok-n>Encoding</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The class <code>lexy::argv_input</code> is an input that uses the command-line arguments passed to <code>main()</code>.
It excludes <code>argv[0]</code>, which is the executable name, and includes <code>\0</code> as a separator between command line arguments.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The input is a lightweight view and does not own any data.</td></tr></tbody></table></div><div class=sect4><h5 id=_command_line_iterators>Command-line iterators</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>argv_sentinel</span><span class=tok-p>;</span>
<span class=tok-k>class</span> <span class=tok-nc>argv_iterator</span><span class=tok-p>;</span>

<span class=tok-k>constexpr</span> <span class=tok-n>argv_iterator</span> <span class=tok-n>argv_begin</span><span class=tok-p>(</span><span class=tok-kt>int</span> <span class=tok-n>argc</span><span class=tok-p>,</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>argv</span><span class=tok-p>[])</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-k>constexpr</span> <span class=tok-n>argv_iterator</span> <span class=tok-n>argv_end</span><span class=tok-p>(</span><span class=tok-kt>int</span> <span class=tok-n>argc</span><span class=tok-p>,</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>argv</span><span class=tok-p>[])</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span></code></pre></div></div><div class=paragraph><p>The <code>lexy::argv_iterator</code> is a bidirectional iterator iterating over the command-line arguments excluding the initial argument which is the executable name.
It can be created using <code>argv_begin()</code> and <code>argv_end()</code>.</p></div><details><summary class=title>Example</summary><div class=content><div class=paragraph><p>Use the command line arguments as input.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-kt>int</span> <span class=tok-nf>main</span><span class=tok-p>(</span><span class=tok-kt>int</span> <span class=tok-n>argc</span><span class=tok-p>,</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>argv</span><span class=tok-p>[])</span>
<span class=tok-p>{</span>
    <span class=tok-k>auto</span> <span class=tok-n>input</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>argv_input</span><span class=tok-p>(</span><span class=tok-n>argc</span><span class=tok-p>,</span> <span class=tok-n>argv</span><span class=tok-p>);</span>
    <span class=tok-err>…</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>If the program is invoked with <code>./a.out a 123 b</code>, the input will be <code>a\0123\0b</code>.</p></div></div></details></div></div></div><div class=sect2><h3 id=_lexemes_and_tokens>Lexemes and Tokens</h3><div class=paragraph><p>A <strong>lexeme</strong> is the part of the input matched by a token rule.
It is represented by the class <code>lexy::lexeme</code>.
A <strong>token</strong> is a combination of an identifier that defines the rule it matches, as well as the matched lexeme.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>When talking about tokens in the context of rules, it is usually short for token rule,
i.e. the rule that defines what is matched, not the concrete realization.</td></tr></tbody></table></div><div class=sect3><h4 id=_code_point>Code point</h4><div class=listingblock><div class=title><code>lexy/encoding.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>class</span> <span class=tok-nc>code_point</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>code_point</span><span class=tok-p>()</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>code_point</span><span class=tok-p>(</span><span class=tok-kt>char32_t</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-kt>char32_t</span> <span class=tok-n>value</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_valid</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_surrogate</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_scalar</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_ascii</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_bmp</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>friend</span> <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>code_point</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>code_point</span> <span class=tok-n>rhs</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>friend</span> <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>code_point</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>code_point</span> <span class=tok-n>rhs</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The class <code>lexy::code_point</code> represents a single code point from the input.
It is merely a wrapper over a <code>char32_t</code> that contains the numerical code.</p></div><div class=sect4><h5 id=_constructors>Constructors</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-nf>code_point</span><span class=tok-p>()</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
<span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>code_point</span><span class=tok-p>(</span><span class=tok-kt>char32_t</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Creates an invalid code point.</p></li><li><p>Creates the specified code point. The value will be returned from <code>value()</code> unchanged.</p></li></ol></div></div><div class=sect4><h5 id=_validity>Validity</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_valid</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
<span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_surrogate</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b>
<span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_scalar</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(3)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns <code>true</code> if the code point is less than <code>0x10’FFFF</code>, <code>false</code> otherwise.</p></li><li><p>Returns <code>true</code> if the code point is a UTF-16 surrogate, <code>false</code> otherwise.</p></li><li><p>Returns <code>true</code> if the code point is valid and not a surrogate, <code>false</code> otherwise.</p></li></ol></div></div><div class=sect4><h5 id=_category>Category</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_ascii</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
<span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_bmp</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns <code>true</code> if the code point is ASCII (7-bit value), <code>false</code> otherwise.</p></li><li><p>Returns <code>true</code> if the code point is in the Unicode BMP (16-bit value), <code>false</code> otherwise.</p></li></ol></div></div></div><div class=sect3><h4 id=_lexeme>Lexeme</h4><div class=listingblock><div class=title><code>lexy/lexeme.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>lexeme</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>using</span> <span class=tok-n>encoding</span>  <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>encoding</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>char_type</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>encoding</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>iterator</span>  <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-nf>lexeme</span><span class=tok-p>()</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-nf>lexeme</span><span class=tok-p>(</span><span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>lexeme</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>Reader</span><span class=tok-o>&amp;</span> <span class=tok-n>reader</span><span class=tok-p>,</span> <span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span>
        <span class=tok-o>:</span> <span class=tok-n>lexeme</span><span class=tok-p>(</span><span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-n>reader</span><span class=tok-p>.</span><span class=tok-n>cur</span><span class=tok-p>())</span>
        <span class=tok-p>{}</span>

        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>empty</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-c1>// Only if the iterator is a pointer.</span>
        <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-n>char_type</span><span class=tok-o>*</span> <span class=tok-n>data</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-c1>// Only if the iterator has `operator-`.</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>size</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-c1>// Only if the iterator has `operator[]`.</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>char_type</span> <span class=tok-k>operator</span><span class=tok-p>[](</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>idx</span><span class=tok-p>)</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-o>&gt;</span>
    <span class=tok-k>using</span> <span class=tok-n>lexeme_for</span> <span class=tok-o>=</span> <span class=tok-n>lexeme</span><span class=tok-o>&lt;</span><span class=tok-n>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The class <code>lexy::lexeme</code> represents a sub-range of the input.
For convenience, most inputs also provide convenience typedefs that can be used instead of <code>lexy::lexeme_for</code>.</p></div></div><div class=sect3><h4 id=_token_kind>Token Kind</h4><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>enum</span> <span class=tok-nc>predefined_token_kind</span>
    <span class=tok-p>{</span>
        <span class=tok-n>unknown_token_kind</span><span class=tok-p>,</span>
        <span class=tok-n>eof_token_kind</span><span class=tok-p>,</span>
        <span class=tok-n>position_token_kind</span><span class=tok-p>,</span>
        <span class=tok-n>identifier_token_kind</span><span class=tok-p>,</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span> <span class=tok-o>=</span> <span class=tok-kt>void</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>token_kind</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>token_kind</span><span class=tok-p>()</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-nf>token_kind</span><span class=tok-p>(</span><span class=tok-n>predefined_token_kind</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-nf>token_kind</span><span class=tok-p>(</span><span class=tok-n>TokenKind</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>TokenRule</span><span class=tok-o>&gt;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>token_kind</span><span class=tok-p>(</span><span class=tok-n>TokenRule</span> <span class=tok-n>token_rule</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-k>operator</span> <span class=tok-kt>bool</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_predefined</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>name</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-n>TokenKind</span> <span class=tok-n>get</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>static</span> <span class=tok-k>constexpr</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>uint_least16_t</span> <span class=tok-n>to_raw</span><span class=tok-p>(</span><span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>kind</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>static</span> <span class=tok-k>constexpr</span> <span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>from_raw</span><span class=tok-p>(</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>uint_least16_t</span> <span class=tok-n>kind</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>friend</span> <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>token_kind</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>token_kind</span> <span class=tok-n>rhs</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>friend</span> <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>token_kind</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>token_kind</span> <span class=tok-n>rhs</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The class <code>lexy::token_kind</code> identifies a token rule.
It is merely a wrapper over the specified <code>TokenKind</code>, which is an enum.
If <code>TokenKind</code> is <code>void</code>, it is a wrapper over an <code>int</code>.</p></div><div class=paragraph><p>A token kind can represent any of the <code>lexy::predefined_token_kind</code> as well as any values specified in the given enum,
or any integer value.
Predefined token kinds are mapped to spare enum values.</p></div><div class=sect4><h5 id=_constructors_2>Constructors</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-nf>token_kind</span><span class=tok-p>()</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>                         // <b class=conum>(1)</b>

<span class=tok-k>constexpr</span> <span class=tok-nf>token_kind</span><span class=tok-p>(</span><span class=tok-n>predefined_token_kind</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b>

<span class=tok-k>constexpr</span> <span class=tok-nf>token_kind</span><span class=tok-p>(</span><span class=tok-n>TokenKind</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(3)</b>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>TokenRule</span><span class=tok-o>&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-n>token_kind</span><span class=tok-p>(</span><span class=tok-n>TokenRule</span> <span class=tok-n>token_rule</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(4)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Creates an unknown token kind.</p></li><li><p>Creates a predefined token kind.</p></li><li><p>Creates the specified token kind, if <code>TokenKind</code> is <code>void</code>, constructor takes an <code>int</code>.</p></li><li><p>Creates a token kind from a token rule.</p></li></ol></div><div class=paragraph><p>The token kind of a rule is computed as follows:</p></div><div class=ulist><ul><li><p>If the token rule was associated with a token kind by calling <code>.kind&lt;value></code>, the resulting kind is the specified <code>value></code>.</p></li><li><p>Otherwise, if the map found at <code>lexy::token_kind_map_for&lt;TokenKind></code> contains a mapping for the <code>TokenRule</code>, it uses that.</p></li><li><p>Otherwise, the token kind is unknown.</p></li></ul></div></div><div class=sect4><h5 id=_access>Access</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-k>operator</span> <span class=tok-kt>bool</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>

<span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_predefined</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b>

<span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>name</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(3)</b>

<span class=tok-k>constexpr</span> <span class=tok-n>TokenKind</span> <span class=tok-n>get</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(4)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns <code>true</code> if the token kind is not unknown, <code>false</code> otherwise.</p></li><li><p>Returns <code>true</code> if the token kind one of the <code>lexy::predefined_token_kind`s, `false</code> otherwise.</p></li><li><p>Returns the name of the token kind.</p></li><li><p>Returns the underlying value of the token kind, which is some other value for predefined tokens.</p></li></ol></div><div class=paragraph><p>The name of a token kind is determined as follows:</p></div><div class=ulist><ul><li><p>If the <code>TokenKind</code> is <code>void</code>, the name is <code>"token"</code> for all token kinds.</p></li><li><p>Otherwise, if the token kind is unknown, the name is <code>"token"</code>.</p></li><li><p>Otherwise, if the token kind is predefined, the name describes the predefined token.</p></li><li><p>Otherwise, if ADL finds an overload <code>const char* token_kind_name(TokenKind kind)</code>,
returns that as the name.</p></li><li><p>Otherwise, the name is <code>"token"</code> for all tokens.</p></li></ul></div></div></div><div class=sect3><h4 id=_token_kind_map>Token Kind Map</h4><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>class</span> <span class=tok-nc>Token</span><span class=tok-o>-</span><span class=tok-n>Kind</span><span class=tok-o>-</span><span class=tok-n>Map</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>auto</span> <span class=tok-n>TokenKind</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenRule</span><span class=tok-o>&gt;</span>
        <span class=tok-k>consteval</span> <span class=tok-n>Token</span><span class=tok-o>-</span><span class=tok-n>Kind</span><span class=tok-o>-</span><span class=tok-n>Map</span> <span class=tok-n>map</span><span class=tok-p>(</span><span class=tok-n>TokenRule</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-kr>inline</span> <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>token_kind_map</span> <span class=tok-o>=</span> <span class=tok-n>Token</span><span class=tok-o>-</span><span class=tok-n>Kind</span><span class=tok-o>-</span><span class=tok-n>Map</span><span class=tok-p>{};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>token_kind_map_for</span> <span class=tok-o>=</span> <span class=tok-n>token_kind_map</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>There are two ways to associate a token kind with a token rule.
Either by calling <code>.kind&lt;Kind></code> on the token rule and giving it a value there,
or by specializing the <code>lexy::token_kind_map_for</code> for your <code>TokenKind</code> enumeration.</p></div><details><summary class=title>Example</summary><div class=content><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>enum</span> <span class=tok-k>class</span> <span class=tok-nc>my_token_kind</span> // <b class=conum>(1)</b>
<span class=tok-p>{</span>
    <span class=tok-n>code_point</span><span class=tok-p>,</span>
    <span class=tok-n>period</span><span class=tok-p>,</span>
    <span class=tok-n>open_paren</span><span class=tok-p>,</span>
    <span class=tok-n>close_paren</span><span class=tok-p>,</span>
<span class=tok-p>};</span>

// <b class=conum>(2)</b>
<span class=tok-k>template</span> <span class=tok-o>&lt;&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>token_kind_map_for</span><span class=tok-o>&lt;</span><span class=tok-n>my_token_kind</span><span class=tok-o>&gt;</span>
    <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>token_kind_map</span><span class=tok-p>.</span><span class=tok-n>map</span><span class=tok-o>&lt;</span><span class=tok-n>my_token_kind</span><span class=tok-o>::</span><span class=tok-n>code_point</span><span class=tok-o>&gt;</span><span class=tok-p>(</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>dsl</span><span class=tok-o>::</span><span class=tok-n>code_point</span><span class=tok-p>)</span>
                          <span class=tok-p>.</span><span class=tok-n>map</span><span class=tok-o>&lt;</span><span class=tok-n>my_token_kind</span><span class=tok-o>::</span><span class=tok-n>period</span><span class=tok-o>&gt;</span><span class=tok-p>(</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>dsl</span><span class=tok-o>::</span><span class=tok-n>period</span><span class=tok-p>)</span>
                          <span class=tok-p>.</span><span class=tok-n>map</span><span class=tok-o>&lt;</span><span class=tok-n>my_token_kind</span><span class=tok-o>::</span><span class=tok-n>open_paren</span><span class=tok-o>&gt;</span><span class=tok-p>(</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>dsl</span><span class=tok-o>::</span><span class=tok-n>parenthesized</span><span class=tok-p>.</span><span class=tok-n>open</span><span class=tok-p>())</span>
                          <span class=tok-p>.</span><span class=tok-n>map</span><span class=tok-o>&lt;</span><span class=tok-n>my_token_kind</span><span class=tok-o>::</span><span class=tok-n>close_paren</span><span class=tok-o>&gt;</span><span class=tok-p>(</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>dsl</span><span class=tok-o>::</span><span class=tok-n>parenthesized</span><span class=tok-p>.</span><span class=tok-n>close</span><span class=tok-p>());</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Define your <code>TokenKind</code> enumeration.</p></li><li><p>Define the mapping of token rules to enumeration values.</p></li></ol></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The token kind is only relevant when <code>lexy::parse_as_tree()</code> is used to parse the input.</td></tr></tbody></table></div></div><div class=sect3><h4 id=_token>Token</h4><div class=listingblock><div class=title><code>lexy/token.hpp</code></div><div class=content><pre>namespace lexy
{
    template &lt;typename Reader, typename TokenKind = void&gt;
    class token
    {
    public:
        explicit constexpr token(token_kind&lt;TokenKind&gt; kind, lexy::lexeme&lt;Reader&gt; lex) noexcept;
        explicit constexpr token(token_kind&lt;TokenKind&gt; kind,
                                 typename Reader::iterator begin,
                                 typename Reader::iterator end) noexcept;

        constexpr token_kind&lt;TokenKind&gt; kind() const noexcept;
        constexpr auto lexeme() const noexcept;

        constexpr auto name() const noexcept { return kind().name(); }

        constexpr auto position() const noexcept -&gt; typename Reader::iterator
        {
            return lexeme().begin();
        }
    };

    template &lt;typename Input, typename TokenKind = void&gt;
    using token_for = token&lt;input_reader&lt;Input&gt;, TokenKind&gt;;
}</pre></div></div><div class=paragraph><p>The class <code>lexy::token</code> just combines a <code>lexy::token_kind</code> and a <code>lexy::lexeme</code>.</p></div></div></div><div class=sect2><h3 id=_writing_custom_inputs>Writing custom Inputs</h3><div class=listingblock><div class=title>The <code>Input</code> concept</div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>Input</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-n>Reader</span> <span class=tok-n>reader</span><span class=tok-p>()</span> <span class=tok-k>const</span><span class=tok-o>&amp;</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>An <code>Input</code> is just a class with a <code>reader()</code> member function that returns a <code>Reader</code> to the beginning of the input.
The type alias <code>lexy::input_reader&lt;Reader></code> returns the type of the corresponding reader.</p></div><div class="admonitionblock warning"><table><tbody><tr><td class=icon><div class=title>Warning</div></td><td class=content>The interface of a <code>Reader</code> is currently experimental.
Refer to the comments in <code>lexy/input/base.hpp</code>.</td></tr></tbody></table></div></div></div></div><div class=sect1><h2 id=_matching_parsing_and_validating>Matching, parsing and validating</h2><div class=sectionbody><div class=listingblock><div class=title>The <code>Production</code> concept</div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>struct</span> <span class=tok-nc>Production</span>
<span class=tok-p>{</span>
    <span class=tok-k>static</span> <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>rule</span> <span class=tok-o>=</span> <span class=tok-err>…</span><span class=tok-p>;</span>
    <span class=tok-k>static</span> <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>whitespace</span> <span class=tok-o>=</span> <span class=tok-err>…</span><span class=tok-p>;</span> <span class=tok-c1>// optional</span>

    <span class=tok-k>static</span> <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>value</span> <span class=tok-o>=</span> <span class=tok-err>…</span><span class=tok-p>;</span> <span class=tok-c1>// optional</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>A <code>Production</code> is type containing a rule and optional callbacks that produce the value.
A grammar contains an entry production where parsing begins and all productions referenced by it.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>It is recommended to put all productions of a grammar into a separate namespace.</td></tr></tbody></table></div><div class=paragraph><p>By passing the entry production of the grammar to <code>lexy::match()</code>, <code>lexy::parse()</code>, or <code>lexy::validate()</code>, the production is parsed.</p></div><h3 id=_matching class=discrete>Matching</h3><div class=listingblock><div class=title><code>lexy/match.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>match</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>);</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The function <code>lexy::match()</code> matches the <code>Production</code> on the given <code>input</code>.
If the production accepts the input, returns <code>true</code>, otherwise, returns <code>false</code>.
It will discard any values produced and does not give detailed information about why the production did not accept the input.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>A production does not necessarily need to consume the entire input for it to match.
Add <code>lexy::dsl::eof</code> to the end if the production should consume the entire input.</td></tr></tbody></table></div><h3 id=_validating class=discrete>Validating</h3><div class=listingblock><div class=title><code>lexy/validate.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>ErrorCallback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>validate_result</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>using</span> <span class=tok-n>error_callback</span> <span class=tok-o>=</span> <span class=tok-n>ErrorCallback</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>error_type</span>     <span class=tok-o>=</span> <span class=tok-cm>/* return type of the sink */</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-k>operator</span> <span class=tok-kt>bool</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span>
        <span class=tok-p>{</span>
            <span class=tok-k>return</span> <span class=tok-nf>is_success</span><span class=tok-p>();</span>
        <span class=tok-p>}</span>

        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_success</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_recovered_error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(3)</b>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_fatal_error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(4)</b>

        <span class=tok-k>constexpr</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>error_count</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-n>error_type</span><span class=tok-o>&amp;</span> <span class=tok-n>errors</span><span class=tok-p>()</span> <span class=tok-k>const</span><span class=tok-o>&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>error_type</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>errors</span><span class=tok-p>()</span> <span class=tok-o>&amp;&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>ErrorCallback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>validate</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>,</span> <span class=tok-n>ErrorCallback</span> <span class=tok-n>error_callback</span><span class=tok-p>)</span>
        <span class=tok-o>-&gt;</span> <span class=tok-n>validate_result</span><span class=tok-o>&lt;</span><span class=tok-n>ErrorCallback</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns <code>true</code> if no error occurred during validation.</p></li><li><p>Returns <code>true</code> if at least one error occurred during validation.</p></li><li><p>Returns <code>true</code> if at least one error occurred during validation, but parsing could recover after all of them.</p></li><li><p>Returns <code>true</code> if at least one error occurred during validation and parsing had to cancel.</p></li></ol></div><div class=paragraph><p>The function <code>lexy::validate()</code> validates that the <code>Production</code> matches on the given <code>input</code>.
If a parse error occurs, it will invoke the error callback (see <a href=#_error_handling>Error handling</a>); all errors are then returned.
It will discard any values produced.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>A production does not necessarily need to consume the entire input for it to match.
Add <code>lexy::dsl::eof</code> to the end if the production should consume the entire input.</td></tr></tbody></table></div><h3 id=_parsing class=discrete>Parsing</h3><div class=listingblock><div class=title><code>lexy/parse.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>T</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>ErrorCallback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>parse_result</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>using</span> <span class=tok-n>value_type</span>     <span class=tok-o>=</span> <span class=tok-n>T</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>error_callback</span> <span class=tok-o>=</span> <span class=tok-n>ErrorCallback</span><span class=tok-p>;</span>
        <span class=tok-k>using</span> <span class=tok-n>error_type</span>     <span class=tok-o>=</span> <span class=tok-cm>/* return type of the sink */</span><span class=tok-p>;</span>

        <span class=tok-c1>//=== status ===//</span>
        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-k>operator</span> <span class=tok-kt>bool</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span>
        <span class=tok-p>{</span>
            <span class=tok-k>return</span> <span class=tok-nf>is_success</span><span class=tok-p>();</span>
        <span class=tok-p>}</span>

        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_success</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_recovered_error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(3)</b>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>is_fatal_error</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(4)</b>

        <span class=tok-c1>//=== value ===//</span>
        <span class=tok-k>constexpr</span> <span class=tok-kt>bool</span> <span class=tok-n>has_value</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(5)</b>

        <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-n>T</span><span class=tok-o>&amp;</span> <span class=tok-n>value</span><span class=tok-p>()</span> <span class=tok-k>const</span><span class=tok-o>&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>T</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>value</span><span class=tok-p>()</span> <span class=tok-o>&amp;&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-c1>//=== error ===//</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>error_count</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-n>error_type</span><span class=tok-o>&amp;</span> <span class=tok-n>errors</span><span class=tok-p>()</span> <span class=tok-k>const</span><span class=tok-o>&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>error_type</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>errors</span><span class=tok-p>()</span> <span class=tok-o>&amp;&amp;</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>ErrorCallback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>parse</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>,</span> <span class=tok-n>ErrorCallback</span> <span class=tok-n>error_callback</span><span class=tok-p>)</span>
        <span class=tok-o>-&gt;</span> <span class=tok-n>parse_result</span><span class=tok-o>&lt;</span><span class=tok-cm>/* see below */</span><span class=tok-p>,</span> <span class=tok-n>ErrorCallback</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>State</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>ErrorCallback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>parse</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>,</span> <span class=tok-k>const</span> <span class=tok-n>State</span><span class=tok-o>&amp;</span> <span class=tok-n>state</span><span class=tok-p>,</span> <span class=tok-n>ErrorCallback</span> <span class=tok-n>error_callback</span><span class=tok-p>)</span>
        <span class=tok-o>-&gt;</span> <span class=tok-n>parse_result</span><span class=tok-o>&lt;</span><span class=tok-cm>/* see below */</span><span class=tok-p>,</span> <span class=tok-n>ErrorCallback</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns <code>true</code> if no error occurred during parsing.</p></li><li><p>Returns <code>true</code> if at least one error occurred during parsing.</p></li><li><p>Returns <code>true</code> if at least one error occurred during parsing, but parsing could recover after all of them.</p></li><li><p>Returns <code>true</code> if at least one error occurred during parsing and parsing had to cancel.</p></li><li><p>Returns <code>true</code> if parsing could produce a value. This can only happen if there was no fatal error.</p></li></ol></div><div class=paragraph><p>The function <code>lexy::parse()</code> parses the <code>Production</code> on the given <code>input</code>.
The return value is a <code>lexy::parse_result&lt;T, ErrorCallback></code>, where <code>T</code> is the return type of the <code>Production::value</code> or <code>Production::list</code> callback.
If the production accepts the input or there are only recoverable errors, invokes <code>Production::value</code> (see below) with the produced values and returns their result.
Invokes the error callback for each parse error (see <a href=#_error_handling>Error handling</a>) and collects the errors.</p></div><div class=paragraph><p>The return value on success is determined using <code>Production::value</code> depending on three cases:</p></div><div class=ulist><ul><li><p><code>Production::rule</code> does not contain a list. Then all arguments will be forwarded to <code>Production::value</code> as a callback whose result is returned.</p></li><li><p><code>Production::rule</code> contains a list and no other rule produces a value. Then <code>Production::value</code> will be used as sink for the list values.
If <code>Production::value</code> is also a callback that accepts the result of the sink as argument,
it will be invoked with the sink result and the processed result returned.
Otherwise, the result of the sink is the final result.</p></li><li><p><code>Production::rule</code> contains a list and other rules produce values as well.
Then <code>Production::value</code> will be used as sink for the list values.
The sink result will be added to the other values in order and everything forwarded to <code>Production::value</code> as a callback.
The callback result is then returned.</p></li></ul></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The callback <code>operator>></code> is useful for case 3 to create a combined callback and sink with the desired behavior.</td></tr></tbody></table></div><div class=paragraph><p>The second overload of <code>lexy::parse()</code> allows passing an arbitrary state argument.
This state will be made available to <code>lexy::parse_state</code> (see <a href=#_binding_arguments>Binding arguments</a>) and passed to the <code>.sink()</code> of <code>Production::value</code>, if it accepts it.
That way, you can access other information (e.g. allocators for your containers) in the callbacks.</p></div><div class=sect2><h3 id=_callbacks>Callbacks</h3><div class=listingblock><div class=title>The <code>Callback</code> concept</div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>struct</span> <span class=tok-nc>Callback</span>
<span class=tok-p>{</span>
    <span class=tok-k>using</span> <span class=tok-n>return_type</span> <span class=tok-o>=</span> <span class=tok-err>…</span><span class=tok-p>;</span>

    <span class=tok-n>return_type</span> <span class=tok-nf>operator</span><span class=tok-p>()(</span><span class=tok-n>Args</span><span class=tok-o>&amp;&amp;</span><span class=tok-p>...</span> <span class=tok-n>args</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>
<span class=tok-p>};</span>

<span class=tok-k>struct</span> <span class=tok-nc>Sink</span>
<span class=tok-p>{</span>
    <span class=tok-k>class</span> <span class=tok-nc>_sink</span> <span class=tok-c1>// exposition only</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>using</span> <span class=tok-n>return_type</span> <span class=tok-o>=</span> <span class=tok-err>…</span><span class=tok-p>;</span>

        <span class=tok-kt>void</span> <span class=tok-nf>operator</span><span class=tok-p>()(</span><span class=tok-n>Args</span><span class=tok-o>&amp;&amp;</span><span class=tok-p>...</span> <span class=tok-n>args</span><span class=tok-p>);</span>

        <span class=tok-n>return_type</span><span class=tok-o>&amp;&amp;</span> <span class=tok-nf>finish</span><span class=tok-p>()</span> <span class=tok-o>&amp;&amp;</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-n>_sink</span> <span class=tok-nf>sink</span><span class=tok-p>(</span><span class=tok-n>Args</span><span class=tok-o>&amp;&amp;</span><span class=tok-p>...</span> <span class=tok-n>args</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>A <code>Callback</code> is a function object whose return type is specified by a member typedef.
A <code>Sink</code> is a type with a <code>sink()</code> member function, which can take arbitrary arguments (e.g. allocators) and returns a callback.
The callback can be invoked multiple times and the final value is return by calling <code>.finish()</code>.</p></div><div class=paragraph><p>Callbacks are used by <code>lexy</code> to compute the parse result and handle error values.
They can either be written manually implementing to the above concepts or composed from the pre-defined concepts.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>When a <code>Sink</code> is used as <code>Production::value</code>, the <code>.sink()</code> member function must either have zero parameters or a single one that matches the state passed to the <code>lexy::parse()</code> overload.
The latter is the case if <code>lexy::bind_sink()</code> is used.</td></tr></tbody></table></div><div class=sect3><h4 id=_callback_adapters>Callback adapters</h4><div class=listingblock><div class=title><code>lexy/callback/base.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>ReturnType</span> <span class=tok-o>=</span> <span class=tok-kt>void</span><span class=tok-p>,</span> <span class=tok-k>typename</span><span class=tok-p>...</span> <span class=tok-n>Fns</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-n>Callback</span> <span class=tok-n>callback</span><span class=tok-p>(</span><span class=tok-n>Fns</span><span class=tok-o>&amp;&amp;</span><span class=tok-p>...</span> <span class=tok-n>fns</span><span class=tok-p>);</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>Creates a callback with the given <code>ReturnType</code> from multiple functions.
When calling the resulting callback, it will use overload resolution to determine the correct function to call.
It supports function pointers, lambdas, and member function or data pointers.</p></div></div><div class=sect3><h4 id=_callback_composition>Callback composition</h4><div class=listingblock><div class=title><code>lexy/callback/base.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>First</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Second</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-k>operator</span><span class=tok-o>|</span><span class=tok-p>(</span><span class=tok-n>First</span> <span class=tok-n>first</span><span class=tok-p>,</span> <span class=tok-n>Second</span> <span class=tok-n>second</span><span class=tok-p>);</span> // <b class=conum>(1)</b>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Sink</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Callback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-k>operator</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>(</span><span class=tok-n>Sink</span> <span class=tok-n>sink</span><span class=tok-p>,</span> <span class=tok-n>Callback</span> <span class=tok-n>callback</span><span class=tok-p>);</span> // <b class=conum>(2)</b>

<span class=tok-p>}</span></code></pre></div></div><div class="colist arabic"><ol><li><p>The result of <code>first | second</code>, where <code>first</code> and <code>second</code> are both callbacks, is another callback that first invokes <code>first</code> and then passes the result to <code>second</code>.
The result cannot be used as sink.</p></li><li><p>The result of <code>sink >> callback</code>, is both a sink and a callback.
As a sink, it behaves just like <code>sink</code>.
As a callback, it takes the result of the <code>sink</code> as well as any other arguments and forwards them to <code>callback</code>.</p></li></ol></div><details><summary class=title>Example</summary><div class=content><div class=paragraph><p>Build a string, then get its length.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>make_string</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>callback</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>string</span><span class=tok-o>&gt;</span><span class=tok-p>([](</span><span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>str</span><span class=tok-p>)</span> <span class=tok-p>{</span> <span class=tok-k>return</span> <span class=tok-n>str</span><span class=tok-p>;</span> <span class=tok-p>});</span>
<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>string_length</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>callback</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span><span class=tok-o>&gt;</span><span class=tok-p>(</span><span class=tok-o>&amp;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>string</span><span class=tok-o>::</span><span class=tok-n>size</span><span class=tok-p>);</span>

<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>inefficient_strlen</span> <span class=tok-o>=</span> <span class=tok-n>make_string</span> <span class=tok-o>|</span> <span class=tok-n>string_length</span><span class=tok-p>;</span> // <b class=conum>(1)</b>

<span class=tok-n>assert</span><span class=tok-p>(</span><span class=tok-n>inefficient_strlen</span><span class=tok-p>(</span><span class=tok-s>&#34;1234&#34;</span><span class=tok-p>)</span> <span class=tok-o>==</span> <span class=tok-mi>4</span><span class=tok-p>);</span> // <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Compose the two callbacks.</p></li><li><p>Use it.</p></li></ol></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>The callback <code>operator>></code> is used for productions whose rule contain both a list and produce other values.
The list will be constructed using the <code>sink</code> and then everything will be passed to <code>callback</code>.</td></tr></tbody></table></div></div><div class=sect3><h4 id=_the_no_op_callback>The no-op callback</h4><div class=listingblock><div class=title><code>lexy/callback/noop.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>noop</span> <span class=tok-o>=</span> <span class=tok-cm>/* unspecified */</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p><code>lexy::noop</code> is both a callback and a sink.
It ignores all arguments passed to it and its return type is <code>void</code>.</p></div><details><summary class=title>Example</summary><div class=content><div class=paragraph><p>Parse the production, but do nothing on errors.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>auto</span> <span class=tok-n>result</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>parse</span><span class=tok-o>&lt;</span><span class=tok-n>my_production</span><span class=tok-o>&gt;</span><span class=tok-p>(</span><span class=tok-n>my_input</span><span class=tok-p>,</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>noop</span><span class=tok-p>);</span> // <b class=conum>(1)</b>
<span class=tok-k>if</span> <span class=tok-p>(</span><span class=tok-o>!</span><span class=tok-n>result</span><span class=tok-p>)</span>
    <span class=tok-k>throw</span> <span class=tok-n>my_parse_error</span><span class=tok-p>();</span> // <b class=conum>(2)</b>
<span class=tok-k>auto</span> <span class=tok-n>value</span> <span class=tok-o>=</span> <span class=tok-n>result</span><span class=tok-p>.</span><span class=tok-n>value</span><span class=tok-p>();</span> // <b class=conum>(3)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Parse <code>my_production</code>. If an error occurs, just return a <code>result&lt;T, void></code> in the error state.</p></li><li><p><code>lexy::noop</code> does not make errors disappear, they still need to be handled.</p></li><li><p>Do something with the parsed value.</p></li></ol></div></div></details></div><div class=sect3><h4 id=_the_constant_callback>The constant callback</h4><div class=listingblock><div class=title><code>lexy/callback/constant.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Arg</span><span class=tok-o>&gt;</span>
<span class=tok-k>consteval</span> <span class=tok-k>auto</span> <span class=tok-n>constant</span><span class=tok-p>(</span><span class=tok-n>Arg</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>arg</span><span class=tok-p>);</span></code></pre></div></div><div class=paragraph><p>The <code>lexy::constant()</code> callback does not take any arguments and always produces the given value.</p></div></div><div class=sect3><h4 id=_forwarding_a_result>Forwarding a result</h4><div class=listingblock><div class=title><code>lexy/callback/forward.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>T</span><span class=tok-o>&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>forward</span> <span class=tok-o>=</span> <span class=tok-cm>/* unspecified */</span><span class=tok-p>;</span></code></pre></div></div><div class=paragraph><p>The callback <code>lexy::forward&lt;T></code> can accept either a <code>const T&</code> or a <code>T&&</code> and forwards it.
It does not have a sink.</p></div></div><div class=sect3><h4 id=_constructing_objects>Constructing objects</h4><div class=listingblock><div class=title><code>lexy/callback/object.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>T</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>construct</span> <span class=tok-o>=</span> <span class=tok-cm>/* unspecified */</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>T</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>PtrT</span> <span class=tok-o>=</span> <span class=tok-n>T</span><span class=tok-o>*&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>new_</span> <span class=tok-o>=</span> <span class=tok-cm>/* unspecified */</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The callback <code>lexy::construct&lt;T></code> constructs a <code>T</code> by forwarding all arguments to a suitable constructor.
If the type does not have a constructor, it forwards all arguments using brace initialization.
It does not have a sink.</p></div><div class=paragraph><p>The callback <code>lexy::new_&lt;T, PtrT></code> works just like <code>lexy::construct&lt;T></code>, but it constructs the object on the heap by calling <code>new</code>.
The resulting pointer is then converted to the specified <code>PtrT</code>.
It does not have a sink.</p></div><details><summary class=title>Example</summary><div class=content><div class=paragraph><p>A callback that creates a <code>std::unique_ptr&lt;std::string></code>.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>make_unique_str</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>new_</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>string</span><span class=tok-p>,</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>unique_ptr</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>string</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>;</span> // <b class=conum>(1)</b>

<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>make_unique_str2</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>new_</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>string</span><span class=tok-o>&gt;</span> <span class=tok-o>|</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>construct</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>unique_ptr</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>string</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>;</span> // <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Specify a suitable <code>PtrT</code>.</p></li><li><p>Equivalent version that uses composition and <code>lexy::construct</code> instead.</p></li></ol></div></div></details></div><div class=sect3><h4 id=_constructing_containers>Constructing containers</h4><div class=listingblock><div class=title><code>lexy/callback/container.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Container</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>as_list</span> <span class=tok-o>=</span> <span class=tok-cm>/* unspecified */</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Container</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>as_collection</span> <span class=tok-o>=</span> <span class=tok-cm>/* unspecified */</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p><code>lexy::as_list&lt;Container></code> is a sink.
If <code>.sink()</code> is called with no arguments, it default constructs a <code>Container</code>.
If <code>.sink()</code> is called with a single argument of type <code>Container::allocator_type</code>, it constructs an empty <code>Container</code> using that allocator.
It then repeatedly calls <code>push_back()</code> for single arguments and <code>emplace_back()</code> otherwise.</p></div><div class=paragraph><p><code>lexy::as_collection&lt;Container></code> is like <code>lexy::as_list&lt;Container></code>, but instead of calling <code>push_back()</code> and <code>emplace_back()</code>, it calls <code>insert()</code> and <code>emplace()</code>.</p></div><details><summary class=title>Example</summary><div class=content><div class=paragraph><p>Create a <code>std::vector&lt;int></code> and <code>std::set&lt;int></code>.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>as_int_vector</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>as_list</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>vector</span><span class=tok-o>&lt;</span><span class=tok-kt>int</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>;</span>
<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>as_int_set</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>as_collection</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>set</span><span class=tok-o>&lt;</span><span class=tok-kt>int</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>;</span></code></pre></div></div></div></details><div class=listingblock><div class=title><code>lexy/callback/container.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Callback</span><span class=tok-o>&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-n>Sink</span> <span class=tok-n>collect</span><span class=tok-p>(</span><span class=tok-n>Callback</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>callback</span><span class=tok-p>);</span>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Container</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Callback</span><span class=tok-o>&gt;</span>
<span class=tok-k>constexpr</span> <span class=tok-n>Sink</span> <span class=tok-n>collect</span><span class=tok-p>(</span><span class=tok-n>Callback</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>callback</span><span class=tok-p>);</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>Turns a callback into a sink by invoking it multiple times and collecting all the results in a container.</p></div><div class=paragraph><p>The first version requires that the callback returns <code>void</code>;
its sink callback forwards all arguments and increases a count.
The final count as a <code>std::size_t</code> is then returned by <code>finish()</code>.</p></div><div class=paragraph><p>The second version requires that the callback returns non-<code>void</code>.
Its sink callback creates a default constructed <code>Container</code>, optionally using a passed <code>Container::allocator_type</code>.
It then invokes the callback multiple times and adds the result to the container using <code>.push_back()</code>.
The final container is then returned.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content><code>collect()</code> is useful for the error callback to handle multiple errors.</td></tr></tbody></table></div></div><div class=sect3><h4 id=_constructing_strings>Constructing strings</h4><div class=listingblock><div class=title><code>lexy/callback/string.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>String</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Encoding</span> <span class=tok-o>=</span> <span class=tok-cm>/* see below */</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>as_string</span> <span class=tok-o>=</span> <span class=tok-cm>/* unspecified */</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p><code>lexy::as_string&lt;String, Encoding></code> is both a callback and a sink, which accepts no arguments.
It constructs a <code>String</code> object in the given <code>Encoding</code>.
If no encoding is specified, it deduces one from the character type of the string.</p></div><div class=paragraph><p>As a callback, it constructs the string directly from the given argument.
Then it accepts:</p></div><div class=ulist><ul><li><p>A reference to an existing <code>String</code> object, which is forwarded as the result.</p></li><li><p>A <code>const CharT*</code> and a <code>std::size_t</code>, where <code>CharT</code> is a compatible character type. The two arguments are forwarded to a <code>String</code> constructor.</p></li><li><p>A <code>lexy::lexeme&lt;Reader> lex</code>, where <code>Reader::iterator</code> is a pointer.
The character type of the reader must be compatible with the encoding.
It constructs the string using <code>String(lex.data(), lex.size())</code> (potentially casting the pointer type if necessary).</p></li><li><p>A <code>lexy::lexeme&lt;Reader> lex</code>, where <code>Reader::iterator</code> is not a pointer.
It constructs the string using <code>String(lex.begin(), lex.end())</code>.
The range constructor has to take care of any necessary character conversion.</p></li><li><p>A <code>lexy::code_point</code>. It is encoded into a local character array according to the specified <code>Encoding</code>.
Then the string is constructed using a two-argument <code>(const CharT*, std::size_t)</code> constructor.</p></li></ul></div><div class=paragraph><p>As a sink, it first default constructs the string, optionally using a passed <code>String::allocator_type</code>.
Then it will repeatedly append the following arguments:</p></div><div class=ulist><ul><li><p>A single <code>CharT</code>, which is convertible to the strings character type.
It is appended by calling <code>.push_back()</code>.</p></li><li><p>A reference to an existing <code>String</code> object, which is appended by calling <code>.append()</code>.</p></li><li><p>A <code>const CharT*</code> and a <code>std::size_t</code>, where <code>CharT</code> is a compatible character type.
The two arguments are forwarded to <code>.append()</code>.</p></li><li><p>A <code>lexy::lexeme&lt;Reader> lex</code>, where <code>Reader::iterator</code> is a pointer.
The character type of the reader must be compatible with the encoding.
It is appended using <code>.append(lex.data(), lex.size())</code> (potentially casting the pointer type if necessary).</p></li><li><p>A <code>lexy::lexeme&lt;Reader> lex</code>, where <code>Reader::iterator</code> is not a pointer.
It constructs the string using <code>.append(lex.begin(), lex.end())</code>.
The range append function has to take care of any necessary character conversion.</p></li><li><p>A <code>lexy::code_point</code>. It is encoded into a local character array according to the specified <code>Encoding</code>.
Then it is appended to the string using a two-argument <code>.append(const CharT*, std::size_t)</code> overload.</p></li></ul></div><details><summary class=title>Example</summary><div class=content><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>as_utf16_string</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>as_string</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>u16string</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>                   // <b class=conum>(1)</b>
<span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>as_utf8_string</span>  <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>as_string</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>string</span><span class=tok-p>,</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>utf8_encoding</span><span class=tok-o>&gt;</span><span class=tok-p>;</span> // <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Constructs a <code>std::u16string</code>, deducing the encoding as UTF-16.</p></li><li><p>Constructs a <code>std::string</code>, specifying the encoding as UTF-8.</p></li></ol></div></div></details></div><div class=sect3><h4 id=_binding_arguments>Binding arguments</h4><div class=listingblock><div class=title><code>lexy/callback/bind.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Callback</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-p>...</span> <span class=tok-n>Args</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>bind</span><span class=tok-p>(</span><span class=tok-n>Callback</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>callback</span><span class=tok-p>,</span> <span class=tok-n>Args</span><span class=tok-o>&amp;&amp;</span><span class=tok-p>...</span> <span class=tok-n>args</span><span class=tok-p>);</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p><code>lexy::bind()</code> allows binding some parameters of <code>callback</code> to given values or re-ordering arguments before invoking the callback, similar to <code>std::bind()</code>.</p></div><div class=paragraph><p>It can accept either a <code>Callback</code> or a <code>Sink</code>.
For a <code>Callback</code>, binds the invocation of its <code>operator()</code>.
For a <code>Sink</code>, binds the invocation of the <code>operator()</code> of the sink’s callback that will be invoked for every item.</p></div><div class=paragraph><p>The arguments to <code>lexy::bind()</code> can either be arbitrary expressions or bind placeholders (see below).
If the Nth argument is an expression, the value of the expression will be passed as the Nth argument to <code>callback</code>.
If the Nth argument is a bind placeholder, the value produced by the placeholder will be passed as the Nth argument to <code>callback</code>.</p></div><details><summary class=title>Example</summary><div class=content><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>make_stars</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>bind</span><span class=tok-p>(</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>construct</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>string</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>_1</span> <span class=tok-n>or</span> <span class=tok-mi>0</span><span class=tok-p>,</span> <span class=tok-sc>&#39;*&#39;</span><span class=tok-p>);</span> // <b class=conum>(1)</b>
<span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>string</span> <span class=tok-n>a</span> <span class=tok-o>=</span> <span class=tok-n>make_stars</span><span class=tok-p>(</span><span class=tok-mi>3</span><span class=tok-p>);</span> // <b class=conum>(2)</b>
<span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>string</span> <span class=tok-n>b</span> <span class=tok-o>=</span> <span class=tok-n>make_stars</span><span class=tok-p>();</span> // <b class=conum>(3)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Bind the <code>(std::size_t, char)</code> constructor of <code>std::string</code>: the first argument will be forwarded, but the second is fixed to <code>'*'</code>.</p></li><li><p><code>a</code> will be <code>"***"</code></p></li><li><p><code>b</code> will be <code>""</code> as the default value for the first argument is <code>0</code>.</p></li></ol></div></div></details><div class=listingblock><div class=title><code>lexy/callback/bind.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Sink</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-p>...</span> <span class=tok-n>Args</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>bind_sink</span><span class=tok-p>(</span><span class=tok-n>Sink</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>callback</span><span class=tok-p>,</span> <span class=tok-n>Args</span><span class=tok-o>&amp;&amp;</span><span class=tok-p>...</span> <span class=tok-n>args</span><span class=tok-p>);</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p><code>lexy::bind_sink()</code> behaves similar to <code>lexy::bind()</code>, but it binds the <code>.sink()</code> function of a <code>Sink</code> instead.</p></div><details><summary class=title>Example</summary><div class=content><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>list</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>bind_sink</span><span class=tok-p>(</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>as_list</span><span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-n>vector</span><span class=tok-o>&lt;</span><span class=tok-kt>int</span><span class=tok-o>&gt;&gt;</span><span class=tok-p>,</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>parse_state</span><span class=tok-p>.</span><span class=tok-n>map</span><span class=tok-p>(</span><span class=tok-o>&amp;</span><span class=tok-n>MyState</span><span class=tok-o>::</span><span class=tok-n>allocator</span><span class=tok-p>);</span></code></pre></div></div><div class=paragraph><p>Constructs a list using an allocator by forwarding the <code>.allocator</code> member of <code>MyState</code> to the <code>.sink()</code>.
This requires that you call <code>lexy::parse()</code> passing it a <code>MyState</code> object.</p></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>It does not make sense to use <code>lexy::nth_value</code> or <code>lexy::values</code> as bind placeholders:
<code>.sink()</code> does not accept any arguments in normal parsing code, it only takes the state accessible via <code>lexy::parse_state</code>.</td></tr></tbody></table></div><div class=sect4><h5 id=_lexynth_value><code>lexy::nth_value</code></h5><div class=listingblock><div class=title><code>lexy/callback/bind.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>N</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>nth</span><span class=tok-o>-</span><span class=tok-n>value</span><span class=tok-o>-</span><span class=tok-n>impl</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Arg</span><span class=tok-o>&gt;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>nth</span><span class=tok-o>-</span><span class=tok-n>value</span><span class=tok-o>-</span><span class=tok-n>impl</span> <span class=tok-n>or_</span><span class=tok-p>(</span><span class=tok-n>Arg</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>fallback</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>
        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Arg</span><span class=tok-o>&gt;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>nth</span><span class=tok-o>-</span><span class=tok-n>value</span><span class=tok-o>-</span><span class=tok-n>impl</span> <span class=tok-k>operator</span><span class=tok-o>||</span><span class=tok-p>(</span><span class=tok-n>Arg</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>fallback</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>

        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Fn</span><span class=tok-o>&gt;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>nth</span><span class=tok-o>-</span><span class=tok-n>value</span><span class=tok-o>-</span><span class=tok-n>impl</span> <span class=tok-n>map</span><span class=tok-p>(</span><span class=tok-n>Fn</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>fn</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>N</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>nth_value</span> <span class=tok-o>=</span> <span class=tok-n>nth</span><span class=tok-o>-</span><span class=tok-n>value</span><span class=tok-o>-</span><span class=tok-n>impl</span><span class=tok-o>&lt;</span><span class=tok-n>N</span><span class=tok-o>&gt;</span><span class=tok-p>{};</span>

    <span class=tok-kr>inline</span> <span class=tok-k>namespace</span> <span class=tok-n>placeholders</span>
    <span class=tok-p>{</span>
        <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>_1</span> <span class=tok-o>=</span> <span class=tok-n>nth_value</span><span class=tok-o>&lt;</span><span class=tok-mi>1</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
        <span class=tok-err>…</span>
        <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>_8</span> <span class=tok-o>=</span> <span class=tok-n>nth_value</span><span class=tok-o>&lt;</span><span class=tok-mi>8</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
    <span class=tok-p>}</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The bind placeholder <code>lexy::nth_value&lt;N></code> expands to the `N`th argument passed to the bound callback, i.e. the `N`th argument produced by a rule.
Arguments are indexed beginning with 1.
For convenience, placeholders 1 through 8 are pre-defined.</p></div><div class=paragraph><p>The member function <code>.map()</code> takes a function <code>fn</code> and returns a placeholder that will expand to <code>fn(value)</code>, where <code>value</code> is the `N`th argument.
It supports member pointers.</p></div><div class=paragraph><p>The member function <code>.or_()</code> (or alternatively spelled <code>||</code>/<code>or</code>) provides a <code>fallback</code> value.
If there are fewer than <code>N</code> arguments, it expands to <code>fallback</code>.
Without a fallback, this would be a compile-time error.
If the <code>N`th argument is of type `lexy::nullopt</code> (e.g. as produced by a <code>dsl::opt()</code> rule), it expands to <code>fallback</code>.
Without a fallback, it would expand to the <code>lexy::nullopt</code> value unchanged.</p></div><div class=paragraph><p>If both a mapping and a fallback is specified, the fallback is not passed to <code>fn</code> but kept as-is.</p></div></div><div class=sect4><h5 id=_lexyvalues><code>lexy::values</code></h5><div class=listingblock><div class=title><code>lexy/callback/bind.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>values</span> <span class=tok-o>=</span> <span class=tok-n>values</span><span class=tok-o>-</span><span class=tok-n>impl</span><span class=tok-p>{};</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The bind placeholder <code>lexy::values</code> expands to all arguments passed to the bound callback, unchanged and in the same order.
If the bound callback is invoked with <code>N</code> arguments, it is equivalent to passing <code>lexy::_1, …​, lexy::nth_value&lt;N></code>.</p></div><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>If you use <code>lexy::nth_value&lt;N></code> and <code>lexy::values</code>, the `N`th argument will be duplicated.</td></tr></tbody></table></div></div><div class=sect4><h5 id=_lexyparse_state><code>lexy::parse_state</code></h5><div class=listingblock><div class=title><code>lexy/callback/bind.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>class</span> <span class=tok-nc>parse</span><span class=tok-o>-</span><span class=tok-n>state</span><span class=tok-o>-</span><span class=tok-n>impl</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Fn</span><span class=tok-o>&gt;</span>
        <span class=tok-k>constexpr</span> <span class=tok-n>parse</span><span class=tok-o>-</span><span class=tok-n>state</span><span class=tok-o>-</span><span class=tok-n>impl</span> <span class=tok-n>map</span><span class=tok-p>(</span><span class=tok-n>Fn</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>fn</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>parse_state</span> <span class=tok-o>=</span> <span class=tok-n>parse</span><span class=tok-o>-</span><span class=tok-n>state</span><span class=tok-o>-</span><span class=tok-n>impl</span><span class=tok-p>{};</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The bind placeholder <code>lexy::parse_state</code> expands to the state passed in the second overload of <code>lexy::parse()</code>.
If there is no parse state, e.g. because the first overload was used or the callback is invoked in a different context, the program is ill-formed.</p></div><div class=paragraph><p>The member function <code>.map()</code> takes a function <code>fn</code> and returns a placeholder that will expand to <code>fn(state)</code>, where <code>state</code> is the parse state.
It supports member pointers.</p></div><div class="admonitionblock tip"><table><tbody><tr><td class=icon><div class=title>Tip</div></td><td class=content>Use <code>lexy::parse_state</code> to pass allocators to your containers.</td></tr></tbody></table></div></div></div><div class=sect3><h4 id=_folding_and_counting>Folding and counting</h4><div class=listingblock><div class=title><code>lexy/callback/fold.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>T</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Arg</span> <span class=tok-o>=</span> <span class=tok-n>T</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Op</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>fold</span><span class=tok-p>(</span><span class=tok-n>Arg</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>init</span><span class=tok-p>,</span> <span class=tok-n>Op</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>op</span><span class=tok-p>);</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>T</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Arg</span> <span class=tok-o>=</span> <span class=tok-n>T</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Op</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>fold_inplace</span><span class=tok-p>(</span><span class=tok-n>Arg</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>init</span><span class=tok-p>,</span> <span class=tok-n>Op</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>op</span><span class=tok-p>);</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p><code>lexy::fold</code> and <code>lexy::fold_inplace</code> are both callbacks and sinks.</p></div><div class=paragraph><p>As a callback, they initialize their result of type <code>T</code> from <code>init</code> and then perform a left fold over all arguments:
<code>lexy::fold</code> with <code>result = invoke(op)(result, arg)</code>, <code>lexy::fold_inplace</code> with <code>invoke(op)(result, arg)</code>,
where <code>arg</code> ranges over the arguments in order.</p></div><div class=paragraph><p>As a sink, they also initialize their result of type <code>T</code> from <code>init</code> and then fold with every invocation of the sink callback:
<code>lexy::fold</code> with <code>result = invoke(op)(result, args…​)</code>, <code>lexy::fold_inplace</code> with <code>invoke(op)(result, args…​)</code>,
where <code>args</code> are the argument of the sink callback.</p></div><div class=listingblock><div class=title><code>lexy/callback/fold.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>count</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p><code>lexy::count</code> is a callback and a sink that counts the number of arguments.</p></div><div class=paragraph><p>As a callback, it returns the number of arguments it was invoked with as a <code>std::size_t</code>.
As a sink, it returns the number of invocations of the sink callback as a <code>std::size_t</code>.
Each invocation of the sink callback can be done with an arbitrary number of arguments that are all ignored itself.</p></div><div class=paragraph><p>It is equivalent to a <code>lexy::fold</code> with <code>init</code> to <code>0</code> and where the operation increments the result and ignores all other arguments.</p></div></div><div class=sect3><h4 id=_rule_specific_callbacks>Rule-specific callbacks</h4><div class=listingblock><div class=title><code>lexy/callback/aggregate.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>T</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>as_aggregate</span> <span class=tok-o>=</span> <span class=tok-cm>/* unspecified */</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The callback and sink <code>lexy::as_aggregate&lt;T></code> is only used together with the <code>lexy::dsl::member</code> rule and documented there.</p></div><div class=listingblock><div class=title><code>lexy/callback/integer.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>T</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>as_integer</span> <span class=tok-o>=</span> <span class=tok-cm>/* unspecified */</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The callback <code>lexy::as_integer&lt;T></code> constructs an integer type <code>T</code> and has three overloads:</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Integer</span><span class=tok-o>&gt;</span>
<span class=tok-n>T</span> <span class=tok-k>operator</span><span class=tok-p>()(</span><span class=tok-k>const</span> <span class=tok-n>Integer</span><span class=tok-o>&amp;</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span> // <b class=conum>(1)</b>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Integer</span><span class=tok-o>&gt;</span>
<span class=tok-n>T</span> <span class=tok-k>operator</span><span class=tok-p>()(</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>plus_sign</span> <span class=tok-n>sign</span><span class=tok-p>,</span> <span class=tok-k>const</span> <span class=tok-n>Integer</span><span class=tok-o>&amp;</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>  // <b class=conum>(2)</b>
<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Integer</span><span class=tok-o>&gt;</span>
<span class=tok-n>T</span> <span class=tok-k>operator</span><span class=tok-p>()(</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>minus_sign</span> <span class=tok-n>sign</span><span class=tok-p>,</span> <span class=tok-k>const</span> <span class=tok-n>Integer</span><span class=tok-o>&amp;</span> <span class=tok-n>value</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span> // <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns <code>T(value)</code>.</p></li><li><p>Returns <code>T(sign * value)</code>.</p></li></ol></div><div class=paragraph><p>The second overload is meant to be used together with <code>lexy::dsl::sign</code> and related rules.</p></div></div></div><div class=sect2><h3 id=_error_handling>Error handling</h3><div class=paragraph><p>Parsing errors are reported by constructing a <code>lexy::error</code> object and passing it to the error callback of <code>lexy::parse</code> and <code>lexy::validate</code> together with the <code>lexy::error_context</code>.
The error callback must either be a sink, in which case it can return an arbitrary type that represents a collection of all the errors,
or is a non-sink callback that returns <code>void</code>, in which case it will be passed to <code>lexy::collect()</code> to turn it into a sink.</p></div><div class=paragraph><p>The <code>error_type</code> of <code>lexy::validate_result</code> and <code>lexy::parse_result</code> will be the return type of the sink.
For a <code>void</code> returning non-sink callback it will be <code>std::size_t</code>, which is the result of <code>lexy::collect()</code>.</p></div><details><summary class=title>Example</summary><div class=content><div class=listingblock><div class=title>A <code>void</code>-returning error callback that is not a sink.</div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>ErrorCallbackVoid</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>using</span> <span class=tok-n>return_type</span> <span class=tok-o>=</span> <span class=tok-kt>void</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-o>&gt;</span>
    <span class=tok-kt>void</span> <span class=tok-k>operator</span><span class=tok-p>()(</span><span class=tok-k>const</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>error_context</span><span class=tok-o>&lt;</span><span class=tok-n>Production</span><span class=tok-p>,</span> <span class=tok-n>Input</span><span class=tok-o>&gt;&amp;</span> <span class=tok-n>context</span><span class=tok-p>,</span>
                           <span class=tok-k>const</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>error</span><span class=tok-o>&lt;</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>Tag</span><span class=tok-o>&gt;&amp;</span> <span class=tok-n>error</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=listingblock><div class=title>A non-<code>void</code>-returning error callback that is a sink.</div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>ErrorCallbackSink</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>class</span> <span class=tok-nc>Sink</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>using</span> <span class=tok-n>return_type</span> <span class=tok-o>=</span> <span class=tok-cm>/* ... */</span><span class=tok-p>;</span>

        <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-o>&gt;</span>
        <span class=tok-kt>void</span> <span class=tok-k>operator</span><span class=tok-p>()(</span><span class=tok-k>const</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>error_context</span><span class=tok-o>&lt;</span><span class=tok-n>Production</span><span class=tok-p>,</span> <span class=tok-n>Input</span><span class=tok-o>&gt;&amp;</span> <span class=tok-n>context</span><span class=tok-p>,</span>
                               <span class=tok-k>const</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>error</span><span class=tok-o>&lt;</span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>Tag</span><span class=tok-o>&gt;&amp;</span> <span class=tok-n>error</span><span class=tok-p>)</span> <span class=tok-k>const</span><span class=tok-p>;</span>

        <span class=tok-n>return_type</span> <span class=tok-nf>finish</span><span class=tok-p>()</span> <span class=tok-o>&amp;&amp;</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-n>Sink</span> <span class=tok-nf>sink</span><span class=tok-p>();</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>Of course, overloading can be used to differentiate between various error types and contexts.</p></div></div></details><div class=sect3><h4 id=_error_types>Error types</h4><div class=listingblock><div class=title><code>lexy/error.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-p>;</span>

    <span class=tok-k>struct</span> <span class=tok-nc>expected_literal</span> <span class=tok-p>{};</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>expected_literal</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>

    <span class=tok-k>struct</span> <span class=tok-nc>expected_keyword</span> <span class=tok-p>{};</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>expected_keyword</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>

    <span class=tok-k>struct</span> <span class=tok-nc>expected_char_class</span> <span class=tok-p>{};</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>expected_char_class</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-o>&gt;</span>
    <span class=tok-k>using</span> <span class=tok-n>error_for</span> <span class=tok-o>=</span> <span class=tok-n>error</span><span class=tok-o>&lt;</span><span class=tok-n>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>Tag</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-p>...</span> <span class=tok-n>Args</span><span class=tok-o>&gt;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>make_error</span><span class=tok-p>(</span><span class=tok-n>Args</span><span class=tok-o>&amp;&amp;</span><span class=tok-p>...</span> <span class=tok-n>args</span><span class=tok-p>);</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>All errors are represented by instantiations of <code>lexy::error&lt;Reader, Tag></code>.
The <code>Tag</code> is an empty type that specifies the kind of error.
There are specializations for two tags to store additional information.</p></div><div class=paragraph><p>The function <code>lexy::make_error</code> constructs an error object given the reader and tag by forwarding all the arguments.</p></div><div class=sect4><h5 id=_generic_error>Generic error</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Tag</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>error</span>
<span class=tok-p>{</span>
    <span class=tok-k>using</span> <span class=tok-n>iterator</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span><span class=tok-p>;</span>

<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>error</span><span class=tok-p>(</span><span class=tok-n>iterator</span> <span class=tok-n>pos</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>error</span><span class=tok-p>(</span><span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>message</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>The primary class template <code>lexy::error&lt;Reader, Tag></code> represents a generic error without additional metadata.
It can either be constructed giving it a single position, then <code>position() == begin() == end()</code>;
or a range of the input, then <code>position() == begin() ⇐ end()</code>.</p></div><div class=paragraph><p>The <code>message()</code> is determined using the <code>Tag</code>.
By default, it returns the type name of <code>Tag</code> after removing the top-level namespace name.
This can be overridden by defining either <code>Tag::name()</code> or <code>Tag::name</code>.</p></div></div><div class=sect4><h5 id=_expected_literal_error>Expected literal error</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>struct</span> <span class=tok-nc>expected_literal</span>
<span class=tok-p>{};</span>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>expected_literal</span><span class=tok-o>&gt;</span>
<span class=tok-p>{</span>
    <span class=tok-k>using</span> <span class=tok-n>iterator</span>    <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span><span class=tok-p>;</span>

<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>error</span><span class=tok-p>(</span><span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>,</span>
                             <span class=tok-k>const</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-o>*</span> <span class=tok-n>string</span><span class=tok-p>,</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>index</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>string</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span> <span class=tok-o>-&gt;</span> <span class=tok-k>const</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-o>*</span><span class=tok-p>;</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>character</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span> <span class=tok-o>-&gt;</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>index</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>A specialization of <code>lexy::error</code> is provided if <code>Tag == lexy::expected_literal</code>.
It represents the error where a literal string was expected, but could not be matched.
It is mainly raised by the <code>lexy::dsl::lit</code> rule.</p></div><div class=paragraph><p>The error happens at a given <code>position()</code> and with a given <code>string()</code>.
The <code>index()</code> is the index into the string where matching failed; e.g. <code>0</code> if the input starts with a different character, <code>2</code> if the first two characters matched, etc.
The <code>character()</code> is the string character at that index.</p></div></div><div class=sect4><h5 id=_expected_keyword_error>Expected keyword error</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>struct</span> <span class=tok-nc>expected_keyword</span>
<span class=tok-p>{};</span>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>expected_keyword</span><span class=tok-o>&gt;</span>
<span class=tok-p>{</span>
    <span class=tok-k>using</span> <span class=tok-n>iterator</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span><span class=tok-p>;</span>

<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>error</span><span class=tok-p>(</span><span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>,</span>
                             <span class=tok-k>const</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-o>*</span> <span class=tok-n>str</span><span class=tok-p>);</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-k>auto</span> <span class=tok-n>string</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span> <span class=tok-o>-&gt;</span> <span class=tok-k>const</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>char_type</span><span class=tok-o>*</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>A specialization of <code>lexy::error</code> is provided if <code>Tag == lexy::expected_keyword</code>.
It represents the error where a keyword was expected, but could not be matched.
It is raised by the <code>lexy::dsl::keyword</code> rule.</p></div><div class=paragraph><p>The error happens at a given <code>position()</code> and with a given <code>string()</code>, which is the text of the keyword.
<code>begin()</code> and <code>end()</code> span the entire range of the identifier, which should have been <code>string()</code> but wasn’t.</p></div></div><div class=sect4><h5 id=_character_class_error>Character class error</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>struct</span> <span class=tok-nc>expected_char_class</span>
<span class=tok-p>{};</span>

<span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>error</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>expected_char_class</span><span class=tok-o>&gt;</span>
<span class=tok-p>{</span>
    <span class=tok-k>using</span> <span class=tok-n>iterator</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span><span class=tok-p>;</span>

<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>error</span><span class=tok-p>(</span><span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>,</span> <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>name</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>name</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>A specialization of <code>lexy::error</code> is provided if <code>Tag == lexy::expected_char_class</code>.
It represents the error where any character from a given set of characters was expected, but could not be matched.
It is raised by the <code>lexy::dsl::ascii::*</code> rules or <code>lexy::dsl::newline</code>, among others.</p></div><div class=paragraph><p>The error happens at the given <code>position()</code> and a symbolic name of the character class is returned by <code>name()</code>.
By convention, the name format used is <code>&lt;group>.&lt;name></code> or <code>&lt;name></code>, where both <code>&lt;group></code> and <code>&lt;name></code> consist of characters.
Examples include <code>newline</code>, <code>ASCII.alnum</code> and <code>digit.decimal</code>.</p></div></div></div><div class=sect3><h4 id=_error_context>Error context</h4><div class=listingblock><div class=title><code>lexy/error.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>error_context</span>
    <span class=tok-p>{</span>
        <span class=tok-k>using</span> <span class=tok-n>iterator</span> <span class=tok-o>=</span> <span class=tok-k>typename</span> <span class=tok-nc>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;::</span><span class=tok-n>iterator</span><span class=tok-p>;</span>

    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>error_context</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>,</span> <span class=tok-n>iterator</span> <span class=tok-n>pos</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>static</span> <span class=tok-k>consteval</span> <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>production</span><span class=tok-p>();</span>

        <span class=tok-k>constexpr</span> <span class=tok-n>iterator</span> <span class=tok-n>position</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The class <code>lexy::error_context&lt;Production, Input></code> contain information about the context where the error occurred.</p></div><div class=paragraph><p>The entire input containing the error is returned by <code>input()</code>.</p></div><div class=paragraph><p>The <code>Production</code> whose rule has raised the error is specified as template parameter and its name returned by <code>production()</code>.
Like <code>lexy::error&lt;Reader, Tag>::message()</code>, it returns the name of the type without the top level namespace name.
This can be overridden by defining <code>Production::name()</code> or <code>Production::name</code>.</p></div><div class=paragraph><p>The <code>position()</code> of the error context is the input position where the production started parsing.</p></div></div></div><div class=sect2><h3 id=_parse_tree>Parse Tree</h3><div class=listingblock><div class=title><code>lexy/parse_tree.hpp</code></div><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>namespace</span> <span class=tok-n>lexy</span>
<span class=tok-p>{</span>
    <span class=tok-k>enum</span> <span class=tok-k>class</span> <span class=tok-nc>traverse_event</span>
    <span class=tok-p>{</span>
        <span class=tok-n>enter</span><span class=tok-p>,</span>
        <span class=tok-n>exit</span><span class=tok-p>,</span>
        <span class=tok-n>leaf</span><span class=tok-p>,</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span> <span class=tok-o>=</span> <span class=tok-kt>void</span><span class=tok-p>,</span>
              <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default */</span><span class=tok-o>&gt;</span>
    <span class=tok-k>class</span> <span class=tok-nc>parse_tree</span>
    <span class=tok-p>{</span>
    <span class=tok-k>public</span><span class=tok-o>:</span>
        <span class=tok-k>class</span> <span class=tok-nc>builder</span><span class=tok-p>;</span>

        <span class=tok-k>constexpr</span> <span class=tok-nf>parse_tree</span><span class=tok-p>();</span>
        <span class=tok-k>constexpr</span> <span class=tok-k>explicit</span> <span class=tok-n>parse_tree</span><span class=tok-p>(</span><span class=tok-n>MemoryResource</span><span class=tok-o>*</span> <span class=tok-n>resource</span><span class=tok-p>);</span>

        <span class=tok-kt>bool</span> <span class=tok-nf>empty</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-kt>void</span> <span class=tok-nf>clear</span><span class=tok-p>()</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

        <span class=tok-k>class</span> <span class=tok-nc>node</span><span class=tok-p>;</span>
        <span class=tok-k>class</span> <span class=tok-nc>node_kind</span><span class=tok-p>;</span>

        <span class=tok-n>node</span> <span class=tok-nf>root</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> <span class=tok-c1>// requires: !empty()</span>

        <span class=tok-k>class</span> <span class=tok-nc>traverse_range</span><span class=tok-p>;</span>

        <span class=tok-n>traverse_range</span> <span class=tok-nf>traverse</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>node</span><span class=tok-o>&amp;</span> <span class=tok-n>n</span><span class=tok-p>)</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
        <span class=tok-n>traverse_range</span> <span class=tok-nf>traverse</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-p>};</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span> <span class=tok-o>=</span> <span class=tok-kt>void</span><span class=tok-p>,</span>
              <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span> <span class=tok-o>=</span> <span class=tok-cm>/* default */</span><span class=tok-o>&gt;</span>
    <span class=tok-k>using</span> <span class=tok-n>parse_tree_for</span> <span class=tok-o>=</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>parse_tree</span><span class=tok-o>&lt;</span><span class=tok-n>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Input</span><span class=tok-p>,</span>
              <span class=tok-k>typename</span> <span class=tok-nc>ErrorCallback</span><span class=tok-o>&gt;</span>
    <span class=tok-k>auto</span> <span class=tok-n>parse_as_tree</span><span class=tok-p>(</span><span class=tok-n>parse_tree</span><span class=tok-o>&lt;</span><span class=tok-n>input_reader</span><span class=tok-o>&lt;</span><span class=tok-n>Input</span><span class=tok-o>&gt;</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;&amp;</span> <span class=tok-n>tree</span><span class=tok-p>,</span>
                       <span class=tok-k>const</span> <span class=tok-n>Input</span><span class=tok-o>&amp;</span> <span class=tok-n>input</span><span class=tok-p>,</span> <span class=tok-n>ErrorCallback</span> <span class=tok-n>error_callback</span><span class=tok-p>)</span>
      <span class=tok-o>-&gt;</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>validate_result</span><span class=tok-o>&lt;</span><span class=tok-n>ErrorCallback</span><span class=tok-o>&gt;</span><span class=tok-p>;</span>
<span class=tok-p>}</span></code></pre></div></div><div class=paragraph><p>The class <code>lexy::parse_tree</code> represents a lossless untyped syntax tree.</p></div><div class=paragraph><p>The function <code>lexy::parse_as_tree()</code> parses a <code>Production</code> on the given <code>input</code> and constructs a lossless parse tree from the result.
All parse errors are passed to the error callback (see <a href=#_error_handling>Error handling</a>) and later returned.
If a non-recoverable parse error happens, the tree will be cleared, otherwise it contains the (partial) parse tree of the input.
It will discard any values produced by parsing the rules.</p></div><div class=paragraph><p>The resulting parse tree will contain a parent node for each production, and leaf node for every token.
If a token is empty and has an unknown token kind, it will not be added to the parse tree.
If a production inherits from <code>lexy::transparent_production</code>, no separate node will be created;
instead all child nodes will be added to its parent.
If a production inherits from <code>lexy::token_production</code>, tokens are merged when possible:
if there are two or more tokens with the same kind directly after each other, only a single node spanning all of them will be added,
as opposed to multiple nodes for each individual token.</p></div><div class=paragraph><p>Traversing the tree and concatenating the lexemes of all tokens will result in the original input.</p></div><div class=sect3><h4 id=_manual_tree_building>Manual Tree Building</h4><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>parse_tree</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;::</span><span class=tok-n>builder</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-k>explicit</span> <span class=tok-n>builder</span><span class=tok-p>(</span><span class=tok-n>parse_tree</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>tree</span><span class=tok-p>,</span> <span class=tok-n>Production</span> <span class=tok-n>production</span><span class=tok-p>);</span> // <b class=conum>(1)</b>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-k>explicit</span> <span class=tok-n>builder</span><span class=tok-p>(</span><span class=tok-n>Production</span> <span class=tok-n>production</span><span class=tok-p>);</span> // <b class=conum>(2)</b>

    <span class=tok-k>struct</span> <span class=tok-nc>production_state</span><span class=tok-p>;</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-n>production_state</span> <span class=tok-n>start_production</span><span class=tok-p>(</span><span class=tok-n>Production</span> <span class=tok-n>production</span><span class=tok-p>);</span> // <b class=conum>(3)</b>

    <span class=tok-kt>void</span> <span class=tok-nf>token</span><span class=tok-p>(</span><span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>kind</span><span class=tok-p>,</span>
               <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span> <span class=tok-n>begin</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-o>::</span><span class=tok-n>iterator</span> <span class=tok-n>end</span><span class=tok-p>);</span> // <b class=conum>(4)</b>

    <span class=tok-kt>void</span> <span class=tok-nf>finish_production</span><span class=tok-p>(</span><span class=tok-n>production_state</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>s</span><span class=tok-p>);</span> // <b class=conum>(5)</b>
    <span class=tok-kt>void</span> <span class=tok-nf>backtrack_production</span><span class=tok-p>(</span><span class=tok-n>production_state</span><span class=tok-o>&amp;&amp;</span> <span class=tok-n>s</span><span class=tok-p>);</span> // <b class=conum>(6)</b>

    <span class=tok-n>parse_tree</span> <span class=tok-nf>finish</span><span class=tok-p>()</span> <span class=tok-o>&amp;&amp;</span><span class=tok-p>;</span> // <b class=conum>(7)</b>
<span class=tok-p>};</span></code></pre></div></div><div class="colist arabic"><ol><li><p>Create a builder that will re-use the memory of the existing <code>tree</code>.
Its root node will be associated with the given <code>Production</code>.</p></li><li><p>Same as above, but does not re-use memory.</p></li><li><p>Adds a production child node as last child of the current node and activates it.
Returns a handle that remembers the previous current node.</p></li><li><p>Adds a token node to the current node.</p></li><li><p>Finishes with a child production and activates its parent.</p></li><li><p>Cancels the currently activated node, by deallocating it and all children.
Activates its parent node again.</p></li><li><p>Returns the finished tree.</p></li></ol></div></div><div class=sect3><h4 id=_tree_node>Tree Node</h4><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>parse_tree</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;::</span><span class=tok-n>node_kind</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-kt>bool</span> <span class=tok-n>is_token</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-kt>bool</span> <span class=tok-nf>is_production</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-kt>bool</span> <span class=tok-nf>is_root</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-kt>bool</span> <span class=tok-nf>is_token_production</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>const</span> <span class=tok-kt>char</span><span class=tok-o>*</span> <span class=tok-n>name</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>node_kind</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>node_kind</span> <span class=tok-n>rhs</span><span class=tok-p>);</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>node_kind</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>node_kind</span> <span class=tok-n>rhs</span><span class=tok-p>);</span>

    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>,</span> <span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>tk</span><span class=tok-p>);</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>tk</span><span class=tok-p>,</span> <span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>);</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>,</span> <span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>tk</span><span class=tok-p>);</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>token_kind</span><span class=tok-o>&lt;</span><span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>tk</span><span class=tok-p>,</span> <span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>);</span>

    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>,</span> <span class=tok-n>Production</span><span class=tok-p>);</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>Production</span> <span class=tok-n>p</span><span class=tok-p>,</span> <span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>);</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>,</span> <span class=tok-n>Production</span> <span class=tok-n>p</span><span class=tok-p>);</span>
    <span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Production</span><span class=tok-o>&gt;</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>Production</span> <span class=tok-n>p</span><span class=tok-p>,</span> <span class=tok-n>node_kind</span> <span class=tok-n>nk</span><span class=tok-p>);</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>The class <code>node_kind</code> stores information over the kind of node.
Nodes are either associated with a <code>Production</code> or a token rule.
The root node is always a <code>Production</code> node.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>template</span> <span class=tok-o>&lt;</span><span class=tok-k>typename</span> <span class=tok-nc>Reader</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>TokenKind</span><span class=tok-p>,</span> <span class=tok-k>typename</span> <span class=tok-nc>MemoryResource</span><span class=tok-o>&gt;</span>
<span class=tok-k>class</span> <span class=tok-nc>parse_tree</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-p>,</span> <span class=tok-n>MemoryResource</span><span class=tok-o>&gt;::</span><span class=tok-n>node</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-kt>void</span><span class=tok-o>*</span> <span class=tok-n>address</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-n>node_kind</span> <span class=tok-nf>kind</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-n>node</span> <span class=tok-nf>parent</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-cm>/* sized range */</span> <span class=tok-n>children</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-cm>/* range */</span> <span class=tok-n>siblings</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-kt>bool</span> <span class=tok-nf>is_last_child</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>lexeme</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-o>&gt;</span> <span class=tok-n>lexeme</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>token</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>token</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>==</span><span class=tok-p>(</span><span class=tok-n>node</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>node</span> <span class=tok-n>rhs</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-k>friend</span> <span class=tok-kt>bool</span> <span class=tok-k>operator</span><span class=tok-o>!=</span><span class=tok-p>(</span><span class=tok-n>node</span> <span class=tok-n>lhs</span><span class=tok-p>,</span> <span class=tok-n>node</span> <span class=tok-n>rhs</span><span class=tok-p>)</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span></code></pre></div></div><div class=paragraph><p>The class <code>node</code> is a reference to a node in the tree.
Two nodes are equal if and only if they point to the same node in the same tree.</p></div><div class=sect4><h5 id=_parent_access>Parent Access</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-n>node</span> <span class=tok-nf>parent</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span></code></pre></div></div><div class=paragraph><p>Returns a reference to a parent node.
For the root node, returns a reference to itself.</p></div><div class=paragraph><p>This operation is <code>O(number of siblings)</code>.</p></div></div><div class=sect4><h5 id=_child_access>Child Access</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>children_range</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>class</span> <span class=tok-nc>iterator</span><span class=tok-p>;</span> <span class=tok-c1>// value_type = node</span>
    <span class=tok-k>class</span> <span class=tok-nc>sentinel</span><span class=tok-p>;</span>

    <span class=tok-n>iterator</span> <span class=tok-nf>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-n>sentinel</span> <span class=tok-nf>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-kt>bool</span> <span class=tok-nf>empty</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-n>std</span><span class=tok-o>::</span><span class=tok-kt>size_t</span> <span class=tok-n>size</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span>

<span class=tok-n>children_range</span> <span class=tok-nf>children</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span></code></pre></div></div><div class=paragraph><p>Returns a range object that iterates over all children of the node.
For a token node, this is always the empty range.</p></div></div><div class=sect4><h5 id=_sibling_access>Sibling Access</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>sibling_range</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>class</span> <span class=tok-nc>iterator</span><span class=tok-p>;</span> <span class=tok-c1>// value_type = node</span>

    <span class=tok-n>iterator</span> <span class=tok-nf>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-n>iterator</span> <span class=tok-nf>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-kt>bool</span> <span class=tok-nf>empty</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span>

<span class=tok-n>sibling_range</span> <span class=tok-nf>siblings</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span></code></pre></div></div><div class=paragraph><p>Returns a range object that iterates over all siblings of a node.
It begins with the sibling that is immediately following the node,
and continues until it reached the last child of the parent.
Then iteration wraps around to the first child of the parent until it ends at the original node.
The original node is not included in the sibling range.</p></div></div><div class=sect4><h5 id=_token_access>Token Access</h5><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>lexeme</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-o>&gt;</span> <span class=tok-n>lexeme</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
<span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>token</span><span class=tok-o>&lt;</span><span class=tok-n>Reader</span><span class=tok-p>,</span> <span class=tok-n>TokenKind</span><span class=tok-o>&gt;</span> <span class=tok-n>token</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns the spelling of a token node. For a production node, returns the empty lexeme.</p></li><li><p>Returns the spelling and token kind of a token node; must not be called on a production node.</p></li></ol></div></div></div><div class=sect3><h4 id=_tree_traversal>Tree Traversal</h4><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>enum</span> <span class=tok-k>class</span> <span class=tok-nc>traverse_event</span>
<span class=tok-p>{</span>
    <span class=tok-n>enter</span><span class=tok-p>,</span>
    <span class=tok-n>exit</span><span class=tok-p>,</span>
    <span class=tok-n>leaf</span><span class=tok-p>,</span>
<span class=tok-p>};</span></code></pre></div></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>class</span> <span class=tok-nc>traverse_range</span>
<span class=tok-p>{</span>
<span class=tok-k>public</span><span class=tok-o>:</span>
    <span class=tok-k>class</span> <span class=tok-nc>iterator</span><span class=tok-p>;</span> <span class=tok-c1>// value_type = { traverse_event, node }</span>

    <span class=tok-n>iterator</span> <span class=tok-nf>begin</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
    <span class=tok-n>iterator</span> <span class=tok-nf>end</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>

    <span class=tok-kt>bool</span> <span class=tok-nf>empty</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span>
<span class=tok-p>};</span>

<span class=tok-n>traverse_range</span> <span class=tok-nf>traverse</span><span class=tok-p>(</span><span class=tok-k>const</span> <span class=tok-n>node</span><span class=tok-o>&amp;</span> <span class=tok-n>n</span><span class=tok-p>)</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(1)</b>
<span class=tok-n>traverse_range</span> <span class=tok-nf>traverse</span><span class=tok-p>()</span> <span class=tok-k>const</span> <span class=tok-k>noexcept</span><span class=tok-p>;</span> // <b class=conum>(2)</b></code></pre></div></div><div class="colist arabic"><ol><li><p>Returns a range that traverses descendants of the given node.</p></li><li><p>Returns a range that traverses the root node, or an empty range if the tree is empty.</p></li></ol></div><div class=paragraph><p>The <code>traverse_range</code> iterates over a node and all its children and their children and so on.
Its value type is a (unspecified) pair whose first member is a <code>lexy::traverse_event</code> and whose second member is a <code>node</code> reference.</p></div><div class=paragraph><p>For a token node, the range contains only the original node with event <code>leaf</code>.</p></div><div class=paragraph><p>For a production node, the range begins with the original node and event <code>enter</code>.
It then does an in-order traversal of all descendants, beginning with the children of a node.
When it reaches a token node, produces it with event <code>leaf</code>.
When it reaches a production node, produces it with event <code>enter</code>, then all its descendants recursively, and then with event <code>exit</code>.
After all descendants of the original node have been produced, finishes with the original node again and event <code>exit</code>.</p></div><details><summary class=title>Example</summary><div class=content><div class=paragraph><p>Prints a tree.</p></div><div class=listingblock><div class=content><pre class="pygments highlight"><code data-lang=cpp><span></span><span class=tok-k>auto</span> <span class=tok-n>depth</span> <span class=tok-o>=</span> <span class=tok-mi>0</span><span class=tok-p>;</span>
<span class=tok-k>for</span> <span class=tok-p>(</span><span class=tok-k>auto</span> <span class=tok-p>[</span><span class=tok-n>event</span><span class=tok-p>,</span> <span class=tok-n>node</span><span class=tok-p>]</span> <span class=tok-o>:</span> <span class=tok-n>tree</span><span class=tok-p>.</span><span class=tok-n>traverse</span><span class=tok-p>())</span>
<span class=tok-p>{</span>
    <span class=tok-k>switch</span> <span class=tok-p>(</span><span class=tok-n>event</span><span class=tok-p>)</span>
    <span class=tok-p>{</span>
    <span class=tok-k>case</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>traverse_event</span><span class=tok-o>::</span><span class=tok-nl>enter</span><span class=tok-p>:</span>
        <span class=tok-o>++</span><span class=tok-n>depth</span><span class=tok-p>;</span>
        <span class=tok-n>indent</span><span class=tok-p>(</span><span class=tok-n>depth</span><span class=tok-p>);</span>
        <span class=tok-n>print_node</span><span class=tok-p>(</span><span class=tok-n>node</span><span class=tok-p>);</span>
        <span class=tok-k>break</span><span class=tok-p>;</span>
    <span class=tok-k>case</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>traverse_event</span><span class=tok-o>::</span><span class=tok-nl>exit</span><span class=tok-p>:</span>
        <span class=tok-o>--</span><span class=tok-n>depth</span><span class=tok-p>;</span>
        <span class=tok-k>break</span><span class=tok-p>;</span>

    <span class=tok-k>case</span> <span class=tok-n>lexy</span><span class=tok-o>::</span><span class=tok-n>traverse_event</span><span class=tok-o>::</span><span class=tok-nl>leaf</span><span class=tok-p>:</span>
        <span class=tok-n>indent</span><span class=tok-p>(</span><span class=tok-n>depth</span><span class=tok-p>);</span>
        <span class=tok-n>print_node</span><span class=tok-p>(</span><span class=tok-n>node</span><span class=tok-p>);</span>
        <span class=tok-k>break</span><span class=tok-p>;</span>
    <span class=tok-p>}</span>
<span class=tok-p>}</span></code></pre></div></div></div></details><div class="admonitionblock note"><table><tbody><tr><td class=icon><div class=title>Note</div></td><td class=content>Traversing a node just does pointer chasing.
There is no allocation or recursion involved.</td></tr></tbody></table></div></div></div></div></div><div class=sect1><h2 id=_the_rule_dsl>The rule DSL</h2><div class=sectionbody><div class=paragraph><p>This documentation has been moved <a href=/reference/dsl/>here</a>.</p></div></div></div><div class=sect1><h2 id=_glossary>Glossary</h2><div class=sectionbody><div class="dlist glossary"><dl><dt>Branch</dt><dd><p>A rule that has an associated condition and will only be taken if the condition matches.
It is used to make decisions in the parsing algorithm.</p></dd><dt>Callback</dt><dd><p>A function object with a <code>return_type</code> member typedef.</p></dd><dt>Encoding</dt><dd><p>Set of pre-defined classes that define the text encoding of the input.</p></dd><dt>Error Callback</dt><dd><p>The callback used to report errors.</p></dd><dt>Grammar</dt><dd><p>An entry production and all productions referenced by it.</p></dd><dt>Input</dt><dd><p>Defines the input that will be parsed.</p></dd><dt>Production</dt><dd><p>Building-block of a grammar consisting of a rule and an optional callback that produces the parsed value.</p></dd><dt>Rule</dt><dd><p>Matches a specific input and then produces a value or an error.</p></dd><dt>Sink</dt><dd><p>A type with a <code>sink()</code> method that then returns a function object that can be called multiple times.</p></dd><dt>Token</dt><dd><p>A rule that is an atomic building block of the input.</p></dd></dl></div></div></div></article></main><footer id=page-footer><section class=copyright>&copy; <a target=_blank href=https://github.com/foonathan/lexy/blob/main/LICENSE title=License>2020-2021</a></section><section class=patreon><a target=_blank href=https://jonathanmueller.dev/support-me/>Support me!</a></section><section class=poweredby>Made with <a target=_blank href=https://gohugo.io>Hugo</a> and <a target=_blank href=https://fontawesome.com/license>Font Awesome</a>.</section></footer></body></html>